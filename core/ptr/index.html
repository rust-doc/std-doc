<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Manually manage memory through raw pointers."><meta name="keywords" content="rust, rustlang, rust-lang, ptr"><title>core::ptr - Rust</title><link rel="stylesheet" type="text/css" href="../../normalize1.58.0.css"><link rel="stylesheet" type="text/css" href="../../rustdoc1.58.0.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../light1.58.0.css" id="themeStyle"><link rel="stylesheet" type="text/css" href="../../dark1.58.0.css" disabled=""><link rel="stylesheet" type="text/css" href="../../ayu1.58.0.css" disabled=""><script id="default-settings"></script><script src="../../storage1.58.0.js"></script><script src="../../crates1.58.0.js"></script><script defer="" src="../../main1.58.0.js"></script>
    <noscript><link rel="stylesheet" href="../../noscript1.58.0.css"></noscript><link rel="alternate icon" type="image/png" href="../../favicon-16x161.58.0.png"><link rel="alternate icon" type="image/png" href="../../favicon-32x321.58.0.png"><link rel="icon" type="image/svg+xml" href="../../favicon1.58.0.svg"><style type="text/css">#crate-search{background-image:url("../../down-arrow1.58.0.svg");}</style></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu" role="button">&#9776;</div><a href='../../core/index.html'><div class='logo-container rust-logo'><img src='../../rust-logo1.58.0.png' alt='logo'></div></a><h2 class="location">Module ptr</h2><div class="sidebar-elems"><div class="block items"><ul><li><a href="#macros">Macros</a></li><li><a href="#structs">Structs</a></li><li><a href="#traits">Traits</a></li><li><a href="#functions">Functions</a></li></ul></div><div id="sidebar-vars" data-name="ptr" data-ty="mod" data-relpath="./"></div><script defer="" src="./sidebar-items.js"></script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu" title="themes"><img width="18" height="18" alt="Pick another theme!" src="../../brush1.58.0.svg"></button><div id="theme-choices" role="menu"></div></div><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><button type="button" id="help-button" title="help">?</button><a id="settings-menu" href="../../settings.html" title="settings"><img width="18" height="18" alt="Change settings" src="../../wheel1.58.0.svg"></a></div></form></nav><section id="main" class="content"><h1 class="fqn"><span class="in-band">Module <a href="../index.html">core</a>::<wbr><a class="mod" href="#">ptr</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../../clipboard1.58.0.svg" width="19" height="18" alt="Copy item path"></button></span><span class="out-of-band"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><span id="render-detail"><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span><a class="srclink" href="../../src/core/ptr/mod.rs.html#1-1580" title="goto source code">[src]</a></span></h1><details class="rustdoc-toggle top-doc" open=""><summary class="hideme"><span>Expand description</span></summary><div class="docblock" xpath="/html[1]/body[1]/section[1]/details[1]/div[1]" istranslationnode="true" main_mp="Y25yZD4/dHFyOzpsa2E="><p class="translate-text">通过原始指针手动管理内存。</p><p>Manually manage memory through raw pointers.</p>
<p class="translate-text">另请参见指针原始类型。</p><p><em><a href="../primitive.pointer.html">See also the pointer primitive types</a>.</em></p>
<h2 id="safety" class="section-header"><a href="#safety">Safety</a></h2>
<p class="translate-text">此模块中的许多函数将原始指针作为参数并对其进行读取或写入。 为了安全起见，这些指针必须有效。 指针是否有效取决于它用于（读取或写入）的操作，以及访问的内存范围（即读取/写入的字节数）。 大多数函数使用 `*mut T` 和 `*const T` 来仅访问单个值，在这种情况下，文档会忽略大小并隐式假定它是 `size_of::<t>()` 字节。</t></p><p>Many functions in this module take raw pointers as arguments and read from
or write to them. For this to be safe, these pointers must be <em>valid</em>.
Whether a pointer is valid depends on the operation it is used for
(read or write), and the extent of the memory that is accessed (i.e.,
how many bytes are read/written). Most functions use <code>*mut T</code> and <code>*const T</code>
to access only a single value, in which case the documentation omits the size
and implicitly assumes it to be <code>size_of::&lt;T&gt;()</code> bytes.</p>
<p class="translate-text">有效性的确切规则尚未确定。 此时提供的保证非常少：</p><p>The precise rules for validity are not determined yet. The guarantees that are
provided at this point are very minimal:</p>
<ul>
<li class="translate-text">“空”指针永远无效，即使对于“大小为零”的访问也是如此。</li><li>A <a href="fn.null.html" title="null">null</a> pointer is <em>never</em> valid, not even for accesses of <a href="../../nomicon/exotic-sizes.html#zero-sized-types-zsts">size zero</a>.</li>
<li class="translate-text">为了使指针有效，指针必须是可解引用的，但并不总是足够的：从指针开始的给定大小的内存范围必须全部在单个分配对象的范围内。 请注意，在 Rust 中，每个（堆栈分配的）变量都被视为一个单独的分配对象。</li><li>For a pointer to be valid, it is necessary, but not always sufficient, that the pointer
be <em>dereferenceable</em>: the memory range of the given size starting at the pointer must all be
within the bounds of a single allocated object. Note that in Rust,
every (stack-allocated) variable is considered a separate allocated object.</li>
<li class="translate-text">即使对于“大小为零”的操作，指针也不能指向已释放的内存，即，即使对于零大小的操作，释放也会使指针无效。 但是，将任何非零整数文字转换为指针对于零大小的访问都是有效的，即使某些内存恰好存在于该地址并被释放。 这对应于编写自己的分配器：分配零大小的对象并不是很难。 获取对零大小访问有效的指针的规范方法是“NonNull::dangling”。</li><li>Even for operations of <a href="../../nomicon/exotic-sizes.html#zero-sized-types-zsts">size zero</a>, the pointer must not be pointing to deallocated
memory, i.e., deallocation makes pointers invalid even for zero-sized operations. However,
casting any non-zero integer <em>literal</em> to a pointer is valid for zero-sized accesses, even if
some memory happens to exist at that address and gets deallocated. This corresponds to writing
your own allocator: allocating zero-sized objects is not very hard. The canonical way to
obtain a pointer that is valid for zero-sized accesses is <a href="struct.NonNull.html#method.dangling" title="NonNull::dangling"><code>NonNull::dangling</code></a>.</li>
<li class="translate-text">在用于在线程之间同步的“原子操作”的意义上，此模块中的函数执行的所有访问都是非原子的。 这意味着从不同线程对同一位置执行两次并发访问是未定义的行为，除非这两次访问都只从内存中读取。 请注意，这明确包括“read_volatile”和“write_volatile”：易失性访问不能用于线程间同步。</li><li>All accesses performed by functions in this module are <em>non-atomic</em> in the sense
of <a href="../sync/atomic/index.html">atomic operations</a> used to synchronize between threads. This means it is
undefined behavior to perform two concurrent accesses to the same location from different
threads unless both accesses only read from memory. Notice that this explicitly
includes <a href="fn.read_volatile.html" title="read_volatile"><code>read_volatile</code></a> and <a href="fn.write_volatile.html" title="write_volatile"><code>write_volatile</code></a>: Volatile accesses cannot
be used for inter-thread synchronization.</li>
<li class="translate-text">只要底层对象是活动的并且没有引用（只是原始指针）用于访问相同的内存，转换对指针的引用的结果就有效。</li><li>The result of casting a reference to a pointer is valid for as long as the
underlying object is live and no reference (just raw pointers) is used to
access the same memory.</li>
</ul>
<p class="translate-text">这些公理，以及在指针算术中谨慎使用“偏移量”，足以在不安全的代码中正确实现许多有用的东西。 随着“别名”规则的确定，最终将提供更强有力的保证。 有关更多信息，请参阅“书”以及参考中专门讨论“未定义行为”的部分。</p><p>These axioms, along with careful use of <a href="../primitive.pointer.html#method.offset"><code>offset</code></a> for pointer arithmetic,
are enough to correctly implement many useful things in unsafe code. Stronger guarantees
will be provided eventually, as the <a href="../../nomicon/aliasing.html">aliasing</a> rules are being determined. For more
information, see the <a href="../../book/ch19-01-unsafe-rust.html#dereferencing-a-raw-pointer">book</a> as well as the section in the reference devoted
to <a href="../../reference/behavior-considered-undefined.html">undefined behavior</a>.</p>
<h3 id="alignment" class="section-header"><a href="#alignment">Alignment</a></h3>
<p class="translate-text">上面定义的有效原始指针不一定正确对齐（其中“正确”对齐由指针类型定义，即`*const T`必须与`mem::align_of::<t>()`对齐）。 但是，大多数函数都要求它们的参数正确对齐，并将在其文档中明确说明这一要求。 值得注意的例外是“read_unaligned”和“write_unaligned”。</t></p><p>Valid raw pointers as defined above are not necessarily properly aligned (where
“proper” alignment is defined by the pointee type, i.e., <code>*const T</code> must be
aligned to <code>mem::align_of::&lt;T&gt;()</code>). However, most functions require their
arguments to be properly aligned, and will explicitly state
this requirement in their documentation. Notable exceptions to this are
<a href="fn.read_unaligned.html" title="read_unaligned"><code>read_unaligned</code></a> and <a href="fn.write_unaligned.html" title="write_unaligned"><code>write_unaligned</code></a>.</p>
<p class="translate-text">当一个函数需要正确对齐时，即使访问的大小为 0，即即使实际上没有触及内存，它也会这样做。 在这种情况下考虑使用“NonNull::dangling”。</p><p>When a function requires proper alignment, it does so even if the access
has size 0, i.e., even if memory is not actually touched. Consider using
<a href="struct.NonNull.html#method.dangling" title="NonNull::dangling"><code>NonNull::dangling</code></a> in such cases.</p>
<h3 id="allocated-object" class="section-header"><a href="#allocated-object">Allocated object</a></h3>
<p class="translate-text">对于一些操作，例如“偏移”或场投影（`expr.field`），“分配对象”的概念变得相关。 分配的对象是一个连续的内存区域。 分配对象的常见示例包括堆栈分配变量（每个变量是一个单独的分配对象）、堆分配（由全局分配器创建的每个分配都是一个单独的分配对象）和“静态”变量。</p><p>For several operations, such as <a href="../primitive.pointer.html#method.offset"><code>offset</code></a> or field projections (<code>expr.field</code>), the notion of an
“allocated object” becomes relevant. An allocated object is a contiguous region of memory.
Common examples of allocated objects include stack-allocated variables (each variable is a
separate allocated object), heap allocations (each allocation created by the global allocator is
a separate allocated object), and <code>static</code> variables.</p>
</div></details><h2 id="macros" class="small-section-header"><a href="#macros">Macros</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="macro" href="macro.addr_of.html" title="core::ptr::addr_of macro">addr_of</a></div><div class="item-right docblock-short"><p>Create a <code>const</code> raw pointer to a place, without creating an intermediate reference.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="macro" href="macro.addr_of_mut.html" title="core::ptr::addr_of_mut macro">addr_of_mut</a></div><div class="item-right docblock-short"><p>Create a <code>mut</code> raw pointer to a place, without creating an intermediate reference.</p>
</div></div></div><h2 id="structs" class="small-section-header"><a href="#structs">Structs</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left unstable module-item"><a class="struct" href="struct.DynMetadata.html" title="core::ptr::DynMetadata struct">DynMetadata</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"><p>The metadata for a <code>Dyn = dyn SomeTrait</code> trait object type.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.NonNull.html" title="core::ptr::NonNull struct">NonNull</a></div><div class="item-right docblock-short"><p><code>*mut T</code> but non-zero and covariant.</p>
</div></div></div><h2 id="traits" class="small-section-header"><a href="#traits">Traits</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left unstable module-item"><a class="trait" href="trait.Pointee.html" title="core::ptr::Pointee trait">Pointee</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"><p>Provides the pointer metadata type of any pointed-to type.</p>
</div></div></div><h2 id="functions" class="small-section-header"><a href="#functions">Functions</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn.from_raw_parts.html" title="core::ptr::from_raw_parts fn">from_raw_parts</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"><p>Forms a (possibly-wide) raw pointer from a data address and metadata.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn.from_raw_parts_mut.html" title="core::ptr::from_raw_parts_mut fn">from_raw_parts_mut</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"><p>Performs the same functionality as <a href="fn.from_raw_parts.html" title="from_raw_parts"><code>from_raw_parts</code></a>, except that a
raw <code>*mut</code> pointer is returned, as opposed to a raw <code>*const</code> pointer.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn.metadata.html" title="core::ptr::metadata fn">metadata</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"><p>Extract the metadata component of a pointer.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.copy.html" title="core::ptr::copy fn">copy</a><a title="unsafe function" href="#"><sup>⚠</sup></a></div><div class="item-right docblock-short"><p>Copies <code>count * size_of::&lt;T&gt;()</code> bytes from <code>src</code> to <code>dst</code>. The source
and destination may overlap.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.copy_nonoverlapping.html" title="core::ptr::copy_nonoverlapping fn">copy_nonoverlapping</a><a title="unsafe function" href="#"><sup>⚠</sup></a></div><div class="item-right docblock-short"><p>Copies <code>count * size_of::&lt;T&gt;()</code> bytes from <code>src</code> to <code>dst</code>. The source
and destination must <em>not</em> overlap.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.drop_in_place.html" title="core::ptr::drop_in_place fn">drop_in_place</a><a title="unsafe function" href="#"><sup>⚠</sup></a></div><div class="item-right docblock-short"><p>Executes the destructor (if any) of the pointed-to value.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.eq.html" title="core::ptr::eq fn">eq</a></div><div class="item-right docblock-short"><p>Compares raw pointers for equality.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.hash.html" title="core::ptr::hash fn">hash</a></div><div class="item-right docblock-short"><p>Hash a raw pointer.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.null.html" title="core::ptr::null fn">null</a></div><div class="item-right docblock-short"><p>Creates a null raw pointer.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.null_mut.html" title="core::ptr::null_mut fn">null_mut</a></div><div class="item-right docblock-short"><p>Creates a null mutable raw pointer.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.read.html" title="core::ptr::read fn">read</a><a title="unsafe function" href="#"><sup>⚠</sup></a></div><div class="item-right docblock-short"><p>Reads the value from <code>src</code> without moving it. This leaves the
memory in <code>src</code> unchanged.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.read_unaligned.html" title="core::ptr::read_unaligned fn">read_unaligned</a><a title="unsafe function" href="#"><sup>⚠</sup></a></div><div class="item-right docblock-short"><p>Reads the value from <code>src</code> without moving it. This leaves the
memory in <code>src</code> unchanged.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.read_volatile.html" title="core::ptr::read_volatile fn">read_volatile</a><a title="unsafe function" href="#"><sup>⚠</sup></a></div><div class="item-right docblock-short"><p>Performs a volatile read of the value from <code>src</code> without moving it. This
leaves the memory in <code>src</code> unchanged.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.replace.html" title="core::ptr::replace fn">replace</a><a title="unsafe function" href="#"><sup>⚠</sup></a></div><div class="item-right docblock-short"><p>Moves <code>src</code> into the pointed <code>dst</code>, returning the previous <code>dst</code> value.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.slice_from_raw_parts.html" title="core::ptr::slice_from_raw_parts fn">slice_from_raw_parts</a></div><div class="item-right docblock-short"><p>Forms a raw slice from a pointer and a length.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.slice_from_raw_parts_mut.html" title="core::ptr::slice_from_raw_parts_mut fn">slice_from_raw_parts_mut</a></div><div class="item-right docblock-short"><p>Performs the same functionality as <a href="fn.slice_from_raw_parts.html" title="slice_from_raw_parts"><code>slice_from_raw_parts</code></a>, except that a
raw mutable slice is returned, as opposed to a raw immutable slice.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.swap.html" title="core::ptr::swap fn">swap</a><a title="unsafe function" href="#"><sup>⚠</sup></a></div><div class="item-right docblock-short"><p>Swaps the values at two mutable locations of the same type, without
deinitializing either.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.swap_nonoverlapping.html" title="core::ptr::swap_nonoverlapping fn">swap_nonoverlapping</a><a title="unsafe function" href="#"><sup>⚠</sup></a></div><div class="item-right docblock-short"><p>Swaps <code>count * size_of::&lt;T&gt;()</code> bytes between the two regions of memory
beginning at <code>x</code> and <code>y</code>. The two regions must <em>not</em> overlap.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.write.html" title="core::ptr::write fn">write</a><a title="unsafe function" href="#"><sup>⚠</sup></a></div><div class="item-right docblock-short"><p>Overwrites a memory location with the given value without reading or
dropping the old value.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.write_bytes.html" title="core::ptr::write_bytes fn">write_bytes</a><a title="unsafe function" href="#"><sup>⚠</sup></a></div><div class="item-right docblock-short"><p>Sets <code>count * size_of::&lt;T&gt;()</code> bytes of memory starting at <code>dst</code> to
<code>val</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.write_unaligned.html" title="core::ptr::write_unaligned fn">write_unaligned</a><a title="unsafe function" href="#"><sup>⚠</sup></a></div><div class="item-right docblock-short"><p>Overwrites a memory location with the given value without reading or
dropping the old value.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.write_volatile.html" title="core::ptr::write_volatile fn">write_volatile</a><a title="unsafe function" href="#"><sup>⚠</sup></a></div><div class="item-right docblock-short"><p>Performs a volatile write of a memory location with the given value without
reading or dropping the old value.</p>
</div></div></div><h2 id="trait-aliases" class="small-section-header"><a href="#trait-aliases">Trait aliases</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left unstable module-item"><a class="traitalias" href="traitalias.Thin.html" title="core::ptr::Thin traitalias">Thin</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"><p>Pointers to types implementing this trait alias are “thin”.</p>
</div></div></div></section><section id="search" class="content hidden"></section><div id="rustdoc-vars" data-root-path="../../" data-current-crate="core" data-search-index-js="../../search-index1.58.0.js" data-search-js="../../search1.58.0.js"></div>
</body></html>