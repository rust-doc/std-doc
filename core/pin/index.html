<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Types that pin data to its location in memory."><meta name="keywords" content="rust, rustlang, rust-lang, pin"><title>core::pin - Rust</title><link rel="stylesheet" type="text/css" href="../../normalize1.56.1.css"><link rel="stylesheet" type="text/css" href="../../rustdoc1.56.1.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../light1.56.1.css" id="themeStyle"><link rel="stylesheet" type="text/css" href="../../dark1.56.1.css" disabled=""><link rel="stylesheet" type="text/css" href="../../ayu1.56.1.css" disabled=""><script id="default-settings"></script><script src="../../storage1.56.1.js"></script><script src="../../crates1.56.1.js"></script><noscript><link rel="stylesheet" href="../../noscript1.56.1.css"></noscript><link rel="alternate icon" type="image/png" href="../../favicon-16x161.56.1.png"><link rel="alternate icon" type="image/png" href="../../favicon-32x321.56.1.png"><link rel="icon" type="image/svg+xml" href="../../favicon1.56.1.svg"><style type="text/css">#crate-search{background-image:url("../../down-arrow1.56.1.svg");}</style></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu" role="button">&#9776;</div><a href='../../core/index.html'><div class='logo-container rust-logo'><img src='../../rust-logo1.56.1.png' alt='logo'></div></a><h2 class="location">Module pin</h2><div class="sidebar-elems"><div class="block items"><ul><li><a href="#structs">Structs</a></li></ul></div><div id="sidebar-vars" data-name="pin" data-ty="mod" data-relpath="./"></div><script defer="" src="./sidebar-items.js"></script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu" title="themes"><img width="18" height="18" alt="Pick another theme!" src="../../brush1.56.1.svg"></button><div id="theme-choices" role="menu"></div></div><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" disabled="" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><button type="button" id="help-button" title="help">?</button><a id="settings-menu" href="../../settings.html" title="settings"><img width="18" height="18" alt="Change settings" src="../../wheel1.56.1.svg"></a></div></form></nav><section id="main" class="content"><h1 class="fqn"><span class="in-band">Module <a href="../index.html">core</a>::<wbr><a class="mod" href="#">pin</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../../clipboard1.56.1.svg" width="19" height="18" alt="Copy item path"></button></span><span class="out-of-band"><span class="since" title="Stable since Rust version 1.33.0">1.33.0</span><span id="render-detail"><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span><a class="srclink" href="../../src/core/pin.rs.html#1-905" title="goto source code">[src]</a></span></h1><details class="rustdoc-toggle top-doc" open=""><summary class="hideme"><span>Expand description</span></summary><div class="docblock" xpath="/html[1]/body[1]/section[1]/details[1]/div[1]" istranslationnode="true" main_mp="Y25yZD4/dGxuOzpsa2E="><p class="translate-text">将数据固定到其在内存中的位置的类型。</p><p>Types that pin data to its location in memory.</p>
<p class="translate-text">有时保证对象不会移动很有用，因为它们在内存中的位置不会改变，因此可以依赖。 这种情况的一个主要示例是构建自引用结构，因为移动带有指向自身的指针的对象将使它们无效，这可能导致未定义的行为。</p><p>It is sometimes useful to have objects that are guaranteed not to move,
in the sense that their placement in memory does not change, and can thus be relied upon.
A prime example of such a scenario would be building self-referential structs,
as moving an object with pointers to itself will invalidate them, which could cause undefined
behavior.</p>
<p class="translate-text">在高层次上， Pin<p> 确保任何指针类型 P 的指针在内存中都有一个稳定的位置，这意味着它不能移动到其他地方，并且它的内存在它被丢弃之前不能被释放。 我们说指针是“固定的”。 当讨论结合固定数据和非固定数据的类型时，事情会变得更加微妙； 请参阅下面的更多细节。</p></p><p>At a high level, a <code><a href="struct.Pin.html" title="Pin">Pin</a>&lt;P&gt;</code> ensures that the pointee of any pointer type
<code>P</code> has a stable location in memory, meaning it cannot be moved elsewhere
and its memory cannot be deallocated until it gets dropped. We say that the
pointee is “pinned”. Things get more subtle when discussing types that
combine pinned with non-pinned data; <a href="#projections-and-structural-pinning">see below</a>
for more details.</p>
<p class="translate-text">默认情况下，Rust 中的所有类型都是可移动的。 Rust 允许按值传递所有类型，并且常见的智能指针类型（例如 Box<t> 和 &mut T）允许替换和移动它们包含的值：您可以移出 Box<t>，也可以使用 mem： ：交换。 Pin<p> 包装了一个指针类型 P，因此 Pin<><t>> 的功能很像普通的 Box<t>：当 Pin<><t>> 被删除时，它的内容也被删除，并且内存被释放 . 类似地，Pin<&mut T> 很像 &mut T。但是，Pin<p> 不会让客户端实际获得 Box<t> 或 &mut T 来固定数据，这意味着您不能使用诸如 mem:: 之类的操作。 交换：</t></p></t></t></t></p></t></t></p><p>By default, all types in Rust are movable. Rust allows passing all types by-value,
and common smart-pointer types such as <code><a href="../../std/boxed/struct.Box.html" title="Box">Box</a>&lt;T&gt;</code> and <code><a href="../../std/primitive.reference.html" title="mutable reference">&amp;mut</a> T</code> allow
replacing and moving the values they contain: you can move out of a <code><a href="../../std/boxed/struct.Box.html" title="Box">Box</a>&lt;T&gt;</code>,
or you can use <a href="../mem/fn.swap.html" title="mem::swap"><code>mem::swap</code></a>. <code><a href="struct.Pin.html" title="Pin">Pin</a>&lt;P&gt;</code> wraps a pointer type <code>P</code>, so
<code><a href="struct.Pin.html" title="Pin">Pin</a>&lt;<a href="../../std/boxed/struct.Box.html" title="Box">Box</a>&lt;T&gt;&gt;</code> functions much like a regular <code><a href="../../std/boxed/struct.Box.html" title="Box">Box</a>&lt;T&gt;</code>:
when a <code><a href="struct.Pin.html" title="Pin">Pin</a>&lt;<a href="../../std/boxed/struct.Box.html" title="Box">Box</a>&lt;T&gt;&gt;</code> gets dropped, so do its contents, and the memory gets
deallocated. Similarly, <code><a href="struct.Pin.html" title="Pin">Pin</a>&lt;<a href="../../std/primitive.reference.html" title="mutable reference">&amp;mut</a> T&gt;</code> is a lot like <code><a href="../../std/primitive.reference.html" title="mutable reference">&amp;mut</a> T</code>.
However, <code><a href="struct.Pin.html" title="Pin">Pin</a>&lt;P&gt;</code> does not let clients actually obtain a <code><a href="../../std/boxed/struct.Box.html" title="Box">Box</a>&lt;T&gt;</code>
or <code><a href="../../std/primitive.reference.html" title="mutable reference">&amp;mut</a> T</code> to pinned data, which implies that you cannot use operations such
as <a href="../mem/fn.swap.html" title="mem::swap"><code>mem::swap</code></a>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">std::pin::Pin</span>;
<span class="kw">fn</span> <span class="ident">swap_pins</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>(<span class="ident">x</span>: <span class="ident">Pin</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">T</span><span class="op">&gt;</span>, <span class="ident">y</span>: <span class="ident">Pin</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">T</span><span class="op">&gt;</span>) {
    <span class="comment">// `mem::swap` needs `&amp;mut T`, but we cannot get it.</span>
    <span class="comment">// We are stuck, we cannot swap the contents of these references.</span>
    <span class="comment">// We could use `Pin::get_unchecked_mut`, but that is unsafe for a reason:</span>
    <span class="comment">// we are not allowed to use it for moving things out of the `Pin`.</span>
}</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Ause%20std%3A%3Apin%3A%3APin%3B%0Afn%20swap_pins%3CT%3E(x%3A%20Pin%3C%26mut%20T%3E%2C%20y%3A%20Pin%3C%26mut%20T%3E)%20%7B%0A%20%20%20%20%2F%2F%20%60mem%3A%3Aswap%60%20needs%20%60%26mut%20T%60%2C%20but%20we%20cannot%20get%20it.%0A%20%20%20%20%2F%2F%20We%20are%20stuck%2C%20we%20cannot%20swap%20the%20contents%20of%20these%20references.%0A%20%20%20%20%2F%2F%20We%20could%20use%20%60Pin%3A%3Aget_unchecked_mut%60%2C%20but%20that%20is%20unsafe%20for%20a%20reason%3A%0A%20%20%20%20%2F%2F%20we%20are%20not%20allowed%20to%20use%20it%20for%20moving%20things%20out%20of%20the%20%60Pin%60.%0A%7D%0A%7D&amp;edition=2018">Run</a></div>
<p class="translate-text">值得重申的是 Pin<p> 并没有改变 Rust 编译器认为所有类型都可移动的事实。 mem::swap 对任何 T 都是可调用的。相反，Pin<p> 防止某些值（由封装在 Pin<p> 中的指针指向）被移动，因为它无法调用需要 &mut T 的方法（如 mem ：：交换）。</p></p><p>It is worth reiterating that <code><a href="struct.Pin.html" title="Pin">Pin</a>&lt;P&gt;</code> does <em>not</em> change the fact that a Rust
compiler considers all types movable. <a href="../mem/fn.swap.html" title="mem::swap"><code>mem::swap</code></a> remains callable for any <code>T</code>. Instead,
<code><a href="struct.Pin.html" title="Pin">Pin</a>&lt;P&gt;</code> prevents certain <em>values</em> (pointed to by pointers wrapped in
<code><a href="struct.Pin.html" title="Pin">Pin</a>&lt;P&gt;</code>) from being moved by making it impossible to call methods that require
<code><a href="../../std/primitive.reference.html" title="mutable reference">&amp;mut</a> T</code> on them (like <a href="../mem/fn.swap.html" title="mem::swap"><code>mem::swap</code></a>).</p>
<p class="translate-text">Pin<p> 可用于包装任何指针类型 P，因此它与 Deref 和 DerefMut 交互。 Pin<p> 其中 P: Deref 应被视为指向固定 P::Target 的“P 样式指针”——因此，Pin<><t>> 是指向固定 T 的拥有指针，而 Pin <><t>> 是一个指向固定 T 的引用计数指针。为了正确起见，Pin<p> 依赖于 Deref 和 DerefMut 的实现，不会移出它们的 self 参数，而只会返回一个指向 pinned 的指针 在固定指针上调用它们时的数据。</p></t></t></p></p><p><code><a href="struct.Pin.html" title="Pin">Pin</a>&lt;P&gt;</code> can be used to wrap any pointer type <code>P</code>, and as such it interacts with
<a href="../ops/trait.Deref.html" title="ops::Deref"><code>Deref</code></a> and <a href="../ops/trait.DerefMut.html" title="ops::DerefMut"><code>DerefMut</code></a>. A <code><a href="struct.Pin.html" title="Pin">Pin</a>&lt;P&gt;</code> where <code>P: <a href="../ops/trait.Deref.html" title="ops::Deref">Deref</a></code> should be
considered as a “<code>P</code>-style pointer” to a pinned <code>P::<a href="../ops/trait.Deref.html#associatedtype.Target" title="ops::Deref::Target">Target</a></code> – so, a
<code><a href="struct.Pin.html" title="Pin">Pin</a>&lt;<a href="../../std/boxed/struct.Box.html" title="Box">Box</a>&lt;T&gt;&gt;</code> is an owned pointer to a pinned <code>T</code>, and a
<code><a href="struct.Pin.html" title="Pin">Pin</a>&lt;<a href="../../std/rc/struct.Rc.html" title="rc::Rc">Rc</a>&lt;T&gt;&gt;</code> is a reference-counted pointer to a pinned <code>T</code>.
For correctness, <code><a href="struct.Pin.html" title="Pin">Pin</a>&lt;P&gt;</code> relies on the implementations of <a href="../ops/trait.Deref.html" title="ops::Deref"><code>Deref</code></a> and
<a href="../ops/trait.DerefMut.html" title="ops::DerefMut"><code>DerefMut</code></a> not to move out of their <code>self</code> parameter, and only ever to
return a pointer to pinned data when they are called on a pinned pointer.</p>
<h1 id="unpin" class="section-header"><a href="#unpin"><code>Unpin</code></a></h1>
<p class="translate-text">许多类型总是可以自由移动，即使在固定时也是如此，因为它们不依赖于稳定的地址。 这包括所有基本类型（如 bool、i32 和引用）以及仅由这些类型组成的类型。 不关心固定的类型实现了 Unpin 自动Trait，它取消了 Pin<p> 的效果。 对于 T：Unpin、Pin<><t>> 和 Box<t> 功能相同，Pin<&mut T> 和 &mut T 也是如此。</t></t></p></p><p>Many types are always freely movable, even when pinned, because they do not
rely on having a stable address. This includes all the basic types (like
<a href="https://doc.rust-lang.org/1.56.1/std/primitive.bool.html" title="bool"><code>bool</code></a>, <a href="https://doc.rust-lang.org/1.56.1/std/primitive.i32.html" title="i32"><code>i32</code></a>, and references) as well as types consisting solely of these
types. Types that do not care about pinning implement the <a href="../marker/trait.Unpin.html" title="Unpin"><code>Unpin</code></a>
auto-trait, which cancels the effect of <code><a href="struct.Pin.html" title="Pin">Pin</a>&lt;P&gt;</code>. For <code>T: <a href="../marker/trait.Unpin.html" title="Unpin">Unpin</a></code>,
<code><a href="struct.Pin.html" title="Pin">Pin</a>&lt;<a href="../../std/boxed/struct.Box.html" title="Box">Box</a>&lt;T&gt;&gt;</code> and <code><a href="../../std/boxed/struct.Box.html" title="Box">Box</a>&lt;T&gt;</code> function identically, as do
<code><a href="struct.Pin.html" title="Pin">Pin</a>&lt;<a href="../../std/primitive.reference.html" title="mutable reference">&amp;mut</a> T&gt;</code> and <code><a href="../../std/primitive.reference.html" title="mutable reference">&amp;mut</a> T</code>.</p>
<p class="translate-text">请注意，pinning 和 Unpin 只影响指向的类型 P::Target，而不影响封装在 Pin<p> 中的指针类型 P 本身。 例如， Box<t> 是否为 Unpin 对 Pin<><t>> 的行为没有影响（这里， T 是指向的类型）。</t></t></p></p><p>Note that pinning and <a href="../marker/trait.Unpin.html" title="Unpin"><code>Unpin</code></a> only affect the pointed-to type <code>P::<a href="../ops/trait.Deref.html#associatedtype.Target" title="ops::Deref::Target">Target</a></code>,
not the pointer type <code>P</code> itself that got wrapped in <code><a href="struct.Pin.html" title="Pin">Pin</a>&lt;P&gt;</code>. For example,
whether or not <code><a href="../../std/boxed/struct.Box.html" title="Box">Box</a>&lt;T&gt;</code> is <a href="../marker/trait.Unpin.html" title="Unpin"><code>Unpin</code></a> has no effect on the behavior of
<code><a href="struct.Pin.html" title="Pin">Pin</a>&lt;<a href="../../std/boxed/struct.Box.html" title="Box">Box</a>&lt;T&gt;&gt;</code> (here, <code>T</code> is the pointed-to type).</p>
<h1 id="example-self-referential-struct" class="section-header"><a href="#example-self-referential-struct">Example: self-referential struct</a></h1>
<p class="translate-text">在我们更详细地解释与 Pin<p> 相关的保证和选择之前，我们将讨论一些如何使用它的示例。 随意跳到理论讨论继续的地方。</p></p><p>Before we go into more details to explain the guarantees and choices
associated with <code><a href="struct.Pin.html" title="Pin">Pin</a>&lt;P&gt;</code>, we discuss some examples for how it might be used.
Feel free to <a href="#drop-guarantee">skip to where the theoretical discussion continues</a>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">std::pin::Pin</span>;
<span class="kw">use</span> <span class="ident">std::marker::PhantomPinned</span>;
<span class="kw">use</span> <span class="ident">std::ptr::NonNull</span>;

<span class="comment">// This is a self-referential struct because the slice field points to the data field.</span>
<span class="comment">// We cannot inform the compiler about that with a normal reference,</span>
<span class="comment">// as this pattern cannot be described with the usual borrowing rules.</span>
<span class="comment">// Instead we use a raw pointer, though one which is known not to be null,</span>
<span class="comment">// as we know it&#39;s pointing at the string.</span>
<span class="kw">struct</span> <span class="ident">Unmovable</span> {
    <span class="ident">data</span>: <span class="ident">String</span>,
    <span class="ident">slice</span>: <span class="ident">NonNull</span><span class="op">&lt;</span><span class="ident">String</span><span class="op">&gt;</span>,
    <span class="ident">_pin</span>: <span class="ident">PhantomPinned</span>,
}

<span class="kw">impl</span> <span class="ident">Unmovable</span> {
    <span class="comment">// To ensure the data doesn&#39;t move when the function returns,</span>
    <span class="comment">// we place it in the heap where it will stay for the lifetime of the object,</span>
    <span class="comment">// and the only way to access it would be through a pointer to it.</span>
    <span class="kw">fn</span> <span class="ident">new</span>(<span class="ident">data</span>: <span class="ident">String</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">Pin</span><span class="op">&lt;</span><span class="ident">Box</span><span class="op">&lt;</span><span class="self">Self</span><span class="op">&gt;</span><span class="op">&gt;</span> {
        <span class="kw">let</span> <span class="ident">res</span> <span class="op">=</span> <span class="ident">Unmovable</span> {
            <span class="ident">data</span>,
            <span class="comment">// we only create the pointer once the data is in place</span>
            <span class="comment">// otherwise it will have already moved before we even started</span>
            <span class="ident">slice</span>: <span class="ident">NonNull::dangling</span>(),
            <span class="ident">_pin</span>: <span class="ident">PhantomPinned</span>,
        };
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">boxed</span> <span class="op">=</span> <span class="ident">Box::pin</span>(<span class="ident">res</span>);

        <span class="kw">let</span> <span class="ident">slice</span> <span class="op">=</span> <span class="ident">NonNull::from</span>(<span class="kw-2">&amp;</span><span class="ident">boxed</span>.<span class="ident">data</span>);
        <span class="comment">// we know this is safe because modifying a field doesn&#39;t move the whole struct</span>
        <span class="kw">unsafe</span> {
            <span class="kw">let</span> <span class="ident">mut_ref</span>: <span class="ident">Pin</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="self">Self</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">Pin::as_mut</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">boxed</span>);
            <span class="ident">Pin::get_unchecked_mut</span>(<span class="ident">mut_ref</span>).<span class="ident">slice</span> <span class="op">=</span> <span class="ident">slice</span>;
        }
        <span class="ident">boxed</span>
    }
}

<span class="kw">let</span> <span class="ident">unmoved</span> <span class="op">=</span> <span class="ident">Unmovable::new</span>(<span class="string">&quot;hello&quot;</span>.<span class="ident">to_string</span>());
<span class="comment">// The pointer should point to the correct location,</span>
<span class="comment">// so long as the struct hasn&#39;t moved.</span>
<span class="comment">// Meanwhile, we are free to move the pointer around.</span>
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">still_unmoved</span> <span class="op">=</span> <span class="ident">unmoved</span>;
<span class="macro">assert_eq!</span>(<span class="ident">still_unmoved</span>.<span class="ident">slice</span>, <span class="ident">NonNull::from</span>(<span class="kw-2">&amp;</span><span class="ident">still_unmoved</span>.<span class="ident">data</span>));

<span class="comment">// Since our type doesn&#39;t implement Unpin, this will fail to compile:</span>
<span class="comment">// let mut new_unmoved = Unmovable::new(&quot;world&quot;.to_string());</span>
<span class="comment">// std::mem::swap(&amp;mut *still_unmoved, &amp;mut *new_unmoved);</span></code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Ause%20std%3A%3Apin%3A%3APin%3B%0Ause%20std%3A%3Amarker%3A%3APhantomPinned%3B%0Ause%20std%3A%3Aptr%3A%3ANonNull%3B%0A%0A%2F%2F%20This%20is%20a%20self-referential%20struct%20because%20the%20slice%20field%20points%20to%20the%20data%20field.%0A%2F%2F%20We%20cannot%20inform%20the%20compiler%20about%20that%20with%20a%20normal%20reference%2C%0A%2F%2F%20as%20this%20pattern%20cannot%20be%20described%20with%20the%20usual%20borrowing%20rules.%0A%2F%2F%20Instead%20we%20use%20a%20raw%20pointer%2C%20though%20one%20which%20is%20known%20not%20to%20be%20null%2C%0A%2F%2F%20as%20we%20know%20it's%20pointing%20at%20the%20string.%0Astruct%20Unmovable%20%7B%0A%20%20%20%20data%3A%20String%2C%0A%20%20%20%20slice%3A%20NonNull%3CString%3E%2C%0A%20%20%20%20_pin%3A%20PhantomPinned%2C%0A%7D%0A%0Aimpl%20Unmovable%20%7B%0A%20%20%20%20%2F%2F%20To%20ensure%20the%20data%20doesn't%20move%20when%20the%20function%20returns%2C%0A%20%20%20%20%2F%2F%20we%20place%20it%20in%20the%20heap%20where%20it%20will%20stay%20for%20the%20lifetime%20of%20the%20object%2C%0A%20%20%20%20%2F%2F%20and%20the%20only%20way%20to%20access%20it%20would%20be%20through%20a%20pointer%20to%20it.%0A%20%20%20%20fn%20new(data%3A%20String)%20-%3E%20Pin%3CBox%3CSelf%3E%3E%20%7B%0A%20%20%20%20%20%20%20%20let%20res%20%3D%20Unmovable%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20data%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20we%20only%20create%20the%20pointer%20once%20the%20data%20is%20in%20place%0A%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20otherwise%20it%20will%20have%20already%20moved%20before%20we%20even%20started%0A%20%20%20%20%20%20%20%20%20%20%20%20slice%3A%20NonNull%3A%3Adangling()%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20_pin%3A%20PhantomPinned%2C%0A%20%20%20%20%20%20%20%20%7D%3B%0A%20%20%20%20%20%20%20%20let%20mut%20boxed%20%3D%20Box%3A%3Apin(res)%3B%0A%0A%20%20%20%20%20%20%20%20let%20slice%20%3D%20NonNull%3A%3Afrom(%26boxed.data)%3B%0A%20%20%20%20%20%20%20%20%2F%2F%20we%20know%20this%20is%20safe%20because%20modifying%20a%20field%20doesn't%20move%20the%20whole%20struct%0A%20%20%20%20%20%20%20%20unsafe%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20let%20mut_ref%3A%20Pin%3C%26mut%20Self%3E%20%3D%20Pin%3A%3Aas_mut(%26mut%20boxed)%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20Pin%3A%3Aget_unchecked_mut(mut_ref).slice%20%3D%20slice%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20boxed%0A%20%20%20%20%7D%0A%7D%0A%0Alet%20unmoved%20%3D%20Unmovable%3A%3Anew(%22hello%22.to_string())%3B%0A%2F%2F%20The%20pointer%20should%20point%20to%20the%20correct%20location%2C%0A%2F%2F%20so%20long%20as%20the%20struct%20hasn't%20moved.%0A%2F%2F%20Meanwhile%2C%20we%20are%20free%20to%20move%20the%20pointer%20around.%0A%23%5Ballow(unused_mut)%5D%0Alet%20mut%20still_unmoved%20%3D%20unmoved%3B%0Aassert_eq!(still_unmoved.slice%2C%20NonNull%3A%3Afrom(%26still_unmoved.data))%3B%0A%0A%2F%2F%20Since%20our%20type%20doesn't%20implement%20Unpin%2C%20this%20will%20fail%20to%20compile%3A%0A%2F%2F%20let%20mut%20new_unmoved%20%3D%20Unmovable%3A%3Anew(%22world%22.to_string())%3B%0A%2F%2F%20std%3A%3Amem%3A%3Aswap(%26mut%20*still_unmoved%2C%20%26mut%20*new_unmoved)%3B%0A%7D&amp;edition=2018">Run</a></div>
<h1 id="example-intrusive-doubly-linked-list" class="section-header"><a href="#example-intrusive-doubly-linked-list">Example: intrusive doubly-linked list</a></h1>
<p class="translate-text">在侵入式双向链表中，集合实际上并不为元素本身分配内存。 分配由客户端控制，元素可以存在于比集合更短的堆栈帧上。</p><p>In an intrusive doubly-linked list, the collection does not actually allocate
the memory for the elements itself. Allocation is controlled by the clients,
and elements can live on a stack frame that lives shorter than the collection does.</p>
<p class="translate-text">为了完成这项工作，每个元素都有指向列表中其前任和后继的指针。 元素只能在固定时添加，因为移动元素会使指针无效。 此外，链表元素的 Drop 实现将修补其前任和后继的指针，以将其从链表中删除。</p><p>To make this work, every element has pointers to its predecessor and successor in
the list. Elements can only be added when they are pinned, because moving the elements
around would invalidate the pointers. Moreover, the <a href="../ops/trait.Drop.html" title="Drop"><code>Drop</code></a> implementation of a linked
list element will patch the pointers of its predecessor and successor to remove itself
from the list.</p>
<p class="translate-text">至关重要的是，我们必须能够依赖 drop 被调用。 如果一个元素可以在不调用 drop 的情况下被释放或以其他方式无效，则从其相邻元素指向它的指针将变为无效，这将破坏数据结构。</p><p>Crucially, we have to be able to rely on <a href="../ops/trait.Drop.html#tymethod.drop" title="Drop::drop"><code>drop</code></a> being called. If an element
could be deallocated or otherwise invalidated without calling <a href="../ops/trait.Drop.html#tymethod.drop" title="Drop::drop"><code>drop</code></a>, the pointers into it
from its neighboring elements would become invalid, which would break the data structure.</p>
<p class="translate-text">因此，固定还带有与丢弃相关的保证。</p><p>Therefore, pinning also comes with a <a href="../ops/trait.Drop.html#tymethod.drop" title="Drop::drop"><code>drop</code></a>-related guarantee.</p>
<h1 id="drop-guarantee" class="section-header"><a href="#drop-guarantee"><code>Drop</code> guarantee</a></h1>
<p class="translate-text">固定的目的是为了能够依赖一些数据在内存中的放置。 为了完成这项工作，不仅要限制移动数据； 释放、重新利用或以其他方式使用于存储数据的内存无效也受到限制。 具体来说，对于固定数据，您必须保持其内存从固定到调用 drop 的那一刻不会失效或重新利用的不变量。 只有一旦 drop 返回或panic，内存可能会被重用。</p><p>The purpose of pinning is to be able to rely on the placement of some data in memory.
To make this work, not just moving the data is restricted; deallocating, repurposing, or
otherwise invalidating the memory used to store the data is restricted, too.
Concretely, for pinned data you have to maintain the invariant
that <em>its memory will not get invalidated or repurposed from the moment it gets pinned until
when <a href="../ops/trait.Drop.html#tymethod.drop" title="Drop::drop"><code>drop</code></a> is called</em>.  Only once <a href="../ops/trait.Drop.html#tymethod.drop" title="Drop::drop"><code>drop</code></a> returns or panics, the memory may be reused.</p>
<p class="translate-text">内存可以通过释放来“失效”，也可以通过将 Some(v) 替换为 None 或调用 Vec::set_len 来“杀死”Vector中的一些元素。 它可以通过使用 ptr::write 来重新利用它来覆盖它，而无需先调用析构函数。 在不调用 drop 的情况下，这些都不允许用于固定数据。</p><p>Memory can be “invalidated” by deallocation, but also by
replacing a <code><a href="../option/enum.Option.html#variant.Some" title="Some">Some</a>(v)</code> by <a href="../option/enum.Option.html#variant.None" title="None"><code>None</code></a>, or calling <a href="../../std/vec/struct.Vec.html#method.set_len" title="Vec::set_len"><code>Vec::set_len</code></a> to “kill” some
elements off of a vector. It can be repurposed by using <a href="../ptr/fn.write.html" title="ptr::write"><code>ptr::write</code></a> to overwrite it without
calling the destructor first. None of this is allowed for pinned data without calling <a href="../ops/trait.Drop.html#tymethod.drop" title="Drop::drop"><code>drop</code></a>.</p>
<p class="translate-text">这正是上一节中的侵入式链表需要正确运行的保证。</p><p>This is exactly the kind of guarantee that the intrusive linked list from the previous
section needs to function correctly.</p>
<p class="translate-text">请注意，此保证并不意味着内存不会泄漏！ 永远不要在固定元素上调用 drop 仍然完全可以（例如，您仍然可以在 Pin<><t>> 上调用 mem::forget）。 在双向链表的示例中，该元素将仅保留在列表中。 但是，您不能在不调用 drop 的情况下释放或重用存储。</t></p><p>Notice that this guarantee does <em>not</em> mean that memory does not leak! It is still
completely okay to not ever call <a href="../ops/trait.Drop.html#tymethod.drop" title="Drop::drop"><code>drop</code></a> on a pinned element (e.g., you can still
call <a href="../mem/fn.forget.html" title="mem::forget"><code>mem::forget</code></a> on a <code><a href="struct.Pin.html" title="Pin">Pin</a>&lt;<a href="../../std/boxed/struct.Box.html" title="Box">Box</a>&lt;T&gt;&gt;</code>). In the example of the doubly-linked
list, that element would just stay in the list. However you must not free or reuse the storage
<em>without calling <a href="../ops/trait.Drop.html#tymethod.drop" title="Drop::drop"><code>drop</code></a></em>.</p>
<h1 id="drop-implementation" class="section-header"><a href="#drop-implementation"><code>Drop</code> implementation</a></h1>
<p class="translate-text">如果你的类型使用 pinning（比如上面的两个例子），你在实现 Drop 时要小心。 drop 函数采用 &mut self，但即使您的类型之前已固定，也会调用它！ 就好像编译器自动调用了 Pin::get_unchecked_mut。</p><p>If your type uses pinning (such as the two examples above), you have to be careful
when implementing <a href="../ops/trait.Drop.html" title="Drop"><code>Drop</code></a>. The <a href="../ops/trait.Drop.html#tymethod.drop" title="Drop::drop"><code>drop</code></a> function takes <code><a href="../../std/primitive.reference.html" title="mutable reference">&amp;mut</a> self</code>, but this
is called <em>even if your type was previously pinned</em>! It is as if the
compiler automatically called <a href="struct.Pin.html#method.get_unchecked_mut" title="Pin::get_unchecked_mut"><code>Pin::get_unchecked_mut</code></a>.</p>
<p class="translate-text">这永远不会导致安全代码出现问题，因为实现依赖于固定的类型需要不安全的代码，但请注意决定在您的类型中使用固定（例如，通过在 Pin<&Self> 或 Pin<&mut 上实现一些操作 Self>) 也会对 Dropimplementation 产生影响：如果您的类型的元素可能已固定，则必须将 Drop 视为隐式采用 Pin<&mut Self>。</p><p>This can never cause a problem in safe code because implementing a type that
relies on pinning requires unsafe code, but be aware that deciding to make
use of pinning in your type (for example by implementing some operation on
<code><a href="struct.Pin.html" title="Pin">Pin</a>&lt;<a href="../../std/primitive.reference.html" title="shared reference">&amp;</a>Self&gt;</code> or <code><a href="struct.Pin.html" title="Pin">Pin</a>&lt;<a href="../../std/primitive.reference.html" title="mutable reference">&amp;mut</a> Self&gt;</code>) has consequences for your
<a href="../ops/trait.Drop.html" title="Drop"><code>Drop</code></a>implementation as well: if an element of your type could have been pinned,
you must treat <a href="../ops/trait.Drop.html" title="Drop"><code>Drop</code></a> as implicitly taking <code><a href="struct.Pin.html" title="Pin">Pin</a>&lt;<a href="../../std/primitive.reference.html" title="mutable reference">&amp;mut</a> Self&gt;</code>.</p>
<p class="translate-text">例如，您可以按如下方式实现 Drop：</p><p>For example, you could implement <a href="../ops/trait.Drop.html" title="Drop"><code>Drop</code></a> as follows:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">impl</span> <span class="ident">Drop</span> <span class="kw">for</span> <span class="ident">Type</span> {
    <span class="kw">fn</span> <span class="ident">drop</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="self">self</span>) {
        <span class="comment">// `new_unchecked` is okay because we know this value is never used</span>
        <span class="comment">// again after being dropped.</span>
        <span class="ident">inner_drop</span>(<span class="kw">unsafe</span> { <span class="ident">Pin::new_unchecked</span>(<span class="self">self</span>)});
        <span class="kw">fn</span> <span class="ident">inner_drop</span>(<span class="ident">this</span>: <span class="ident">Pin</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">Type</span><span class="op">&gt;</span>) {
            <span class="comment">// Actual drop code goes here.</span>
        }
    }
}</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Ause%20std%3A%3Apin%3A%3APin%3B%0Astruct%20Type%20%7B%20%7D%0Aimpl%20Drop%20for%20Type%20%7B%0A%20%20%20%20fn%20drop(%26mut%20self)%20%7B%0A%20%20%20%20%20%20%20%20%2F%2F%20%60new_unchecked%60%20is%20okay%20because%20we%20know%20this%20value%20is%20never%20used%0A%20%20%20%20%20%20%20%20%2F%2F%20again%20after%20being%20dropped.%0A%20%20%20%20%20%20%20%20inner_drop(unsafe%20%7B%20Pin%3A%3Anew_unchecked(self)%7D)%3B%0A%20%20%20%20%20%20%20%20fn%20inner_drop(this%3A%20Pin%3C%26mut%20Type%3E)%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20Actual%20drop%20code%20goes%20here.%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%7D%0A%7D&amp;edition=2018">Run</a></div>
<p class="translate-text">函数 inner_drop 具有 drop 应该具有的类型，因此可以确保您不会以与 pinning 冲突的方式意外使用 self/this。</p><p>The function <code>inner_drop</code> has the type that <a href="../ops/trait.Drop.html#tymethod.drop" title="Drop::drop"><code>drop</code></a> <em>should</em> have, so this makes sure that
you do not accidentally use <code>self</code>/<code>this</code> in a way that is in conflict with pinning.</p>
<p class="translate-text">此外，如果您的类型是#[repr(packed)]，编译器将自动移动字段以便能够删除它们。 它甚至可以对恰好对齐的字段执行此操作。 因此，您不能将 pinning 与 #[repr(packed)] 类型一起使用。</p><p>Moreover, if your type is <code>#[repr(packed)]</code>, the compiler will automatically
move fields around to be able to drop them. It might even do
that for fields that happen to be sufficiently aligned. As a consequence, you cannot use
pinning with a <code>#[repr(packed)]</code> type.</p>
<h1 id="projections-and-structural-pinning" class="section-header"><a href="#projections-and-structural-pinning">Projections and Structural Pinning</a></h1>
<p class="translate-text">在使用固定结构时，问题出现了如何以仅采用 Pin<&mut Struct> 的方法访问该结构的字段。 通常的方法是编写将 Pin<&mut Struct> 转换为对字段的引用的辅助方法（所谓的投影），但是该引用应该具有什么类型？ 是 Pin<&mut Field> 还是 &mut 字段？ 枚举的字段也会出现同样的问题，在考虑容器/包装器类型（例如 Vec<t>、Box<t> 或 RefCell<t> 时）也会出现同样的问题。 （这个问题既适用于可变引用，也适用于共享引用，我们在这里只使用更常见的可变引用来说明。）</t></t></t></p><p>When working with pinned structs, the question arises how one can access the
fields of that struct in a method that takes just <code><a href="struct.Pin.html" title="Pin">Pin</a>&lt;<a href="../../std/primitive.reference.html" title="mutable reference">&amp;mut</a> Struct&gt;</code>.
The usual approach is to write helper methods (so called <em>projections</em>)
that turn <code><a href="struct.Pin.html" title="Pin">Pin</a>&lt;<a href="../../std/primitive.reference.html" title="mutable reference">&amp;mut</a> Struct&gt;</code> into a reference to the field, but what type should
that reference have? Is it <code><a href="struct.Pin.html" title="Pin">Pin</a>&lt;<a href="../../std/primitive.reference.html" title="mutable reference">&amp;mut</a> Field&gt;</code> or <code><a href="../../std/primitive.reference.html" title="mutable reference">&amp;mut</a> Field</code>?
The same question arises with the fields of an <code>enum</code>, and also when considering
container/wrapper types such as <code><a href="../../std/vec/struct.Vec.html" title="Vec">Vec</a>&lt;T&gt;</code>, <code><a href="../../std/boxed/struct.Box.html" title="Box">Box</a>&lt;T&gt;</code>,
or <code><a href="../cell/struct.RefCell.html" title="cell::RefCell">RefCell</a>&lt;T&gt;</code>. (This question applies to both mutable and shared references,
we just use the more common case of mutable references here for illustration.)</p>
<p class="translate-text">事实证明，实际上是由数据结构的作者来决定特定字段的固定投影是将 Pin<&mut Struct> 变成 Pin<&mut Field> 还是 &mut Field。 但是有一些限制，最重要的限制是一致性：每个字段都可以投影到固定参考，或者将固定作为投影的一部分移除。 如果两者都是针对同一个领域进行的，那可能是不合理的！</p><p>It turns out that it is actually up to the author of the data structure to decide whether
the pinned projection for a particular field turns <code><a href="struct.Pin.html" title="Pin">Pin</a>&lt;<a href="../../std/primitive.reference.html" title="mutable reference">&amp;mut</a> Struct&gt;</code>
into <code><a href="struct.Pin.html" title="Pin">Pin</a>&lt;<a href="../../std/primitive.reference.html" title="mutable reference">&amp;mut</a> Field&gt;</code> or <code><a href="../../std/primitive.reference.html" title="mutable reference">&amp;mut</a> Field</code>. There are some
constraints though, and the most important constraint is <em>consistency</em>:
every field can be <em>either</em> projected to a pinned reference, <em>or</em> have
pinning removed as part of the projection. If both are done for the same field,
that will likely be unsound!</p>
<p class="translate-text">作为数据结构的作者，您可以决定每个字段是否固定“传播”到该字段。 传播的固定也称为“结构”，因为它遵循类型的结构。 在下面的小节中，我们描述了对任何一种选择都必须考虑的因素。</p><p>As the author of a data structure you get to decide for each field whether pinning
“propagates” to this field or not. Pinning that propagates is also called “structural”,
because it follows the structure of the type.
In the following subsections, we describe the considerations that have to be made
for either choice.</p>
<h2 id="pinning-is-not-structural-for-field" class="section-header"><a href="#pinning-is-not-structural-for-field">Pinning <em>is not</em> structural for <code>field</code></a></h2>
<p class="translate-text">固定结构的字段可能未固定，这似乎违反直觉，但这实际上是最简单的选择：如果从未创建 Pin<&mut Field>，则不会出错！ 因此，如果您决定某个字段没有结构固定，您只需确保永远不要创建对该字段的固定引用。</p><p>It may seem counter-intuitive that the field of a pinned struct might not be pinned,
but that is actually the easiest choice: if a <code><a href="struct.Pin.html" title="Pin">Pin</a>&lt;<a href="../../std/primitive.reference.html" title="mutable reference">&amp;mut</a> Field&gt;</code> is never created,
nothing can go wrong! So, if you decide that some field does not have structural pinning,
all you have to ensure is that you never create a pinned reference to that field.</p>
<p class="translate-text">没有结构钉扎的字段可能有一个将 Pin<&mut Struct> 转换为 &mut 字段的投影方法：</p><p>Fields without structural pinning may have a projection method that turns
<code><a href="struct.Pin.html" title="Pin">Pin</a>&lt;<a href="../../std/primitive.reference.html" title="mutable reference">&amp;mut</a> Struct&gt;</code> into <code><a href="../../std/primitive.reference.html" title="mutable reference">&amp;mut</a> Field</code>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">impl</span> <span class="ident">Struct</span> {
    <span class="kw">fn</span> <span class="ident">pin_get_field</span>(<span class="self">self</span>: <span class="ident">Pin</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="self">Self</span><span class="op">&gt;</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">Field</span> {
        <span class="comment">// This is okay because `field` is never considered pinned.</span>
        <span class="kw">unsafe</span> { <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="self">self</span>.<span class="ident">get_unchecked_mut</span>().<span class="ident">field</span> }
    }
}</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Ause%20std%3A%3Apin%3A%3APin%3B%0Atype%20Field%20%3D%20i32%3B%0Astruct%20Struct%20%7B%20field%3A%20Field%20%7D%0Aimpl%20Struct%20%7B%0A%20%20%20%20fn%20pin_get_field(self%3A%20Pin%3C%26mut%20Self%3E)%20-%3E%20%26mut%20Field%20%7B%0A%20%20%20%20%20%20%20%20%2F%2F%20This%20is%20okay%20because%20%60field%60%20is%20never%20considered%20pinned.%0A%20%20%20%20%20%20%20%20unsafe%20%7B%20%26mut%20self.get_unchecked_mut().field%20%7D%0A%20%20%20%20%7D%0A%7D%0A%7D&amp;edition=2018">Run</a></div>
<p class="translate-text">即使字段类型不是 Unpin，您也可以为 Struct 实现 Unpin。 当没有创建 Pin<&mut Field> 时，该类型对固定的看法是不相关的。</p><p>You may also <code>impl <a href="../marker/trait.Unpin.html" title="Unpin">Unpin</a> for Struct</code> <em>even if</em> the type of <code>field</code>
is not <a href="../marker/trait.Unpin.html" title="Unpin"><code>Unpin</code></a>. What that type thinks about pinning is not relevant
when no <code><a href="struct.Pin.html" title="Pin">Pin</a>&lt;<a href="../../std/primitive.reference.html" title="mutable reference">&amp;mut</a> Field&gt;</code> is ever created.</p>
<h2 id="pinning-is-structural-for-field" class="section-header"><a href="#pinning-is-structural-for-field">Pinning <em>is</em> structural for <code>field</code></a></h2>
<p class="translate-text">另一种选择是确定字段的固定是“结构的”，这意味着如果结构被固定，那么字段也是如此。</p><p>The other option is to decide that pinning is “structural” for <code>field</code>,
meaning that if the struct is pinned then so is the field.</p>
<p class="translate-text">这允许编写一个创建 Pin<&mut Field> 的投影，从而见证该字段被固定：</p><p>This allows writing a projection that creates a <code><a href="struct.Pin.html" title="Pin">Pin</a>&lt;<a href="../../std/primitive.reference.html" title="mutable reference">&amp;mut</a> Field&gt;</code>, thus
witnessing that the field is pinned:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">impl</span> <span class="ident">Struct</span> {
    <span class="kw">fn</span> <span class="ident">pin_get_field</span>(<span class="self">self</span>: <span class="ident">Pin</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="self">Self</span><span class="op">&gt;</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">Pin</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">Field</span><span class="op">&gt;</span> {
        <span class="comment">// This is okay because `field` is pinned when `self` is.</span>
        <span class="kw">unsafe</span> { <span class="self">self</span>.<span class="ident">map_unchecked_mut</span>(<span class="op">|</span><span class="ident">s</span><span class="op">|</span> <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">s</span>.<span class="ident">field</span>) }
    }
}</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Ause%20std%3A%3Apin%3A%3APin%3B%0Atype%20Field%20%3D%20i32%3B%0Astruct%20Struct%20%7B%20field%3A%20Field%20%7D%0Aimpl%20Struct%20%7B%0A%20%20%20%20fn%20pin_get_field(self%3A%20Pin%3C%26mut%20Self%3E)%20-%3E%20Pin%3C%26mut%20Field%3E%20%7B%0A%20%20%20%20%20%20%20%20%2F%2F%20This%20is%20okay%20because%20%60field%60%20is%20pinned%20when%20%60self%60%20is.%0A%20%20%20%20%20%20%20%20unsafe%20%7B%20self.map_unchecked_mut(%7Cs%7C%20%26mut%20s.field)%20%7D%0A%20%20%20%20%7D%0A%7D%0A%7D&amp;edition=2018">Run</a></div>
<p class="translate-text">但是，结构钉扎有一些额外的要求：</p><p>However, structural pinning comes with a few extra requirements:</p>
<ol>
<li class="translate-text">如果所有结构字段都是 Unpin，则结构必须是 Unpin。 这是默认设置，但 Unpin 是一个安全特性，因此作为结构的作者，您有责任不要为 Struct<t> 添加类似 impl<t> Unpin 之类的内容。 （请注意，添加投影操作需要不安全的代码，因此 Unpin 是一个安全Trait这一事实并没有违反这样一个原则，即您只需要在使用 unsafe 时担心这些。）</t></t></li><li>
<p>The struct must only be <a href="../marker/trait.Unpin.html" title="Unpin"><code>Unpin</code></a> if all the structural fields are
<a href="../marker/trait.Unpin.html" title="Unpin"><code>Unpin</code></a>. This is the default, but <a href="../marker/trait.Unpin.html" title="Unpin"><code>Unpin</code></a> is a safe trait, so as the author of
the struct it is your responsibility <em>not</em> to add something like
<code>impl&lt;T&gt; <a href="../marker/trait.Unpin.html" title="Unpin">Unpin</a> for Struct&lt;T&gt;</code>. (Notice that adding a projection operation
requires unsafe code, so the fact that <a href="../marker/trait.Unpin.html" title="Unpin"><code>Unpin</code></a> is a safe trait does not break
the principle that you only have to worry about any of this if you use <a href="../../std/keyword.unsafe.html" title="keyword unsafe"><code>unsafe</code></a>.)</p>
</li>
<li class="translate-text">结构的析构函数不得将结构字段移出其参数。 这就是上一节中提出的确切观点：drop 接受 &mut self，但结构（以及它的字段）之前可能已被固定。 您必须保证不会在 Drop 实现中移动字段。 特别是，如前所述，这意味着您的结构不能是#[repr(packed)]。 请参阅该部分以了解如何以编译器可以帮助您不会意外破坏固定的方式编写 drop。</li><li>
<p>The destructor of the struct must not move structural fields out of its argument. This
is the exact point that was raised in the <a href="#drop-implementation">previous section</a>: <a href="../ops/trait.Drop.html#tymethod.drop" title="Drop::drop"><code>drop</code></a> takes
<code><a href="../../std/primitive.reference.html" title="mutable reference">&amp;mut</a> self</code>, but the struct (and hence its fields) might have been pinned
before. You have to guarantee that you do not move a field inside your <a href="../ops/trait.Drop.html" title="Drop"><code>Drop</code></a>
implementation. In particular, as explained previously, this means that your struct
must <em>not</em> be <code>#[repr(packed)]</code>.
See that section for how to write <a href="../ops/trait.Drop.html#tymethod.drop" title="Drop::drop"><code>drop</code></a> in a way that the compiler can help you
not accidentally break pinning.</p>
</li>
<li class="translate-text">您必须确保遵守 Drop 保证：一旦您的结构被固定，包含内容的内存不会在不调用内容的析构函数的情况下被覆盖或释放。 这可能很棘手，正如 VecDeque<t> 所见证的那样：如果析构函数之一发生panic，则 VecDeque<t> 的析构函数可能无法对所有元素调用 drop。 这违反了 Drop 保证，因为它可能导致元素在没有调用其析构函数的情况下被释放。 （VecDeque<t> 没有固定投影，所以这不会导致不健全。）</t></t></t></li><li>
<p>You must make sure that you uphold the <a href="#drop-guarantee"><code>Drop</code> guarantee</a>:
once your struct is pinned, the memory that contains the
content is not overwritten or deallocated without calling the content’s destructors.
This can be tricky, as witnessed by <code><a href="../../std/collections/struct.VecDeque.html" title="collections::VecDeque">VecDeque</a>&lt;T&gt;</code>: the destructor of
<code><a href="../../std/collections/struct.VecDeque.html" title="collections::VecDeque">VecDeque</a>&lt;T&gt;</code> can fail to call <a href="../ops/trait.Drop.html#tymethod.drop" title="Drop::drop"><code>drop</code></a> on all elements if one of the
destructors panics. This violates the <a href="../ops/trait.Drop.html" title="Drop"><code>Drop</code></a> guarantee, because it can lead to
elements being deallocated without their destructor being called.
(<code><a href="../../std/collections/struct.VecDeque.html" title="collections::VecDeque">VecDeque</a>&lt;T&gt;</code> has no pinning projections, so this
does not cause unsoundness.)</p>
</li>
<li class="translate-text">当您的类型被固定时，您不得提供任何其他可能导致数据移出结构字段的操作。例如，如果结构包含 Option<t> 并且存在类型为 fn(Pin<&mut Struct<t>>) -> Option<t> 的 take-like 操作，则该操作可用于将 T 移出固定的 Struct<t> - 这意味着对于保存此数据的字段，固定不能是结构性的。对于将数据移出固定类型的更复杂示例，想象一下如果 RefCell<t> 有一个方法 fn get_pin_mut(self: Pin<&mut Self>) -> Pin<&mut T>。然后我们可以执行以下操作： ⓘfn exploit_ref_cell<t>(rc: Pin<&mut RefCell<t>>) { { let p = rc.as_mut().get_pin_mut(); } // 在这里，我们获得了对 `T` 的固定访问权限。让 rc_shr: &RefCell<t> = rc.into_ref().get_ref();让 b = rc_shr.borrow_mut();让内容 = &mut *b; // 这里我们有 `&mut T` 到​​相同的数据。 }Run 这是灾难性的，这意味着我们可以首先固定 RefCell<t> 的内容（使用 RefCell::get_pin_mut），然后使用我们稍后获得的可变引用移动该内容。</t></t></t></t></t></t></t></t></t></li><li>
<p>You must not offer any other operations that could lead to data being moved out of
the structural fields when your type is pinned. For example, if the struct contains an
<code><a href="../option/enum.Option.html" title="Option">Option</a>&lt;T&gt;</code> and there is a <a href="../option/enum.Option.html#method.take" title="Option::take"><code>take</code></a>-like operation with type
<code>fn(<a href="struct.Pin.html" title="Pin">Pin</a>&lt;<a href="../../std/primitive.reference.html" title="mutable reference">&amp;mut</a> Struct&lt;T&gt;&gt;) -&gt; <a href="../option/enum.Option.html" title="Option">Option</a>&lt;T&gt;</code>,
that operation can be used to move a <code>T</code> out of a pinned <code>Struct&lt;T&gt;</code> – which means
pinning cannot be structural for the field holding this data.</p>
<p>For a more complex example of moving data out of a pinned type,
imagine if <code><a href="../cell/struct.RefCell.html" title="cell::RefCell">RefCell</a>&lt;T&gt;</code> had a method
<code>fn get_pin_mut(self: <a href="struct.Pin.html" title="Pin">Pin</a>&lt;<a href="../../std/primitive.reference.html" title="mutable reference">&amp;mut</a> Self&gt;) -&gt; <a href="struct.Pin.html" title="Pin">Pin</a>&lt;<a href="../../std/primitive.reference.html" title="mutable reference">&amp;mut</a> T&gt;</code>.
Then we could do the following:</p>

<div class='information'><div class='tooltip compile_fail'>ⓘ</div></div><div class="example-wrap"><pre class="rust rust-example-rendered compile_fail"><code><span class="kw">fn</span> <span class="ident">exploit_ref_cell</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>(<span class="ident">rc</span>: <span class="ident">Pin</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">RefCell</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span><span class="op">&gt;</span>) {
    { <span class="kw">let</span> <span class="ident">p</span> <span class="op">=</span> <span class="ident">rc</span>.<span class="ident">as_mut</span>().<span class="ident">get_pin_mut</span>(); } <span class="comment">// Here we get pinned access to the `T`.</span>
    <span class="kw">let</span> <span class="ident">rc_shr</span>: <span class="kw-2">&amp;</span><span class="ident">RefCell</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">rc</span>.<span class="ident">into_ref</span>().<span class="ident">get_ref</span>();
    <span class="kw">let</span> <span class="ident">b</span> <span class="op">=</span> <span class="ident">rc_shr</span>.<span class="ident">borrow_mut</span>();
    <span class="kw">let</span> <span class="ident">content</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="kw-2">*</span><span class="ident">b</span>; <span class="comment">// And here we have `&amp;mut T` to the same data.</span>
}</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Afn%20exploit_ref_cell%3CT%3E(rc%3A%20Pin%3C%26mut%20RefCell%3CT%3E%3E)%20%7B%0A%20%20%20%20%7B%20let%20p%20%3D%20rc.as_mut().get_pin_mut()%3B%20%7D%20%2F%2F%20Here%20we%20get%20pinned%20access%20to%20the%20%60T%60.%0A%20%20%20%20let%20rc_shr%3A%20%26RefCell%3CT%3E%20%3D%20rc.into_ref().get_ref()%3B%0A%20%20%20%20let%20b%20%3D%20rc_shr.borrow_mut()%3B%0A%20%20%20%20let%20content%20%3D%20%26mut%20*b%3B%20%2F%2F%20And%20here%20we%20have%20%60%26mut%20T%60%20to%20the%20same%20data.%0A%7D%0A%7D&amp;edition=2018">Run</a></div>
<p>This is catastrophic, it means we can first pin the content of the
<code><a href="../cell/struct.RefCell.html" title="cell::RefCell">RefCell</a>&lt;T&gt;</code> (using <code><a href="../cell/struct.RefCell.html" title="cell::RefCell">RefCell</a>::get_pin_mut</code>) and then move that
content using the mutable reference we got later.</p>
</li>
</ol>
<h2 id="examples" class="section-header"><a href="#examples">Examples</a></h2>
<p class="translate-text">对于像 Vec<t> 这样的类型，两种可能性（结构钉扎与否）都是有意义的。 具有结构固定的 Vec<t> 可以具有 get_pin/get_pin_mut 方法来获取对元素的固定引用。 但是，它不能允许在固定的 Vec<t> 上调用 pop，因为这会移动（结构固定的）内容！ 它也不允许推送，这可能会重新分配并因此也移动内容。</t></t></t></p><p>For a type like <code><a href="../../std/vec/struct.Vec.html" title="Vec">Vec</a>&lt;T&gt;</code>, both possibilities (structural pinning or not) make
sense. A <code><a href="../../std/vec/struct.Vec.html" title="Vec">Vec</a>&lt;T&gt;</code> with structural pinning could have <code>get_pin</code>/<code>get_pin_mut</code>
methods to get pinned references to elements. However, it could <em>not</em> allow calling
<a href="../../std/vec/struct.Vec.html#method.pop" title="Vec::pop"><code>pop</code></a> on a pinned <code><a href="../../std/vec/struct.Vec.html" title="Vec">Vec</a>&lt;T&gt;</code> because that would move the (structurally
pinned) contents! Nor could it allow <a href="../../std/vec/struct.Vec.html#method.push" title="Vec::push"><code>push</code></a>, which might reallocate and thus also
move the contents.</p>
<p class="translate-text">没有结构固定的 Vec<t> 可以 impl<t> Unpin for Vec<t>，因为内容永远不会固定，而且 Vec<t> 本身也可以移动。 在这一点上，钉扎根本对Vector没有影响。</t></t></t></t></p><p>A <code><a href="../../std/vec/struct.Vec.html" title="Vec">Vec</a>&lt;T&gt;</code> without structural pinning could
<code>impl&lt;T&gt; <a href="../marker/trait.Unpin.html" title="Unpin">Unpin</a> for <a href="../../std/vec/struct.Vec.html" title="Vec">Vec</a>&lt;T&gt;</code>, because the contents are never pinned
and the <code><a href="../../std/vec/struct.Vec.html" title="Vec">Vec</a>&lt;T&gt;</code> itself is fine with being moved as well.
At that point pinning just has no effect on the vector at all.</p>
<p class="translate-text">在标准库中，指针类型通常没有结构固定，因此它们不提供固定投影。 这就是为什么 Box<t>: Unpin 适用于所有 T。对指针类型这样做是有意义的，因为移动 Box<t> 实际上不会移动 T：Box<t> 可以自由移动（也称为 Unpin ) 即使 T 不是。 事实上，即使 Pin<><t>> 和 Pin<&mut T> 本身也总是 Unpin，原因相同：它们的内容（T）是固定的，但指针本身可以在不移动固定数据的情况下移动。 对于 Box<t> 和 Pin<><t>>，内容是否被钉住完全与指针是否被钉住无关，意味着钉住不是结构性的。</t></t></t></t></t></t></p><p>In the standard library, pointer types generally do not have structural pinning,
and thus they do not offer pinning projections. This is why <code><a href="../../std/boxed/struct.Box.html" title="Box">Box</a>&lt;T&gt;: <a href="../marker/trait.Unpin.html" title="Unpin">Unpin</a></code>
holds for all <code>T</code>. It makes sense to do this for pointer types, because moving the
<code><a href="../../std/boxed/struct.Box.html" title="Box">Box</a>&lt;T&gt;</code> does not actually move the <code>T</code>: the <code><a href="../../std/boxed/struct.Box.html" title="Box">Box</a>&lt;T&gt;</code> can be freely
movable (aka <a href="../marker/trait.Unpin.html" title="Unpin"><code>Unpin</code></a>) even if the <code>T</code> is not. In fact, even <code><a href="struct.Pin.html" title="Pin">Pin</a>&lt;<a href="../../std/boxed/struct.Box.html" title="Box">Box</a>&lt;T&gt;&gt;</code> and
<code><a href="struct.Pin.html" title="Pin">Pin</a>&lt;<a href="../../std/primitive.reference.html" title="mutable reference">&amp;mut</a> T&gt;</code> are always <a href="../marker/trait.Unpin.html" title="Unpin"><code>Unpin</code></a> themselves, for the same reason:
their contents (the <code>T</code>) are pinned, but the pointers themselves can be moved without moving
the pinned data. For both <code><a href="../../std/boxed/struct.Box.html" title="Box">Box</a>&lt;T&gt;</code> and <code><a href="struct.Pin.html" title="Pin">Pin</a>&lt;<a href="../../std/boxed/struct.Box.html" title="Box">Box</a>&lt;T&gt;&gt;</code>,
whether the content is pinned is entirely independent of whether the
pointer is pinned, meaning pinning is <em>not</em> structural.</p>
<p class="translate-text">在实现 Future 组合器时，您通常需要对嵌套的 futures 进行结构固定，因为您需要获取对它们的固定引用才能调用 poll。 但是，如果您的组合器包含不需要固定的任何其他数据，您可以使这些字段不是结构化的，因此即使您只有 Pin<&mut Self> （例如在您自己的 poll 实现中），也可以使用可变引用自由访问它们 ）。</p><p>When implementing a <a href="../future/trait.Future.html" title="future::Future"><code>Future</code></a> combinator, you will usually need structural pinning
for the nested futures, as you need to get pinned references to them to call <a href="../future/trait.Future.html#tymethod.poll" title="future::Future::poll"><code>poll</code></a>.
But if your combinator contains any other data that does not need to be pinned,
you can make those fields not structural and hence freely access them with a
mutable reference even when you just have <code><a href="struct.Pin.html" title="Pin">Pin</a>&lt;<a href="../../std/primitive.reference.html" title="mutable reference">&amp;mut</a> Self&gt;</code> (such as in your own
<a href="../future/trait.Future.html#tymethod.poll" title="future::Future::poll"><code>poll</code></a> implementation).</p>
</div></details><h2 id="structs" class="section-header"><a href="#structs">Structs</a></h2>
<div class="item-table"><div class="item-left module-item"><a class="struct" href="struct.Pin.html" title="core::pin::Pin struct">Pin</a></div><div class="item-right docblock-short"><p>A pinned pointer.</p>
</div></div></section><section id="search" class="content hidden"></section><div id="rustdoc-vars" data-root-path="../../" data-current-crate="core" data-search-index-js="../../search-index1.56.1.js" data-search-js="../../search1.56.1.js"></div>
    <script src="../../main1.56.1.js"></script>
</body></html>