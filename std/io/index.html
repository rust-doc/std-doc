<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Traits, helpers, and type definitions for core I&#x2F;O functionality."><meta name="keywords" content="rust, rustlang, rust-lang, io"><title>std::io - Rust</title><link rel="stylesheet" type="text/css" href="../../normalize1.58.0.css"><link rel="stylesheet" type="text/css" href="../../rustdoc1.58.0.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../light1.58.0.css" id="themeStyle"><link rel="stylesheet" type="text/css" href="../../dark1.58.0.css" disabled=""><link rel="stylesheet" type="text/css" href="../../ayu1.58.0.css" disabled=""><script id="default-settings"></script><script src="../../storage1.58.0.js"></script><script src="../../crates1.58.0.js"></script><script defer="" src="../../main1.58.0.js"></script>
    <noscript><link rel="stylesheet" href="../../noscript1.58.0.css"></noscript><link rel="alternate icon" type="image/png" href="../../favicon-16x161.58.0.png"><link rel="alternate icon" type="image/png" href="../../favicon-32x321.58.0.png"><link rel="icon" type="image/svg+xml" href="../../favicon1.58.0.svg"><style type="text/css">#crate-search{background-image:url("../../down-arrow1.58.0.svg");}</style></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu" role="button">&#9776;</div><a href='../../std/index.html'><div class='logo-container rust-logo'><img src='../../rust-logo1.58.0.png' alt='logo'></div></a><h2 class="location">Module io</h2><div class="sidebar-elems"><div class="block items"><ul><li><a href="#modules">Modules</a></li><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li><li><a href="#traits">Traits</a></li><li><a href="#functions">Functions</a></li><li><a href="#types">Type Definitions</a></li></ul></div><div id="sidebar-vars" data-name="io" data-ty="mod" data-relpath="./"></div><script defer="" src="./sidebar-items.js"></script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu" title="themes"><img width="18" height="18" alt="Pick another theme!" src="../../brush1.58.0.svg"></button><div id="theme-choices" role="menu"></div></div><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><button type="button" id="help-button" title="help">?</button><a id="settings-menu" href="../../settings.html" title="settings"><img width="18" height="18" alt="Change settings" src="../../wheel1.58.0.svg"></a></div></form></nav><section id="main" class="content"><h1 class="fqn"><span class="in-band">Module <a href="../index.html">std</a>::<wbr><a class="mod" href="#">io</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../../clipboard1.58.0.svg" width="19" height="18" alt="Copy item path"></button></span><span class="out-of-band"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><span id="render-detail"><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span><a class="srclink" href="../../src/std/io/mod.rs.html#1-2810" title="goto source code">[src]</a></span></h1><details class="rustdoc-toggle top-doc" open=""><summary class="hideme"><span>Expand description</span></summary><div class="docblock" xpath="/html[1]/body[1]/section[1]/details[1]/div[1]" istranslationnode="true" main_mp="c3VkOz5saz86bG9l"><p class="translate-text">核心 I/O 功能的Trait、助手和类型定义。</p><p>Traits, helpers, and type definitions for core I/O functionality.</p>
<p class="translate-text">`std::io` 模块包含许多在进行输入和输出时需要的常见内容。 该模块最核心的部分是“Read”和“Write”Trait，它们为读写输入输出提供了最通用的接口。</p><p>The <code>std::io</code> module contains a number of common things you’ll need
when doing input and output. The most core part of this module is
the <a href="trait.Read.html" title="Read"><code>Read</code></a> and <a href="trait.Write.html" title="Write"><code>Write</code></a> traits, which provide the
most general interface for reading and writing input and output.</p>
<h2 id="read-and-write" class="section-header"><a href="#read-and-write">Read and Write</a></h2>
<p class="translate-text">因为它们是Trait，所以“读取”和“写入”由许多其他类型实现，您也可以为您的类型实现它们。 因此，您将在本模块的整个文档中看到几种不同类型的 I/O：“File”、“TcpStream”，有时甚至是“Vec<t>”。 例如，“Read”添加了一个“read”方法，我们可以在“File”上使用它：</t></p><p>Because they are traits, <a href="trait.Read.html" title="Read"><code>Read</code></a> and <a href="trait.Write.html" title="Write"><code>Write</code></a> are implemented by a number
of other types, and you can implement them for your types too. As such,
you’ll see a few different types of I/O throughout the documentation in
this module: <a href="../fs/struct.File.html"><code>File</code></a>s, <a href="../net/struct.TcpStream.html"><code>TcpStream</code></a>s, and sometimes even <a href="../vec/struct.Vec.html" title="Vec&lt;T&gt;"><code>Vec&lt;T&gt;</code></a>s. For
example, <a href="trait.Read.html" title="Read"><code>Read</code></a> adds a <a href="trait.Read.html#tymethod.read" title="Read::read"><code>read</code></a> method, which we can use on
<a href="../fs/struct.File.html"><code>File</code></a>s:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">std::io</span>;
<span class="kw">use</span> <span class="ident">std::io::prelude</span>::<span class="kw-2">*</span>;
<span class="kw">use</span> <span class="ident">std::fs::File</span>;

<span class="kw">fn</span> <span class="ident">main</span>() -&gt; <span class="ident">io::Result</span><span class="op">&lt;</span>()<span class="op">&gt;</span> {
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">f</span> <span class="op">=</span> <span class="ident">File::open</span>(<span class="string">&quot;foo.txt&quot;</span>)<span class="question-mark">?</span>;
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">buffer</span> <span class="op">=</span> [<span class="number">0</span>; <span class="number">10</span>];

    <span class="comment">// read up to 10 bytes</span>
    <span class="kw">let</span> <span class="ident">n</span> <span class="op">=</span> <span class="ident">f</span>.<span class="ident">read</span>(<span class="kw-2">&amp;mut</span> <span class="ident">buffer</span>)<span class="question-mark">?</span>;

    <span class="macro">println!</span>(<span class="string">&quot;The bytes: {:?}&quot;</span>, <span class="kw-2">&amp;</span><span class="ident">buffer</span>[..<span class="ident">n</span>]);
    <span class="prelude-val">Ok</span>(())
}</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Ause%20std%3A%3Aio%3B%0Ause%20std%3A%3Aio%3A%3Aprelude%3A%3A*%3B%0Ause%20std%3A%3Afs%3A%3AFile%3B%0A%0Afn%20main()%20-%3E%20io%3A%3AResult%3C()%3E%20%7B%0A%20%20%20%20let%20mut%20f%20%3D%20File%3A%3Aopen(%22foo.txt%22)%3F%3B%0A%20%20%20%20let%20mut%20buffer%20%3D%20%5B0%3B%2010%5D%3B%0A%0A%20%20%20%20%2F%2F%20read%20up%20to%2010%20bytes%0A%20%20%20%20let%20n%20%3D%20f.read(%26mut%20buffer)%3F%3B%0A%0A%20%20%20%20println!(%22The%20bytes%3A%20%7B%3A%3F%7D%22%2C%20%26buffer%5B..n%5D)%3B%0A%20%20%20%20Ok(())%0A%7D&amp;edition=2018">Run</a></div>
<p class="translate-text">“读”和“写”是如此重要，这两个Trait的实现者有一个绰号：读者和作者。 因此，有时您会看到“阅读器”而不是“实现“阅读”Trait的类型”。 容易多了！</p><p><a href="trait.Read.html" title="Read"><code>Read</code></a> and <a href="trait.Write.html" title="Write"><code>Write</code></a> are so important, implementors of the two traits have a
nickname: readers and writers. So you’ll sometimes see ‘a reader’ instead
of ‘a type that implements the <a href="trait.Read.html" title="Read"><code>Read</code></a> trait’. Much easier!</p>
<h3 id="seek-and-bufread" class="section-header"><a href="#seek-and-bufread">Seek and BufRead</a></h3>
<p class="translate-text">除此之外，还提供了两个重要Trait：“Seek”和“BufRead”。 这两者都建立在阅读器之上，以控制阅读的发生方式。 “Seek”让您控制下一个字节的来源：</p><p>Beyond that, there are two important traits that are provided: <a href="trait.Seek.html" title="Seek"><code>Seek</code></a>
and <a href="trait.BufRead.html" title="BufRead"><code>BufRead</code></a>. Both of these build on top of a reader to control
how the reading happens. <a href="trait.Seek.html" title="Seek"><code>Seek</code></a> lets you control where the next byte is
coming from:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">std::io</span>;
<span class="kw">use</span> <span class="ident">std::io::prelude</span>::<span class="kw-2">*</span>;
<span class="kw">use</span> <span class="ident">std::io::SeekFrom</span>;
<span class="kw">use</span> <span class="ident">std::fs::File</span>;

<span class="kw">fn</span> <span class="ident">main</span>() -&gt; <span class="ident">io::Result</span><span class="op">&lt;</span>()<span class="op">&gt;</span> {
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">f</span> <span class="op">=</span> <span class="ident">File::open</span>(<span class="string">&quot;foo.txt&quot;</span>)<span class="question-mark">?</span>;
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">buffer</span> <span class="op">=</span> [<span class="number">0</span>; <span class="number">10</span>];

    <span class="comment">// skip to the last 10 bytes of the file</span>
    <span class="ident">f</span>.<span class="ident">seek</span>(<span class="ident">SeekFrom::End</span>(<span class="op">-</span><span class="number">10</span>))<span class="question-mark">?</span>;

    <span class="comment">// read up to 10 bytes</span>
    <span class="kw">let</span> <span class="ident">n</span> <span class="op">=</span> <span class="ident">f</span>.<span class="ident">read</span>(<span class="kw-2">&amp;mut</span> <span class="ident">buffer</span>)<span class="question-mark">?</span>;

    <span class="macro">println!</span>(<span class="string">&quot;The bytes: {:?}&quot;</span>, <span class="kw-2">&amp;</span><span class="ident">buffer</span>[..<span class="ident">n</span>]);
    <span class="prelude-val">Ok</span>(())
}</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Ause%20std%3A%3Aio%3B%0Ause%20std%3A%3Aio%3A%3Aprelude%3A%3A*%3B%0Ause%20std%3A%3Aio%3A%3ASeekFrom%3B%0Ause%20std%3A%3Afs%3A%3AFile%3B%0A%0Afn%20main()%20-%3E%20io%3A%3AResult%3C()%3E%20%7B%0A%20%20%20%20let%20mut%20f%20%3D%20File%3A%3Aopen(%22foo.txt%22)%3F%3B%0A%20%20%20%20let%20mut%20buffer%20%3D%20%5B0%3B%2010%5D%3B%0A%0A%20%20%20%20%2F%2F%20skip%20to%20the%20last%2010%20bytes%20of%20the%20file%0A%20%20%20%20f.seek(SeekFrom%3A%3AEnd(-10))%3F%3B%0A%0A%20%20%20%20%2F%2F%20read%20up%20to%2010%20bytes%0A%20%20%20%20let%20n%20%3D%20f.read(%26mut%20buffer)%3F%3B%0A%0A%20%20%20%20println!(%22The%20bytes%3A%20%7B%3A%3F%7D%22%2C%20%26buffer%5B..n%5D)%3B%0A%20%20%20%20Ok(())%0A%7D&amp;edition=2018">Run</a></div>
<p class="translate-text">“BufRead”使用内部缓冲区来提供许多其他读取方式，但为了展示它，我们需要一般地讨论缓冲区。 继续阅读！</p><p><a href="trait.BufRead.html" title="BufRead"><code>BufRead</code></a> uses an internal buffer to provide a number of other ways to read, but
to show it off, we’ll need to talk about buffers in general. Keep reading!</p>
<h3 id="bufreader-and-bufwriter" class="section-header"><a href="#bufreader-and-bufwriter">BufReader and BufWriter</a></h3>
<p class="translate-text">基于字节的接口笨拙且效率低下，因为我们需要对操作系统进行近乎恒定的调用。 为了帮助解决这个问题，`std::io` 带有两个结构，“BufReader”和“BufWriter”，它们包装了读取器和写入器。 包装器使用缓冲区，减少调用次数并提供更好的方法来准确访问您想要的内容。</p><p>Byte-based interfaces are unwieldy and can be inefficient, as we’d need to be
making near-constant calls to the operating system. To help with this,
<code>std::io</code> comes with two structs, <a href="struct.BufReader.html" title="BufReader"><code>BufReader</code></a> and <a href="struct.BufWriter.html" title="BufWriter"><code>BufWriter</code></a>, which wrap
readers and writers. The wrapper uses a buffer, reducing the number of
calls and providing nicer methods for accessing exactly what you want.</p>
<p class="translate-text">例如，“BufReader”与“BufRead”Trait一起为任何阅读器添加额外的方法：</p><p>For example, <a href="struct.BufReader.html" title="BufReader"><code>BufReader</code></a> works with the <a href="trait.BufRead.html" title="BufRead"><code>BufRead</code></a> trait to add extra
methods to any reader:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">std::io</span>;
<span class="kw">use</span> <span class="ident">std::io::prelude</span>::<span class="kw-2">*</span>;
<span class="kw">use</span> <span class="ident">std::io::BufReader</span>;
<span class="kw">use</span> <span class="ident">std::fs::File</span>;

<span class="kw">fn</span> <span class="ident">main</span>() -&gt; <span class="ident">io::Result</span><span class="op">&lt;</span>()<span class="op">&gt;</span> {
    <span class="kw">let</span> <span class="ident">f</span> <span class="op">=</span> <span class="ident">File::open</span>(<span class="string">&quot;foo.txt&quot;</span>)<span class="question-mark">?</span>;
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">reader</span> <span class="op">=</span> <span class="ident">BufReader::new</span>(<span class="ident">f</span>);
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">buffer</span> <span class="op">=</span> <span class="ident">String::new</span>();

    <span class="comment">// read a line into buffer</span>
    <span class="ident">reader</span>.<span class="ident">read_line</span>(<span class="kw-2">&amp;mut</span> <span class="ident">buffer</span>)<span class="question-mark">?</span>;

    <span class="macro">println!</span>(<span class="string">&quot;{}&quot;</span>, <span class="ident">buffer</span>);
    <span class="prelude-val">Ok</span>(())
}</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Ause%20std%3A%3Aio%3B%0Ause%20std%3A%3Aio%3A%3Aprelude%3A%3A*%3B%0Ause%20std%3A%3Aio%3A%3ABufReader%3B%0Ause%20std%3A%3Afs%3A%3AFile%3B%0A%0Afn%20main()%20-%3E%20io%3A%3AResult%3C()%3E%20%7B%0A%20%20%20%20let%20f%20%3D%20File%3A%3Aopen(%22foo.txt%22)%3F%3B%0A%20%20%20%20let%20mut%20reader%20%3D%20BufReader%3A%3Anew(f)%3B%0A%20%20%20%20let%20mut%20buffer%20%3D%20String%3A%3Anew()%3B%0A%0A%20%20%20%20%2F%2F%20read%20a%20line%20into%20buffer%0A%20%20%20%20reader.read_line(%26mut%20buffer)%3F%3B%0A%0A%20%20%20%20println!(%22%7B%7D%22%2C%20buffer)%3B%0A%20%20%20%20Ok(())%0A%7D&amp;edition=2018">Run</a></div>
<p class="translate-text">“BufWriter”没有添加任何新的书写方式； 它只是缓冲每次对“write”的调用：</p><p><a href="struct.BufWriter.html" title="BufWriter"><code>BufWriter</code></a> doesn’t add any new ways of writing; it just buffers every call
to <a href="trait.Write.html#tymethod.write" title="Write::write"><code>write</code></a>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">std::io</span>;
<span class="kw">use</span> <span class="ident">std::io::prelude</span>::<span class="kw-2">*</span>;
<span class="kw">use</span> <span class="ident">std::io::BufWriter</span>;
<span class="kw">use</span> <span class="ident">std::fs::File</span>;

<span class="kw">fn</span> <span class="ident">main</span>() -&gt; <span class="ident">io::Result</span><span class="op">&lt;</span>()<span class="op">&gt;</span> {
    <span class="kw">let</span> <span class="ident">f</span> <span class="op">=</span> <span class="ident">File::create</span>(<span class="string">&quot;foo.txt&quot;</span>)<span class="question-mark">?</span>;
    {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">writer</span> <span class="op">=</span> <span class="ident">BufWriter::new</span>(<span class="ident">f</span>);

        <span class="comment">// write a byte to the buffer</span>
        <span class="ident">writer</span>.<span class="ident">write</span>(<span class="kw-2">&amp;</span>[<span class="number">42</span>])<span class="question-mark">?</span>;

    } <span class="comment">// the buffer is flushed once writer goes out of scope</span>

    <span class="prelude-val">Ok</span>(())
}</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Ause%20std%3A%3Aio%3B%0Ause%20std%3A%3Aio%3A%3Aprelude%3A%3A*%3B%0Ause%20std%3A%3Aio%3A%3ABufWriter%3B%0Ause%20std%3A%3Afs%3A%3AFile%3B%0A%0Afn%20main()%20-%3E%20io%3A%3AResult%3C()%3E%20%7B%0A%20%20%20%20let%20f%20%3D%20File%3A%3Acreate(%22foo.txt%22)%3F%3B%0A%20%20%20%20%7B%0A%20%20%20%20%20%20%20%20let%20mut%20writer%20%3D%20BufWriter%3A%3Anew(f)%3B%0A%0A%20%20%20%20%20%20%20%20%2F%2F%20write%20a%20byte%20to%20the%20buffer%0A%20%20%20%20%20%20%20%20writer.write(%26%5B42%5D)%3F%3B%0A%0A%20%20%20%20%7D%20%2F%2F%20the%20buffer%20is%20flushed%20once%20writer%20goes%20out%20of%20scope%0A%0A%20%20%20%20Ok(())%0A%7D&amp;edition=2018">Run</a></div>
<h3 id="standard-input-and-output" class="section-header"><a href="#standard-input-and-output">Standard input and output</a></h3>
<p class="translate-text">一个非常常见的输入源是标准输入：</p><p>A very common source of input is standard input:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">std::io</span>;

<span class="kw">fn</span> <span class="ident">main</span>() -&gt; <span class="ident">io::Result</span><span class="op">&lt;</span>()<span class="op">&gt;</span> {
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">input</span> <span class="op">=</span> <span class="ident">String::new</span>();

    <span class="ident">io::stdin</span>().<span class="ident">read_line</span>(<span class="kw-2">&amp;mut</span> <span class="ident">input</span>)<span class="question-mark">?</span>;

    <span class="macro">println!</span>(<span class="string">&quot;You typed: {}&quot;</span>, <span class="ident">input</span>.<span class="ident">trim</span>());
    <span class="prelude-val">Ok</span>(())
}</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Ause%20std%3A%3Aio%3B%0A%0Afn%20main()%20-%3E%20io%3A%3AResult%3C()%3E%20%7B%0A%20%20%20%20let%20mut%20input%20%3D%20String%3A%3Anew()%3B%0A%0A%20%20%20%20io%3A%3Astdin().read_line(%26mut%20input)%3F%3B%0A%0A%20%20%20%20println!(%22You%20typed%3A%20%7B%7D%22%2C%20input.trim())%3B%0A%20%20%20%20Ok(())%0A%7D&amp;edition=2018">Run</a></div>
<p class="translate-text">请注意，不能在不返回“Result<t, e="">”的函数中使用“? 运算符”。 相反，您可以在返回值上调用 ".unwrap()" 或 `match` 来捕获任何可能的错误：</t,></p><p>Note that you cannot use the <a href="../../book/appendix-02-operators.html"><code>?</code> operator</a> in functions that do not return
a <a href="../result/enum.Result.html"><code>Result&lt;T, E&gt;</code></a>. Instead, you can call <a href="../result/enum.Result.html#method.unwrap"><code>.unwrap()</code></a>
or <code>match</code> on the return value to catch any possible errors:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">std::io</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">input</span> <span class="op">=</span> <span class="ident">String::new</span>();

<span class="ident">io::stdin</span>().<span class="ident">read_line</span>(<span class="kw-2">&amp;mut</span> <span class="ident">input</span>).<span class="ident">unwrap</span>();</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Ause%20std%3A%3Aio%3B%0A%0Alet%20mut%20input%20%3D%20String%3A%3Anew()%3B%0A%0Aio%3A%3Astdin().read_line(%26mut%20input).unwrap()%3B%0A%7D&amp;edition=2018">Run</a></div>
<p class="translate-text">一个非常常见的输出来源是标准输出：</p><p>And a very common source of output is standard output:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">std::io</span>;
<span class="kw">use</span> <span class="ident">std::io::prelude</span>::<span class="kw-2">*</span>;

<span class="kw">fn</span> <span class="ident">main</span>() -&gt; <span class="ident">io::Result</span><span class="op">&lt;</span>()<span class="op">&gt;</span> {
    <span class="ident">io::stdout</span>().<span class="ident">write</span>(<span class="kw-2">&amp;</span>[<span class="number">42</span>])<span class="question-mark">?</span>;
    <span class="prelude-val">Ok</span>(())
}</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Ause%20std%3A%3Aio%3B%0Ause%20std%3A%3Aio%3A%3Aprelude%3A%3A*%3B%0A%0Afn%20main()%20-%3E%20io%3A%3AResult%3C()%3E%20%7B%0A%20%20%20%20io%3A%3Astdout().write(%26%5B42%5D)%3F%3B%0A%20%20%20%20Ok(())%0A%7D&amp;edition=2018">Run</a></div>
<p class="translate-text">当然，直接使用“io::stdout”不如“println！”之类的常见。</p><p>Of course, using <a href="fn.stdout.html"><code>io::stdout</code></a> directly is less common than something like
<a href="../macro.println.html" title="println!"><code>println!</code></a>.</p>
<h3 id="iterator-types" class="section-header"><a href="#iterator-types">Iterator types</a></h3>
<p class="translate-text">`std::io` 提供的大量结构用于迭代 I/O 的各种方式。 例如，“Lines”用于分割线：</p><p>A large number of the structures provided by <code>std::io</code> are for various
ways of iterating over I/O. For example, <a href="struct.Lines.html" title="Lines"><code>Lines</code></a> is used to split over
lines:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">std::io</span>;
<span class="kw">use</span> <span class="ident">std::io::prelude</span>::<span class="kw-2">*</span>;
<span class="kw">use</span> <span class="ident">std::io::BufReader</span>;
<span class="kw">use</span> <span class="ident">std::fs::File</span>;

<span class="kw">fn</span> <span class="ident">main</span>() -&gt; <span class="ident">io::Result</span><span class="op">&lt;</span>()<span class="op">&gt;</span> {
    <span class="kw">let</span> <span class="ident">f</span> <span class="op">=</span> <span class="ident">File::open</span>(<span class="string">&quot;foo.txt&quot;</span>)<span class="question-mark">?</span>;
    <span class="kw">let</span> <span class="ident">reader</span> <span class="op">=</span> <span class="ident">BufReader::new</span>(<span class="ident">f</span>);

    <span class="kw">for</span> <span class="ident">line</span> <span class="kw">in</span> <span class="ident">reader</span>.<span class="ident">lines</span>() {
        <span class="macro">println!</span>(<span class="string">&quot;{}&quot;</span>, <span class="ident">line</span><span class="question-mark">?</span>);
    }
    <span class="prelude-val">Ok</span>(())
}</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Ause%20std%3A%3Aio%3B%0Ause%20std%3A%3Aio%3A%3Aprelude%3A%3A*%3B%0Ause%20std%3A%3Aio%3A%3ABufReader%3B%0Ause%20std%3A%3Afs%3A%3AFile%3B%0A%0Afn%20main()%20-%3E%20io%3A%3AResult%3C()%3E%20%7B%0A%20%20%20%20let%20f%20%3D%20File%3A%3Aopen(%22foo.txt%22)%3F%3B%0A%20%20%20%20let%20reader%20%3D%20BufReader%3A%3Anew(f)%3B%0A%0A%20%20%20%20for%20line%20in%20reader.lines()%20%7B%0A%20%20%20%20%20%20%20%20println!(%22%7B%7D%22%2C%20line%3F)%3B%0A%20%20%20%20%7D%0A%20%20%20%20Ok(())%0A%7D&amp;edition=2018">Run</a></div>
<h3 id="functions" class="section-header"><a href="#functions">Functions</a></h3>
<p class="translate-text">有许多“功能”提供对各种功能的访问。 例如，我们可以使用其中三个函数来复制从标准输入到标准输出的所有内容：</p><p>There are a number of <a href="#functions-1">functions</a> that offer access to various
features. For example, we can use three of these functions to copy everything
from standard input to standard output:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">std::io</span>;

<span class="kw">fn</span> <span class="ident">main</span>() -&gt; <span class="ident">io::Result</span><span class="op">&lt;</span>()<span class="op">&gt;</span> {
    <span class="ident">io::copy</span>(<span class="kw-2">&amp;mut</span> <span class="ident">io::stdin</span>(), <span class="kw-2">&amp;mut</span> <span class="ident">io::stdout</span>())<span class="question-mark">?</span>;
    <span class="prelude-val">Ok</span>(())
}</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Ause%20std%3A%3Aio%3B%0A%0Afn%20main()%20-%3E%20io%3A%3AResult%3C()%3E%20%7B%0A%20%20%20%20io%3A%3Acopy(%26mut%20io%3A%3Astdin()%2C%20%26mut%20io%3A%3Astdout())%3F%3B%0A%20%20%20%20Ok(())%0A%7D&amp;edition=2018">Run</a></div>
<h3 id="ioresult" class="section-header"><a href="#ioresult">io::Result</a></h3>
<p class="translate-text">最后但同样重要的是“io::Result”。 这种类型被用作许多可能导致错误的 `std::io` 函数的返回类型，也可以从您自己的函数中返回。 本模块中的许多示例都使用“? 运算符”：</p><p>Last, but certainly not least, is <a href="type.Result.html"><code>io::Result</code></a>. This type is used
as the return type of many <code>std::io</code> functions that can cause an error, and
can be returned from your own functions as well. Many of the examples in this
module use the <a href="../../book/appendix-02-operators.html"><code>?</code> operator</a>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">std::io</span>;

<span class="kw">fn</span> <span class="ident">read_input</span>() -&gt; <span class="ident">io::Result</span><span class="op">&lt;</span>()<span class="op">&gt;</span> {
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">input</span> <span class="op">=</span> <span class="ident">String::new</span>();

    <span class="ident">io::stdin</span>().<span class="ident">read_line</span>(<span class="kw-2">&amp;mut</span> <span class="ident">input</span>)<span class="question-mark">?</span>;

    <span class="macro">println!</span>(<span class="string">&quot;You typed: {}&quot;</span>, <span class="ident">input</span>.<span class="ident">trim</span>());

    <span class="prelude-val">Ok</span>(())
}</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Ause%20std%3A%3Aio%3B%0A%0Afn%20read_input()%20-%3E%20io%3A%3AResult%3C()%3E%20%7B%0A%20%20%20%20let%20mut%20input%20%3D%20String%3A%3Anew()%3B%0A%0A%20%20%20%20io%3A%3Astdin().read_line(%26mut%20input)%3F%3B%0A%0A%20%20%20%20println!(%22You%20typed%3A%20%7B%7D%22%2C%20input.trim())%3B%0A%0A%20%20%20%20Ok(())%0A%7D%0A%7D&amp;edition=2018">Run</a></div>
<p class="translate-text">`read_input()` 的返回类型“io::Result<()>”对于没有“真实”返回值但确实希望在发生错误时返回错误的函数来说是一种非常常见的类型。 在这种情况下，这个函数的唯一目的是读取该行并打印它，所以我们使用`()`。</p><p>The return type of <code>read_input()</code>, <a href="type.Result.html"><code>io::Result&lt;()&gt;</code></a>, is a very
common type for functions which don’t have a ‘real’ return value, but do want to
return errors if they happen. In this case, the only purpose of this function is
to read the line and print it, so we use <code>()</code>.</p>
<h3 id="platform-specific-behavior" class="section-header"><a href="#platform-specific-behavior">Platform-specific behavior</a></h3>
<p class="translate-text">整个标准库中的许多 I/O 函数都记录在案，以指示它们被委派给哪些各种库或系统调用。 这样做是为了帮助应用程序了解幕后发生的事情以及调查任何可能不清楚的语义。 但是请注意，这是提供信息，而不是具有约束力的合同。 许多这些函数的实现会随着时间的推移而发生变化，并且可能会调用更少或更多的系统调用/库函数。</p><p>Many I/O functions throughout the standard library are documented to indicate
what various library or syscalls they are delegated to. This is done to help
applications both understand what’s happening under the hood as well as investigate
any possibly unclear semantics. Note, however, that this is informative, not a binding
contract. The implementation of many of these functions are subject to change over
time and may call fewer or more syscalls/library functions.</p>
</div></details><h2 id="modules" class="small-section-header"><a href="#modules">Modules</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="mod" href="prelude/index.html" title="std::io::prelude mod">prelude</a></div><div class="item-right docblock-short"><p>The I/O Prelude.</p>
</div></div></div><h2 id="structs" class="small-section-header"><a href="#structs">Structs</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left unstable module-item"><a class="struct" href="struct.Initializer.html" title="std::io::Initializer struct">Initializer</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"><p>A type used to conditionally initialize buffers passed to <code>Read</code> methods.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.BufReader.html" title="std::io::BufReader struct">BufReader</a></div><div class="item-right docblock-short"><p>The <code>BufReader&lt;R&gt;</code> struct adds buffering to any reader.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.BufWriter.html" title="std::io::BufWriter struct">BufWriter</a></div><div class="item-right docblock-short"><p>Wraps a writer and buffers its output.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.Bytes.html" title="std::io::Bytes struct">Bytes</a></div><div class="item-right docblock-short"><p>An iterator over <code>u8</code> values of a reader.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.Chain.html" title="std::io::Chain struct">Chain</a></div><div class="item-right docblock-short"><p>Adapter to chain together two readers.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.Cursor.html" title="std::io::Cursor struct">Cursor</a></div><div class="item-right docblock-short"><p>A <code>Cursor</code> wraps an in-memory buffer and provides it with a
<a href="trait.Seek.html" title="Seek"><code>Seek</code></a> implementation.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.Empty.html" title="std::io::Empty struct">Empty</a></div><div class="item-right docblock-short"><p>A reader which is always at EOF.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.Error.html" title="std::io::Error struct">Error</a></div><div class="item-right docblock-short"><p>The error type for I/O operations of the <a href="trait.Read.html"><code>Read</code></a>, <a href="trait.Write.html"><code>Write</code></a>, <a href="trait.Seek.html"><code>Seek</code></a>, and
associated traits.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.IntoInnerError.html" title="std::io::IntoInnerError struct">IntoInnerError</a></div><div class="item-right docblock-short"><p>An error returned by <a href="struct.BufWriter.html#method.into_inner" title="BufWriter::into_inner"><code>BufWriter::into_inner</code></a> which combines an error that
happened while writing out the buffer, and the buffered writer object
which may be used to recover from the condition.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.IoSlice.html" title="std::io::IoSlice struct">IoSlice</a></div><div class="item-right docblock-short"><p>A buffer type used with <code>Write::write_vectored</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.IoSliceMut.html" title="std::io::IoSliceMut struct">IoSliceMut</a></div><div class="item-right docblock-short"><p>A buffer type used with <code>Read::read_vectored</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.LineWriter.html" title="std::io::LineWriter struct">LineWriter</a></div><div class="item-right docblock-short"><p>Wraps a writer and buffers output to it, flushing whenever a newline
(<code>0x0a</code>, <code>'\n'</code>) is detected.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.Lines.html" title="std::io::Lines struct">Lines</a></div><div class="item-right docblock-short"><p>An iterator over the lines of an instance of <code>BufRead</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.Repeat.html" title="std::io::Repeat struct">Repeat</a></div><div class="item-right docblock-short"><p>A reader which yields one byte over and over and over and over and over and…</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.Sink.html" title="std::io::Sink struct">Sink</a></div><div class="item-right docblock-short"><p>A writer which will move data into the void.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.Split.html" title="std::io::Split struct">Split</a></div><div class="item-right docblock-short"><p>An iterator over the contents of an instance of <code>BufRead</code> split on a
particular byte.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.Stderr.html" title="std::io::Stderr struct">Stderr</a></div><div class="item-right docblock-short"><p>A handle to the standard error stream of a process.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.StderrLock.html" title="std::io::StderrLock struct">StderrLock</a></div><div class="item-right docblock-short"><p>A locked reference to the <a href="struct.Stderr.html" title="Stderr"><code>Stderr</code></a> handle.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.Stdin.html" title="std::io::Stdin struct">Stdin</a></div><div class="item-right docblock-short"><p>A handle to the standard input stream of a process.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.StdinLock.html" title="std::io::StdinLock struct">StdinLock</a></div><div class="item-right docblock-short"><p>A locked reference to the <a href="struct.Stdin.html" title="Stdin"><code>Stdin</code></a> handle.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.Stdout.html" title="std::io::Stdout struct">Stdout</a></div><div class="item-right docblock-short"><p>A handle to the global standard output stream of the current process.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.StdoutLock.html" title="std::io::StdoutLock struct">StdoutLock</a></div><div class="item-right docblock-short"><p>A locked reference to the <a href="struct.Stdout.html" title="Stdout"><code>Stdout</code></a> handle.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.Take.html" title="std::io::Take struct">Take</a></div><div class="item-right docblock-short"><p>Reader adapter which limits the bytes read from an underlying reader.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.WriterPanicked.html" title="std::io::WriterPanicked struct">WriterPanicked</a></div><div class="item-right docblock-short"><p>Error returned for the buffered data from <code>BufWriter::into_parts</code>, when the underlying
writer has previously panicked.  Contains the (possibly partly written) buffered data.</p>
</div></div></div><h2 id="enums" class="small-section-header"><a href="#enums">Enums</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="enum" href="enum.ErrorKind.html" title="std::io::ErrorKind enum">ErrorKind</a></div><div class="item-right docblock-short"><p>A list specifying general categories of I/O error.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="enum" href="enum.SeekFrom.html" title="std::io::SeekFrom enum">SeekFrom</a></div><div class="item-right docblock-short"><p>Enumeration of possible methods to seek within an I/O object.</p>
</div></div></div><h2 id="traits" class="small-section-header"><a href="#traits">Traits</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.BufRead.html" title="std::io::BufRead trait">BufRead</a></div><div class="item-right docblock-short"><p>A <code>BufRead</code> is a type of <code>Read</code>er which has an internal buffer, allowing it
to perform extra ways of reading.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.Read.html" title="std::io::Read trait">Read</a></div><div class="item-right docblock-short"><p>The <code>Read</code> trait allows for reading bytes from a source.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.Seek.html" title="std::io::Seek trait">Seek</a></div><div class="item-right docblock-short"><p>The <code>Seek</code> trait provides a cursor which can be moved within a stream of
bytes.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.Write.html" title="std::io::Write trait">Write</a></div><div class="item-right docblock-short"><p>A trait for objects which are byte-oriented sinks.</p>
</div></div></div><h2 id="functions-1" class="small-section-header"><a href="#functions-1">Functions</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn.read_to_string.html" title="std::io::read_to_string fn">read_to_string</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"><p>Read all bytes from a <a href="trait.Read.html" title="Read">reader</a> into a new <a href="../string/struct.String.html" title="String"><code>String</code></a>.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn.stderr_locked.html" title="std::io::stderr_locked fn">stderr_locked</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"><p>Constructs a new locked handle to the standard error of the current
process.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn.stdin_locked.html" title="std::io::stdin_locked fn">stdin_locked</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"><p>Constructs a new locked handle to the standard input of the current
process.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn.stdout_locked.html" title="std::io::stdout_locked fn">stdout_locked</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"><p>Constructs a new locked handle to the standard output of the current
process.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.copy.html" title="std::io::copy fn">copy</a></div><div class="item-right docblock-short"><p>Copies the entire contents of a reader into a writer.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.empty.html" title="std::io::empty fn">empty</a></div><div class="item-right docblock-short"><p>Constructs a new handle to an empty reader.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.repeat.html" title="std::io::repeat fn">repeat</a></div><div class="item-right docblock-short"><p>Creates an instance of a reader that infinitely repeats one byte.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.sink.html" title="std::io::sink fn">sink</a></div><div class="item-right docblock-short"><p>Creates an instance of a writer which will successfully consume all data.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.stderr.html" title="std::io::stderr fn">stderr</a></div><div class="item-right docblock-short"><p>Constructs a new handle to the standard error of the current process.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.stdin.html" title="std::io::stdin fn">stdin</a></div><div class="item-right docblock-short"><p>Constructs a new handle to the standard input of the current process.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.stdout.html" title="std::io::stdout fn">stdout</a></div><div class="item-right docblock-short"><p>Constructs a new handle to the standard output of the current process.</p>
</div></div></div><h2 id="types" class="small-section-header"><a href="#types">Type Definitions</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="type" href="type.Result.html" title="std::io::Result type">Result</a></div><div class="item-right docblock-short"><p>A specialized <a href="../result/enum.Result.html"><code>Result</code></a> type for I/O operations.</p>
</div></div></div></section><section id="search" class="content hidden"></section><div id="rustdoc-vars" data-root-path="../../" data-current-crate="std" data-search-index-js="../../search-index1.58.0.js" data-search-js="../../search1.58.0.js"></div>
</body></html>