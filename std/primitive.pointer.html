<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Raw, unsafe pointers, `*const T`, and `*mut T`."><meta name="keywords" content="rust, rustlang, rust-lang, pointer"><title>pointer - Rust</title><link rel="stylesheet" type="text/css" href="../normalize1.56.1.css"><link rel="stylesheet" type="text/css" href="../rustdoc1.56.1.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../light1.56.1.css" id="themeStyle"><link rel="stylesheet" type="text/css" href="../dark1.56.1.css" disabled=""><link rel="stylesheet" type="text/css" href="../ayu1.56.1.css" disabled=""><script id="default-settings"></script><script src="../storage1.56.1.js"></script><script src="../crates1.56.1.js"></script><noscript><link rel="stylesheet" href="../noscript1.56.1.css"></noscript><link rel="alternate icon" type="image/png" href="../favicon-16x161.56.1.png"><link rel="alternate icon" type="image/png" href="../favicon-32x321.56.1.png"><link rel="icon" type="image/svg+xml" href="../favicon1.56.1.svg"><style type="text/css">#crate-search{background-image:url("../down-arrow1.56.1.svg");}</style></head><body class="rustdoc primitive"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu" role="button">&#9776;</div><a href='../std/index.html'><div class='logo-container rust-logo'><img src='../rust-logo1.56.1.png' alt='logo'></div></a><h2 class="location">Primitive Type pointer</h2><div class="sidebar-elems"><div class="block items"><h3 class="sidebar-title"><a href="#implementations">Methods</a></h3><div class="sidebar-links"><a href="#method.add">add</a><a href="#method.add-1">add</a><a href="#method.align_offset">align_offset</a><a href="#method.align_offset-1">align_offset</a><a href="#method.as_mut">as_mut</a><a href="#method.as_mut_ptr">as_mut_ptr</a><a href="#method.as_ptr">as_ptr</a><a href="#method.as_ref">as_ref</a><a href="#method.as_ref-1">as_ref</a><a href="#method.as_uninit_mut">as_uninit_mut</a><a href="#method.as_uninit_ref">as_uninit_ref</a><a href="#method.as_uninit_ref-1">as_uninit_ref</a><a href="#method.as_uninit_slice">as_uninit_slice</a><a href="#method.as_uninit_slice-1">as_uninit_slice</a><a href="#method.as_uninit_slice_mut">as_uninit_slice_mut</a><a href="#method.cast">cast</a><a href="#method.cast-1">cast</a><a href="#method.copy_from">copy_from</a><a href="#method.copy_from_nonoverlapping">copy_from_nonoverlapping</a><a href="#method.copy_to">copy_to</a><a href="#method.copy_to-1">copy_to</a><a href="#method.copy_to_nonoverlapping">copy_to_nonoverlapping</a><a href="#method.copy_to_nonoverlapping-1">copy_to_nonoverlapping</a><a href="#method.drop_in_place">drop_in_place</a><a href="#method.get_unchecked">get_unchecked</a><a href="#method.get_unchecked_mut">get_unchecked_mut</a><a href="#method.guaranteed_eq">guaranteed_eq</a><a href="#method.guaranteed_eq-1">guaranteed_eq</a><a href="#method.guaranteed_ne">guaranteed_ne</a><a href="#method.guaranteed_ne-1">guaranteed_ne</a><a href="#method.is_null">is_null</a><a href="#method.is_null-1">is_null</a><a href="#method.len">len</a><a href="#method.len-1">len</a><a href="#method.offset">offset</a><a href="#method.offset-1">offset</a><a href="#method.offset_from">offset_from</a><a href="#method.offset_from-1">offset_from</a><a href="#method.read">read</a><a href="#method.read-1">read</a><a href="#method.read_unaligned">read_unaligned</a><a href="#method.read_unaligned-1">read_unaligned</a><a href="#method.read_volatile">read_volatile</a><a href="#method.read_volatile-1">read_volatile</a><a href="#method.replace">replace</a><a href="#method.set_ptr_value">set_ptr_value</a><a href="#method.set_ptr_value-1">set_ptr_value</a><a href="#method.sub">sub</a><a href="#method.sub-1">sub</a><a href="#method.swap">swap</a><a href="#method.to_raw_parts">to_raw_parts</a><a href="#method.to_raw_parts-1">to_raw_parts</a><a href="#method.wrapping_add">wrapping_add</a><a href="#method.wrapping_add-1">wrapping_add</a><a href="#method.wrapping_offset">wrapping_offset</a><a href="#method.wrapping_offset-1">wrapping_offset</a><a href="#method.wrapping_sub">wrapping_sub</a><a href="#method.wrapping_sub-1">wrapping_sub</a><a href="#method.write">write</a><a href="#method.write_bytes">write_bytes</a><a href="#method.write_unaligned">write_unaligned</a><a href="#method.write_volatile">write_volatile</a></div><h3 class="sidebar-title"><a href="#trait-implementations">Trait Implementations</a></h3><div class="sidebar-links"><a href="#impl-Clone">Clone</a><a href="#impl-CoerceUnsized%3C*const%20U%3E">CoerceUnsized&lt;*const U&gt;</a><a href="#impl-CoerceUnsized%3C*mut%20U%3E">CoerceUnsized&lt;*mut U&gt;</a><a href="#impl-Copy">Copy</a><a href="#impl-Debug">Debug</a><a href="#impl-DispatchFromDyn%3C*const%20U%3E">DispatchFromDyn&lt;*const U&gt;</a><a href="#impl-DispatchFromDyn%3C*mut%20U%3E">DispatchFromDyn&lt;*mut U&gt;</a><a href="#impl-Eq">Eq</a><a href="#impl-Hash">Hash</a><a href="#impl-Ord">Ord</a><a href="#impl-PartialEq%3C*const%20T%3E">PartialEq&lt;*const T&gt;</a><a href="#impl-PartialEq%3C*mut%20T%3E">PartialEq&lt;*mut T&gt;</a><a href="#impl-PartialOrd%3C*const%20T%3E">PartialOrd&lt;*const T&gt;</a><a href="#impl-PartialOrd%3C*mut%20T%3E">PartialOrd&lt;*mut T&gt;</a><a href="#impl-Pointer">Pointer</a><a href="#impl-Send">!Send</a><a href="#impl-Sync">!Sync</a><a href="#impl-Unpin">Unpin</a><a href="#impl-UnwindSafe">UnwindSafe</a></div><h3 class="sidebar-title"><a href="#synthetic-implementations">Auto Trait Implementations</a></h3><div class="sidebar-links"><a href="#impl-RefUnwindSafe">RefUnwindSafe</a></div><h3 class="sidebar-title"><a href="#blanket-implementations">Blanket Implementations</a></h3><div class="sidebar-links"><a href="#impl-Any">Any</a><a href="#impl-Borrow%3CT%3E">Borrow&lt;T&gt;</a><a href="#impl-BorrowMut%3CT%3E">BorrowMut&lt;T&gt;</a><a href="#impl-From%3CT%3E">From&lt;T&gt;</a><a href="#impl-Into%3CU%3E">Into&lt;U&gt;</a><a href="#impl-ToOwned">ToOwned</a><a href="#impl-TryFrom%3CU%3E">TryFrom&lt;U&gt;</a><a href="#impl-TryInto%3CU%3E">TryInto&lt;U&gt;</a></div></div><h2 class="location">Other items in<br><a href="index.html">std</a></h2><div id="sidebar-vars" data-name="pointer" data-ty="primitive" data-relpath=""></div><script defer="" src="sidebar-items.js"></script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu" title="themes"><img width="18" height="18" alt="Pick another theme!" src="../brush1.56.1.svg"></button><div id="theme-choices" role="menu"></div></div><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" disabled="" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><button type="button" id="help-button" title="help">?</button><a id="settings-menu" href="../settings.html" title="settings"><img width="18" height="18" alt="Change settings" src="../wheel1.56.1.svg"></a></div></form></nav><section id="main" class="content"><h1 class="fqn"><span class="in-band">Primitive Type <a class="primitive" href="#">pointer</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../clipboard1.56.1.svg" width="19" height="18" alt="Copy item path"></button></span><span class="out-of-band"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><span id="render-detail"><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span></span></h1><details class="rustdoc-toggle top-doc" open=""><summary class="hideme"><span>Expand description</span></summary><div class="docblock" xpath="/html[1]/body[1]/section[1]/details[1]/div[1]" istranslationnode="true" main_mp="cHNpbG1xbXNlXnR4dGA+P2B+eX9gcGY=" sub_mp="[&quot;cHNpbG1xbXNlXnR4dGA+Pzpyf39nYTRB&quot;,&quot;cHNpbG1xbXNlXnR4dGA+Pzp8ZWU0QQ==&quot;,&quot;KmJvb3dxJFE=&quot;,&quot;Kmx1dSRR&quot;]"><p class="translate-text">原始的、不安全的指针、*const T 和 *mut T。</p><p>Raw, unsafe pointers, <code>*const T</code>, and <code>*mut T</code>.</p>
<p class="translate-text">另见 std::ptr 模块。</p><p><em><a href="ptr/index.html">See also the <code>std::ptr</code> module</a>.</em></p>
<p class="translate-text">在 Rust 中使用原始指针并不常见，通常仅限于几种模式。 原始指针可以是未对齐的或为空的。 但是，当取消引用原始指针（使用 * 运算符）时，它必须为非空且对齐。</p><p>Working with raw pointers in Rust is uncommon, typically limited to a few patterns.
Raw pointers can be unaligned or <a href="ptr/fn.null.html"><code>null</code></a>. However, when a raw pointer is
dereferenced (using the <code>*</code> operator), it must be non-null and aligned.</p>
<p class="translate-text">使用 *ptr = data 通过原始指针存储旧值调用 drop ，因此如果类型具有 drop 胶水并且内存尚未初始化，则必须使用 write - 否则将在未初始化的内存上调用 drop 。</p><p>Storing through a raw pointer using <code>*ptr = data</code> calls <code>drop</code> on the old value, so
<a href="ptr/fn.write.html"><code>write</code></a> must be used if the type has drop glue and memory is not already
initialized - otherwise <code>drop</code> would be called on the uninitialized memory.</p>
<p class="translate-text">使用 null 和 null_mut 函数创建空指针，并使用 *const T 和 *mut T 类型的 is_null 方法检查空值。 *const T 和 *mut T 类型还为指针数学定义了偏移方法。</p><p>Use the <a href="ptr/fn.null.html"><code>null</code></a> and <a href="ptr/fn.null_mut.html"><code>null_mut</code></a> functions to create null pointers, and the
<a href="https://doc.rust-lang.org/1.56.1/std/primitive.pointer.html#method.is_null"><code>is_null</code></a> method of the <code>*const T</code> and <code>*mut T</code> types to check for null.
The <code>*const T</code> and <code>*mut T</code> types also define the <a href="https://doc.rust-lang.org/1.56.1/std/primitive.pointer.html#method.offset"><code>offset</code></a> method, for
pointer math.</p>
<h1 id="common-ways-to-create-raw-pointers" class="section-header"><a href="#common-ways-to-create-raw-pointers">Common ways to create raw pointers</a></h1><h2 id="1-coerce-a-reference-t-or-mutable-reference-mut-t" class="section-header"><a href="#1-coerce-a-reference-t-or-mutable-reference-mut-t">1. Coerce a reference (<code>&amp;T</code>) or mutable reference (<code>&amp;mut T</code>).</a></h2>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">my_num</span>: <span class="ident">i32</span> <span class="op">=</span> <span class="number">10</span>;
<span class="kw">let</span> <span class="ident">my_num_ptr</span>: <span class="kw-2">*</span><span class="kw">const</span> <span class="ident">i32</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="ident">my_num</span>;
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">my_speed</span>: <span class="ident">i32</span> <span class="op">=</span> <span class="number">88</span>;
<span class="kw">let</span> <span class="ident">my_speed_ptr</span>: <span class="kw-2">*</span><span class="kw-2">mut</span> <span class="ident">i32</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">my_speed</span>;</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20my_num%3A%20i32%20%3D%2010%3B%0Alet%20my_num_ptr%3A%20*const%20i32%20%3D%20%26my_num%3B%0Alet%20mut%20my_speed%3A%20i32%20%3D%2088%3B%0Alet%20my_speed_ptr%3A%20*mut%20i32%20%3D%20%26mut%20my_speed%3B%0A%7D&amp;edition=2018">Run</a></div>
<p class="translate-text">要获取指向装箱值的指针，请取消引用该框：</p><p>To get a pointer to a boxed value, dereference the box:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">my_num</span>: <span class="ident">Box</span><span class="op">&lt;</span><span class="ident">i32</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">Box::new</span>(<span class="number">10</span>);
<span class="kw">let</span> <span class="ident">my_num_ptr</span>: <span class="kw-2">*</span><span class="kw">const</span> <span class="ident">i32</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="kw-2">*</span><span class="ident">my_num</span>;
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">my_speed</span>: <span class="ident">Box</span><span class="op">&lt;</span><span class="ident">i32</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">Box::new</span>(<span class="number">88</span>);
<span class="kw">let</span> <span class="ident">my_speed_ptr</span>: <span class="kw-2">*</span><span class="kw-2">mut</span> <span class="ident">i32</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="kw-2">*</span><span class="ident">my_speed</span>;</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20my_num%3A%20Box%3Ci32%3E%20%3D%20Box%3A%3Anew(10)%3B%0Alet%20my_num_ptr%3A%20*const%20i32%20%3D%20%26*my_num%3B%0Alet%20mut%20my_speed%3A%20Box%3Ci32%3E%20%3D%20Box%3A%3Anew(88)%3B%0Alet%20my_speed_ptr%3A%20*mut%20i32%20%3D%20%26mut%20*my_speed%3B%0A%7D&amp;edition=2018">Run</a></div>
<p class="translate-text">这不获取原始分配的所有权，并且以后不需要资源管理，但是您不能在其生命周期之后使用指针。</p><p>This does not take ownership of the original allocation
and requires no resource management later,
but you must not use the pointer after its lifetime.</p>
<h2 id="2-consume-a-box-boxt" class="section-header"><a href="#2-consume-a-box-boxt">2. Consume a box (<code>Box&lt;T&gt;</code>).</a></h2>
<p class="translate-text">into_raw 函数消耗一个盒子并返回原始指针。 它不会破坏 T 或释放任何内存。</p><p>The <a href="boxed/struct.Box.html#method.into_raw"><code>into_raw</code></a> function consumes a box and returns
the raw pointer. It doesn’t destroy <code>T</code> or deallocate any memory.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">my_speed</span>: <span class="ident">Box</span><span class="op">&lt;</span><span class="ident">i32</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">Box::new</span>(<span class="number">88</span>);
<span class="kw">let</span> <span class="ident">my_speed</span>: <span class="kw-2">*</span><span class="kw-2">mut</span> <span class="ident">i32</span> <span class="op">=</span> <span class="ident">Box::into_raw</span>(<span class="ident">my_speed</span>);

<span class="comment">// By taking ownership of the original `Box&lt;T&gt;` though</span>
<span class="comment">// we are obligated to put it together later to be destroyed.</span>
<span class="kw">unsafe</span> {
    <span class="ident">drop</span>(<span class="ident">Box::from_raw</span>(<span class="ident">my_speed</span>));
}</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20my_speed%3A%20Box%3Ci32%3E%20%3D%20Box%3A%3Anew(88)%3B%0Alet%20my_speed%3A%20*mut%20i32%20%3D%20Box%3A%3Ainto_raw(my_speed)%3B%0A%0A%2F%2F%20By%20taking%20ownership%20of%20the%20original%20%60Box%3CT%3E%60%20though%0A%2F%2F%20we%20are%20obligated%20to%20put%20it%20together%20later%20to%20be%20destroyed.%0Aunsafe%20%7B%0A%20%20%20%20drop(Box%3A%3Afrom_raw(my_speed))%3B%0A%7D%0A%7D&amp;edition=2018">Run</a></div>
<p class="translate-text">请注意，这里对 drop 的调用是为了清楚起见——它表明我们已经完成了给定的值，应该将其销毁。</p><p>Note that here the call to <a href="mem/fn.drop.html"><code>drop</code></a> is for clarity - it indicates
that we are done with the given value and it should be destroyed.</p>
<h2 id="3-create-it-using-ptraddr_of" class="section-header"><a href="#3-create-it-using-ptraddr_of">3. Create it using <code>ptr::addr_of!</code></a></h2>
<p class="translate-text">您可以使用宏 ptr::addr_of，而不是强制引用原始指针！ （对于 *const T）和 ptr::addr_of_mut！ （对于 *mut T）。 这些宏允许您创建指向无法创建引用的字段的原始指针（不会导致未定义的行为），例如未对齐的字段。 如果涉及打包结构或未初始化的内存，这可能是必要的。</p><p>Instead of coercing a reference to a raw pointer, you can use the macros
<a href="ptr/macro.addr_of.html" title="ptr::addr_of!"><code>ptr::addr_of!</code></a> (for <code>*const T</code>) and <a href="ptr/macro.addr_of_mut.html" title="ptr::addr_of_mut!"><code>ptr::addr_of_mut!</code></a> (for <code>*mut T</code>).
These macros allow you to create raw pointers to fields to which you cannot
create a reference (without causing undefined behaviour), such as an
unaligned field. This might be necessary if packed structs or uninitialized
memory is involved.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Debug</span>, <span class="ident">Default</span>, <span class="ident">Copy</span>, <span class="ident">Clone</span>)]</span>
<span class="attribute">#[<span class="ident">repr</span>(<span class="ident">C</span>, <span class="ident">packed</span>)]</span>
<span class="kw">struct</span> <span class="ident">S</span> {
    <span class="ident">aligned</span>: <span class="ident">u8</span>,
    <span class="ident">unaligned</span>: <span class="ident">u32</span>,
}
<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="ident">S::default</span>();
<span class="kw">let</span> <span class="ident">p</span> <span class="op">=</span> <span class="macro">std::ptr::addr_of!</span>(<span class="ident">s</span>.<span class="ident">unaligned</span>); <span class="comment">// not allowed with coercion</span></code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0A%23%5Bderive(Debug%2C%20Default%2C%20Copy%2C%20Clone)%5D%0A%23%5Brepr(C%2C%20packed)%5D%0Astruct%20S%20%7B%0A%20%20%20%20aligned%3A%20u8%2C%0A%20%20%20%20unaligned%3A%20u32%2C%0A%7D%0Alet%20s%20%3D%20S%3A%3Adefault()%3B%0Alet%20p%20%3D%20std%3A%3Aptr%3A%3Aaddr_of!(s.unaligned)%3B%20%2F%2F%20not%20allowed%20with%20coercion%0A%7D&amp;edition=2018">Run</a></div>
<h2 id="4-get-it-from-c" class="section-header"><a href="#4-get-it-from-c">4. Get it from C.</a></h2>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">libc</span>;

<span class="kw">use</span> <span class="ident">std::mem</span>;

<span class="kw">unsafe</span> {
    <span class="kw">let</span> <span class="ident">my_num</span>: <span class="kw-2">*</span><span class="kw-2">mut</span> <span class="ident">i32</span> <span class="op">=</span> <span class="ident">libc::malloc</span>(<span class="ident">mem::size_of</span>::<span class="op">&lt;</span><span class="ident">i32</span><span class="op">&gt;</span>()) <span class="kw">as</span> <span class="kw-2">*</span><span class="kw-2">mut</span> <span class="ident">i32</span>;
    <span class="kw">if</span> <span class="ident">my_num</span>.<span class="ident">is_null</span>() {
        <span class="macro">panic!</span>(<span class="string">&quot;failed to allocate memory&quot;</span>);
    }
    <span class="ident">libc::free</span>(<span class="ident">my_num</span> <span class="kw">as</span> <span class="kw-2">*</span><span class="kw-2">mut</span> <span class="ident">libc::c_void</span>);
}</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(rustc_private)%5D%0Aextern%20crate%20libc%3B%0A%0Afn%20main()%20%7B%0Ause%20std%3A%3Amem%3B%0A%0Aunsafe%20%7B%0A%20%20%20%20let%20my_num%3A%20*mut%20i32%20%3D%20libc%3A%3Amalloc(mem%3A%3Asize_of%3A%3A%3Ci32%3E())%20as%20*mut%20i32%3B%0A%20%20%20%20if%20my_num.is_null()%20%7B%0A%20%20%20%20%20%20%20%20panic!(%22failed%20to%20allocate%20memory%22)%3B%0A%20%20%20%20%7D%0A%20%20%20%20libc%3A%3Afree(my_num%20as%20*mut%20libc%3A%3Ac_void)%3B%0A%7D%0A%7D&amp;version=nightly&amp;edition=2018">Run</a></div>
<p class="translate-text">通常你不会从字面上使用 malloc 和 free from Rust，但 C API 通常会分发大量指针，因此是 Rust 中原始指针的常见来源。</p><p>Usually you wouldn’t literally use <code>malloc</code> and <code>free</code> from Rust,
but C APIs hand out a lot of pointers generally, so are a common source
of raw pointers in Rust.</p>
</div></details><h2 id="implementations" class="small-section-header">Implementations<a href="#implementations" class="anchor"></a></h2><details class="rustdoc-toggle implementors-toggle" open=""><summary><div id="impl" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/ptr/const_ptr.rs.html#8-892" title="goto source code">[src]</a></div><a href="#impl" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="primitive" href="primitive.pointer.html">*const T</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,&nbsp;</span></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.is_null" class="method has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.0.0, const unstable">1.0.0 (const: <a href="https://github.com/rust-lang/rust/issues/74939" title="Tracking issue for const_ptr_is_null">unstable</a>)</span><a class="srclink" href="../src/core/ptr/const_ptr.rs.html#37" title="goto source code">[src]</a></div><a href="#method.is_null" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.is_null" class="fnname">is_null</a>(self) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></div></summary><div class="docblock" xpath="/html[1]/body[1]/section[1]/details[2]/div[1]/details[1]/div[1]" istranslationnode="true" main_mp="Y25yZD4/dHFyOzpia2t3cU9hZGMuLz52f39jZTRBLi9JUn9PUUlI"><p class="translate-text">如果指针为空，则返回 true。</p><p>Returns <code>true</code> if the pointer is null.</p>
<p class="translate-text">请注意，未调整大小的类型有许多可能的空指针，因为只考虑原始数据指针，而不考虑它们的长度、vtable 等。因此，两个为空的指针可能仍然不能相互比较。</p><p>Note that unsized types have many possible null pointers, as only the
raw data pointer is considered, not their length, vtable, etc.
Therefore, two pointers that are null may still not compare equal to
each other.</p>
<h2 id="behavior-during-const-evaluation" class="section-header"><a href="#behavior-during-const-evaluation">Behavior during const evaluation</a></h2>
<p class="translate-text">在 const 评估期间使用此函数时，对于在运行时结果为空的指针，它可能会返回 false。 具体来说，当指向某个内存的指针以这样的方式偏移超出其边界以致结果指针为空时，该函数仍将返回 false。 CTFE 无法知道该内存的绝对位置，因此我们无法判断指针是否为空。</p><p>When this function is used during const evaluation, it may return <code>false</code> for pointers
that turn out to be null at runtime. Specifically, when a pointer to some memory
is offset beyond its bounds in such a way that the resulting pointer is null,
the function will still return <code>false</code>. There is no way for CTFE to know
the absolute position of that memory, so we cannot tell if the pointer is
null or not.</p>
<h1 id="examples" class="section-header"><a href="#examples">Examples</a></h1>
<p class="translate-text">基本用法：</p><p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">s</span>: <span class="kw-2">&amp;</span><span class="ident">str</span> <span class="op">=</span> <span class="string">&quot;Follow the rabbit&quot;</span>;
<span class="kw">let</span> <span class="ident">ptr</span>: <span class="kw-2">*</span><span class="kw">const</span> <span class="ident">u8</span> <span class="op">=</span> <span class="ident">s</span>.<span class="ident">as_ptr</span>();
<span class="macro">assert!</span>(<span class="op">!</span><span class="ident">ptr</span>.<span class="ident">is_null</span>());</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20s%3A%20%26str%20%3D%20%22Follow%20the%20rabbit%22%3B%0Alet%20ptr%3A%20*const%20u8%20%3D%20s.as_ptr()%3B%0Aassert!(!ptr.is_null())%3B%0A%7D&amp;edition=2018">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.cast" class="method has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.38.0, const since 1.38.0">1.38.0 (const: 1.38.0)</span><a class="srclink" href="../src/core/ptr/const_ptr.rs.html#47" title="goto source code">[src]</a></div><a href="#method.cast" class="anchor"></a><h4 class="code-header">pub const fn <a href="#method.cast" class="fnname">cast</a>&lt;U&gt;(self) -&gt; <a class="primitive" href="primitive.pointer.html">*const U</a></h4></div></summary><div class="docblock" xpath="/html[1]/body[1]/section[1]/details[2]/div[1]/details[2]/div[1]" istranslationnode="true" main_mp="Y25yZD4/dHFyOzpia2t3cU9hZGMuLz52f39jZTRBLi9DQFNV"><p class="translate-text">转换为另一种类型的指针。</p><p>Casts to a pointer of another type.</p>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.to_raw_parts" class="method has-srclink"><div class="rightside"><a class="srclink" href="../src/core/ptr/const_ptr.rs.html#57" title="goto source code">[src]</a></div><a href="#method.to_raw_parts" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.to_raw_parts" class="fnname">to_raw_parts</a>(self) -&gt; <a class="primitive" href="primitive.tuple.html">(</a><a class="primitive" href="primitive.pointer.html">*const </a><a class="primitive" href="primitive.unit.html">()</a>, &lt;T as <a class="trait" href="ptr/trait.Pointee.html" title="trait std::ptr::Pointee">Pointee</a>&gt;::<a class="type" href="ptr/trait.Pointee.html#associatedtype.Metadata" title="type std::ptr::Pointee::Metadata">Metadata</a><a class="primitive" href="primitive.tuple.html">)</a></h4></div><div class="item-info"><div class="stab unstable"><span class="emoji">🔬</span> This is a nightly-only experimental API. (<code>ptr_metadata</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/81513">#81513</a>)</div></div></summary><div class="docblock" xpath="/html[1]/body[1]/section[1]/details[2]/div[1]/details[3]/div[1]" istranslationnode="true" main_mp="Y25yZD4/dHFyOzpia2t3cU9hZGMuLz52f39jZTRBLi9UTn9TRVJ7VUFTVFI="><p class="translate-text">将（可能是宽的）指针分解为其地址和元数据组件。</p><p>Decompose a (possibly wide) pointer into its address and metadata components.</p>
<p class="translate-text">稍后可以使用 from_raw_parts 重建指针。</p><p>The pointer can be later reconstructed with <a href="ptr/fn.from_raw_parts.html" title="from_raw_parts"><code>from_raw_parts</code></a>.</p>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.as_ref" class="method has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.9.0">1.9.0</span><a class="srclink" href="../src/core/ptr/const_ptr.rs.html#119" title="goto source code">[src]</a></div><a href="#method.as_ref" class="anchor"></a><h4 class="code-header">pub unsafe fn <a href="#method.as_ref" class="fnname">as_ref</a>&lt;'a&gt;(self) -&gt; <a class="enum" href="option/enum.Option.html" title="enum std::option::Option">Option</a>&lt;<a class="primitive" href="primitive.reference.html">&amp;'a </a>T&gt;</h4></div></summary><div class="docblock" xpath="/html[1]/body[1]/section[1]/details[2]/div[1]/details[4]/div[1]" istranslationnode="true" main_mp="Y25yZD4/dHFyOzpia2t3cU9hZGMuLz52f39jZTRBLi9BUn9TQUM="><p class="translate-text">如果指针为 null，则返回 None，否则返回对 Some 中包装的值的共享引用。 如果该值可能未初始化，则必须改用 as_uninit_ref。</p><p>Returns <code>None</code> if the pointer is null, or else returns a shared reference to
the value wrapped in <code>Some</code>. If the value may be uninitialized, <a href="#method.as_uninit_ref"><code>as_uninit_ref</code></a>
must be used instead.</p>
<h1 id="safety" class="section-header"><a href="#safety">Safety</a></h1>
<p class="translate-text">调用此方法时，您必须确保指针为空或以下所有条件都为真：</p><p>When calling this method, you have to ensure that <em>either</em> the pointer is null <em>or</em>
all of the following is true:</p>
<ul>
<li class="translate-text">指针必须正确对齐。</li><li>
<p>The pointer must be properly aligned.</p>
</li>
<li class="translate-text">在模块文档中定义的意义上，它必须是“可解引用的”。</li><li>
<p>It must be “dereferencable” in the sense defined in <a href="ptr/index.html#safety">the module documentation</a>.</p>
</li>
<li class="translate-text">指针必须指向 T 的初始化实例。</li><li>
<p>The pointer must point to an initialized instance of <code>T</code>.</p>
</li>
<li class="translate-text">您必须强制执行 Rust 的别名规则，因为返回的生命周期 'a 是任意选择的，不一定反映数据的实际生命周期。 特别是，在此生命周期内，指针指向的内存不得发生可变（UnsafeCell 内除外）。</li><li>
<p>You must enforce Rust’s aliasing rules, since the returned lifetime <code>'a</code> is
arbitrarily chosen and does not necessarily reflect the actual lifetime of the data.
In particular, for the duration of this lifetime, the memory the pointer points to must
not get mutated (except inside <code>UnsafeCell</code>).</p>
</li>
</ul>
<p class="translate-text">即使此方法的结果未使用，这也适用！ （关于被初始化的部分尚未完全确定，但在确定之前，唯一安全的方法是确保它们确实被初始化。）</p><p>This applies even if the result of this method is unused!
(The part about being initialized is not yet fully decided, but until
it is, the only safe approach is to ensure that they are indeed initialized.)</p>
<h1 id="examples-1" class="section-header"><a href="#examples-1">Examples</a></h1>
<p class="translate-text">基本用法：</p><p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">ptr</span>: <span class="kw-2">*</span><span class="kw">const</span> <span class="ident">u8</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="number">10u8</span> <span class="kw">as</span> <span class="kw-2">*</span><span class="kw">const</span> <span class="ident">u8</span>;

<span class="kw">unsafe</span> {
    <span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>(<span class="ident">val_back</span>) <span class="op">=</span> <span class="ident">ptr</span>.<span class="ident">as_ref</span>() {
        <span class="macro">println!</span>(<span class="string">&quot;We got back the value: {}!&quot;</span>, <span class="ident">val_back</span>);
    }
}</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20ptr%3A%20*const%20u8%20%3D%20%2610u8%20as%20*const%20u8%3B%0A%0Aunsafe%20%7B%0A%20%20%20%20if%20let%20Some(val_back)%20%3D%20ptr.as_ref()%20%7B%0A%20%20%20%20%20%20%20%20println!(%22We%20got%20back%20the%20value%3A%20%7B%7D!%22%2C%20val_back)%3B%0A%20%20%20%20%7D%0A%7D%0A%7D&amp;edition=2018">Run</a></div>
<h1 id="null-unchecked-version" class="section-header"><a href="#null-unchecked-version">Null-unchecked version</a></h1>
<p class="translate-text">如果您确定指针永远不会为空并且正在寻找某种返回 &T 而不是 Option<&T> 的 as_ref_unchecked，请知道您可以直接取消引用指针。</p><p>If you are sure the pointer can never be null and are looking for some kind of
<code>as_ref_unchecked</code> that returns the <code>&amp;T</code> instead of <code>Option&lt;&amp;T&gt;</code>, know that you can
dereference the pointer directly.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">ptr</span>: <span class="kw-2">*</span><span class="kw">const</span> <span class="ident">u8</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="number">10u8</span> <span class="kw">as</span> <span class="kw-2">*</span><span class="kw">const</span> <span class="ident">u8</span>;

<span class="kw">unsafe</span> {
    <span class="kw">let</span> <span class="ident">val_back</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="kw-2">*</span><span class="ident">ptr</span>;
    <span class="macro">println!</span>(<span class="string">&quot;We got back the value: {}!&quot;</span>, <span class="ident">val_back</span>);
}</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20ptr%3A%20*const%20u8%20%3D%20%2610u8%20as%20*const%20u8%3B%0A%0Aunsafe%20%7B%0A%20%20%20%20let%20val_back%20%3D%20%26*ptr%3B%0A%20%20%20%20println!(%22We%20got%20back%20the%20value%3A%20%7B%7D!%22%2C%20val_back)%3B%0A%7D%0A%7D&amp;edition=2018">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.as_uninit_ref" class="method has-srclink"><div class="rightside"><a class="srclink" href="../src/core/ptr/const_ptr.rs.html#166-168" title="goto source code">[src]</a></div><a href="#method.as_uninit_ref" class="anchor"></a><h4 class="code-header">pub unsafe fn <a href="#method.as_uninit_ref" class="fnname">as_uninit_ref</a>&lt;'a&gt;(self) -&gt; <a class="enum" href="option/enum.Option.html" title="enum std::option::Option">Option</a>&lt;&amp;'a <a class="union" href="mem/union.MaybeUninit.html" title="union std::mem::MaybeUninit">MaybeUninit</a>&lt;T&gt;&gt;</h4></div><div class="item-info"><div class="stab unstable"><span class="emoji">🔬</span> This is a nightly-only experimental API. (<code>ptr_as_uninit</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/75402">#75402</a>)</div></div></summary><div class="docblock" xpath="/html[1]/body[1]/section[1]/details[2]/div[1]/details[5]/div[1]" istranslationnode="true" main_mp="Y25yZD4/dHFyOzpia2t3cU9hZGMuLz52f39jZTRBLi9BUn9USkxKTFR+UkRC"><p class="translate-text">如果指针为 null，则返回 None，否则返回对 Some 中包装的值的共享引用。 与 as_ref 相比，这不需要初始化值。</p><p>Returns <code>None</code> if the pointer is null, or else returns a shared reference to
the value wrapped in <code>Some</code>. In contrast to <a href="#method.as_ref"><code>as_ref</code></a>, this does not require
that the value has to be initialized.</p>
<h1 id="safety-1" class="section-header"><a href="#safety-1">Safety</a></h1>
<p class="translate-text">调用此方法时，您必须确保指针为空或以下所有条件都为真：</p><p>When calling this method, you have to ensure that <em>either</em> the pointer is null <em>or</em>
all of the following is true:</p>
<ul>
<li class="translate-text">指针必须正确对齐。</li><li>
<p>The pointer must be properly aligned.</p>
</li>
<li class="translate-text">在模块文档中定义的意义上，它必须是“可解引用的”。</li><li>
<p>It must be “dereferencable” in the sense defined in <a href="ptr/index.html#safety">the module documentation</a>.</p>
</li>
<li class="translate-text">您必须强制执行 Rust 的别名规则，因为返回的生命周期 'a 是任意选择的，不一定反映数据的实际生命周期。 特别是，在此生命周期内，指针指向的内存不得发生可变（UnsafeCell 内除外）。</li><li>
<p>You must enforce Rust’s aliasing rules, since the returned lifetime <code>'a</code> is
arbitrarily chosen and does not necessarily reflect the actual lifetime of the data.
In particular, for the duration of this lifetime, the memory the pointer points to must
not get mutated (except inside <code>UnsafeCell</code>).</p>
</li>
</ul>
<p class="translate-text">即使此方法的结果未使用，这也适用！</p><p>This applies even if the result of this method is unused!</p>
<h1 id="examples-2" class="section-header"><a href="#examples-2">Examples</a></h1>
<p class="translate-text">基本用法：</p><p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attribute">#![<span class="ident">feature</span>(<span class="ident">ptr_as_uninit</span>)]</span>

<span class="kw">let</span> <span class="ident">ptr</span>: <span class="kw-2">*</span><span class="kw">const</span> <span class="ident">u8</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="number">10u8</span> <span class="kw">as</span> <span class="kw-2">*</span><span class="kw">const</span> <span class="ident">u8</span>;

<span class="kw">unsafe</span> {
    <span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>(<span class="ident">val_back</span>) <span class="op">=</span> <span class="ident">ptr</span>.<span class="ident">as_uninit_ref</span>() {
        <span class="macro">println!</span>(<span class="string">&quot;We got back the value: {}!&quot;</span>, <span class="ident">val_back</span>.<span class="ident">assume_init</span>());
    }
}</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(ptr_as_uninit)%5D%0A%0Afn%20main()%20%7B%0Alet%20ptr%3A%20*const%20u8%20%3D%20%2610u8%20as%20*const%20u8%3B%0A%0Aunsafe%20%7B%0A%20%20%20%20if%20let%20Some(val_back)%20%3D%20ptr.as_uninit_ref()%20%7B%0A%20%20%20%20%20%20%20%20println!(%22We%20got%20back%20the%20value%3A%20%7B%7D!%22%2C%20val_back.assume_init())%3B%0A%20%20%20%20%7D%0A%7D%0A%7D&amp;version=nightly&amp;edition=2018">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.offset" class="method has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.0.0, const unstable">1.0.0 (const: <a href="https://github.com/rust-lang/rust/issues/71499" title="Tracking issue for const_ptr_offset">unstable</a>)</span><a class="srclink" href="../src/core/ptr/const_ptr.rs.html#230-232" title="goto source code">[src]</a></div><a href="#method.offset" class="anchor"></a><h4 class="code-header">pub unsafe fn <a href="#method.offset" class="fnname">offset</a>(self, count: <a class="primitive" href="primitive.isize.html">isize</a>) -&gt; <a class="primitive" href="primitive.pointer.html">*const T</a></h4></div></summary><div class="docblock" xpath="/html[1]/body[1]/section[1]/details[2]/div[1]/details[6]/div[1]" istranslationnode="true" main_mp="Y25yZD4/dHFyOzpia2t3cU9hZGMuLz52f39jZTRBLi9PR0ZSQVE="><p class="translate-text">计算与指针的偏移量。</p><p>Calculates the offset from a pointer.</p>
<p class="translate-text">计数以 T 为单位； 例如，计数 3 表示 3 * size_of::<t>() 字节的指针偏移量。</t></p><p><code>count</code> is in units of T; e.g., a <code>count</code> of 3 represents a pointer
offset of <code>3 * size_of::&lt;T&gt;()</code> bytes.</p>
<h1 id="safety-2" class="section-header"><a href="#safety-2">Safety</a></h1>
<p class="translate-text">如果违反以下任何条件，则结果为未定义行为：</p><p>If any of the following conditions are violated, the result is Undefined
Behavior:</p>
<ul>
<li class="translate-text">起始指针和结果指针都必须在边界内或超过同一分配对象的末尾一个字节。</li><li>
<p>Both the starting and resulting pointer must be either in bounds or one
byte past the end of the same <a href="ptr/index.html#allocated-object">allocated object</a>.</p>
</li>
<li class="translate-text">计算的偏移量（以字节为单位）不能溢出 isize。</li><li>
<p>The computed offset, <strong>in bytes</strong>, cannot overflow an <code>isize</code>.</p>
</li>
<li class="translate-text">范围内的偏移量不能依赖于“环绕”地址空间。 也就是说，以字节为单位的无限精度和必须适合使用大小。</li><li>
<p>The offset being in bounds cannot rely on “wrapping around” the address
space. That is, the infinite-precision sum, <strong>in bytes</strong> must fit in a usize.</p>
</li>
</ul>
<p class="translate-text">编译器和标准库通常会尝试确保分配永远不会达到需要考虑偏移量的大小。 例如， Vec 和 Box 确保它们分配的字节数永远不会超过 isize::MAX 字节，因此 vec.as_ptr().add(vec.len()) 总是安全的。</p><p>The compiler and standard library generally tries to ensure allocations
never reach a size where an offset is a concern. For instance, <code>Vec</code>
and <code>Box</code> ensure they never allocate more than <code>isize::MAX</code> bytes, so
<code>vec.as_ptr().add(vec.len())</code> is always safe.</p>
<p class="translate-text">大多数平台根本无法构建这样的分配。 例如，由于页表限制或地址空间分割，没有已知的 64 位平台可以为 263 字节的请求提供服务。 但是，一些 32 位和 16 位平台可能会成功地为超过 isize::MAX 字节的请求提供物理地址扩展等内容。 因此，直接从分配器或内存映射文件获取的内存可能太大而无法使用此函数处理。</p><p>Most platforms fundamentally can’t even construct such an allocation.
For instance, no known 64-bit platform can ever serve a request
for 2<sup>63</sup> bytes due to page-table limitations or splitting the address space.
However, some 32-bit and 16-bit platforms may successfully serve a request for
more than <code>isize::MAX</code> bytes with things like Physical Address
Extension. As such, memory acquired directly from allocators or memory
mapped files <em>may</em> be too large to handle with this function.</p>
<p class="translate-text">如果这些约束难以满足，请考虑使用 wrapping_offset。 这种方法的唯一优点是它可以实现更积极的编译器优化。</p><p>Consider using <a href="#method.wrapping_offset"><code>wrapping_offset</code></a> instead if these constraints are
difficult to satisfy. The only advantage of this method is that it
enables more aggressive compiler optimizations.</p>
<h1 id="examples-3" class="section-header"><a href="#examples-3">Examples</a></h1>
<p class="translate-text">基本用法：</p><p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">s</span>: <span class="kw-2">&amp;</span><span class="ident">str</span> <span class="op">=</span> <span class="string">&quot;123&quot;</span>;
<span class="kw">let</span> <span class="ident">ptr</span>: <span class="kw-2">*</span><span class="kw">const</span> <span class="ident">u8</span> <span class="op">=</span> <span class="ident">s</span>.<span class="ident">as_ptr</span>();

<span class="kw">unsafe</span> {
    <span class="macro">println!</span>(<span class="string">&quot;{}&quot;</span>, <span class="kw-2">*</span><span class="ident">ptr</span>.<span class="ident">offset</span>(<span class="number">1</span>) <span class="kw">as</span> <span class="ident">char</span>);
    <span class="macro">println!</span>(<span class="string">&quot;{}&quot;</span>, <span class="kw-2">*</span><span class="ident">ptr</span>.<span class="ident">offset</span>(<span class="number">2</span>) <span class="kw">as</span> <span class="ident">char</span>);
}</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20s%3A%20%26str%20%3D%20%22123%22%3B%0Alet%20ptr%3A%20*const%20u8%20%3D%20s.as_ptr()%3B%0A%0Aunsafe%20%7B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20*ptr.offset(1)%20as%20char)%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20*ptr.offset(2)%20as%20char)%3B%0A%7D%0A%7D&amp;edition=2018">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.wrapping_offset" class="method has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.16.0, const unstable">1.16.0 (const: <a href="https://github.com/rust-lang/rust/issues/71499" title="Tracking issue for const_ptr_offset">unstable</a>)</span><a class="srclink" href="../src/core/ptr/const_ptr.rs.html#292-294" title="goto source code">[src]</a></div><a href="#method.wrapping_offset" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.wrapping_offset" class="fnname">wrapping_offset</a>(self, count: <a class="primitive" href="primitive.isize.html">isize</a>) -&gt; <a class="primitive" href="primitive.pointer.html">*const T</a></h4></div></summary><div class="docblock" xpath="/html[1]/body[1]/section[1]/details[2]/div[1]/details[7]/div[1]" istranslationnode="true" main_mp="Y25yZD4/dHFyOzpia2t3cU9hZGMuLz52f39jZTRBLi9XU0FRVExKQn9ORkdXQFA="><p class="translate-text">使用环绕算法计算指针的偏移量。</p><p>Calculates the offset from a pointer using wrapping arithmetic.</p>
<p class="translate-text">计数以 T 为单位； 例如，计数 3 表示 3 * size_of::<t>() 字节的指针偏移量。</t></p><p><code>count</code> is in units of T; e.g., a <code>count</code> of 3 represents a pointer
offset of <code>3 * size_of::&lt;T&gt;()</code> bytes.</p>
<h1 id="safety-3" class="section-header"><a href="#safety-3">Safety</a></h1>
<p class="translate-text">这个操作本身总是安全的，但使用结果指针却不是。</p><p>This operation itself is always safe, but using the resulting pointer is not.</p>
<p class="translate-text">结果指针“记住”了 self 指向的已分配对象； 它不能用于读取或写入其他分配的对象。</p><p>The resulting pointer “remembers” the <a href="ptr/index.html#allocated-object">allocated object</a> that <code>self</code> points to; it must not
be used to read or write other allocated objects.</p>
<p class="translate-text">换句话说，即使我们假设 T 的大小为 1 并且没有溢出， let z = x.wrapping_offset((y as isize) - (x as isize)) 也不会使 z 与 y 相同：z 仍然附加到 对象 x 附加到，并且取消引用它是未定义的行为，除非 x 和 y 指向同一个分配的对象。</p><p>In other words, <code>let z = x.wrapping_offset((y as isize) - (x as isize))</code> does <em>not</em> make <code>z</code>
the same as <code>y</code> even if we assume <code>T</code> has size <code>1</code> and there is no overflow: <code>z</code> is still
attached to the object <code>x</code> is attached to, and dereferencing it is Undefined Behavior unless
<code>x</code> and <code>y</code> point into the same allocated object.</p>
<p class="translate-text">与offset相比，这种方法基本上延迟了停留在同一个分配对象内的要求：offset是立即跨越对象边界时的未定义行为； wrapping_offset 会产生一个指针，但如果指针在其附加到的对象超出范围时被取消引用，它仍会导致未定义行为。 offset 可以更好地优化，因此在性能敏感的代码中更可取。</p><p>Compared to <a href="#method.offset"><code>offset</code></a>, this method basically delays the requirement of staying within the
same allocated object: <a href="#method.offset"><code>offset</code></a> is immediate Undefined Behavior when crossing object
boundaries; <code>wrapping_offset</code> produces a pointer but still leads to Undefined Behavior if a
pointer is dereferenced when it is out-of-bounds of the object it is attached to. <a href="#method.offset"><code>offset</code></a>
can be optimized better and is thus preferable in performance-sensitive code.</p>
<p class="translate-text">延迟检查仅考虑被取消引用的指针的值，而不考虑在计算最终结果期间使用的中间值。 例如，x.wrapping_offset(o).wrapping_offset(o.wrapping_neg()) 总是与 x 相同。 换句话说，允许离开分配的对象，然后再重新进入它。</p><p>The delayed check only considers the value of the pointer that was dereferenced, not the
intermediate values used during the computation of the final result. For example,
<code>x.wrapping_offset(o).wrapping_offset(o.wrapping_neg())</code> is always the same as <code>x</code>. In other
words, leaving the allocated object and then re-entering it later is permitted.</p>
<h1 id="examples-4" class="section-header"><a href="#examples-4">Examples</a></h1>
<p class="translate-text">基本用法：</p><p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Iterate using a raw pointer in increments of two elements</span>
<span class="kw">let</span> <span class="ident">data</span> <span class="op">=</span> [<span class="number">1u8</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">ptr</span>: <span class="kw-2">*</span><span class="kw">const</span> <span class="ident">u8</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">as_ptr</span>();
<span class="kw">let</span> <span class="ident">step</span> <span class="op">=</span> <span class="number">2</span>;
<span class="kw">let</span> <span class="ident">end_rounded_up</span> <span class="op">=</span> <span class="ident">ptr</span>.<span class="ident">wrapping_offset</span>(<span class="number">6</span>);

<span class="comment">// This loop prints &quot;1, 3, 5, &quot;</span>
<span class="kw">while</span> <span class="ident">ptr</span> <span class="op">!</span><span class="op">=</span> <span class="ident">end_rounded_up</span> {
    <span class="kw">unsafe</span> {
        <span class="macro">print!</span>(<span class="string">&quot;{}, &quot;</span>, <span class="kw-2">*</span><span class="ident">ptr</span>);
    }
    <span class="ident">ptr</span> <span class="op">=</span> <span class="ident">ptr</span>.<span class="ident">wrapping_offset</span>(<span class="ident">step</span>);
}</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%2F%2F%20Iterate%20using%20a%20raw%20pointer%20in%20increments%20of%20two%20elements%0Afn%20main()%20%7B%0Alet%20data%20%3D%20%5B1u8%2C%202%2C%203%2C%204%2C%205%5D%3B%0Alet%20mut%20ptr%3A%20*const%20u8%20%3D%20data.as_ptr()%3B%0Alet%20step%20%3D%202%3B%0Alet%20end_rounded_up%20%3D%20ptr.wrapping_offset(6)%3B%0A%0A%2F%2F%20This%20loop%20prints%20%221%2C%203%2C%205%2C%20%22%0Awhile%20ptr%20!%3D%20end_rounded_up%20%7B%0A%20%20%20%20unsafe%20%7B%0A%20%20%20%20%20%20%20%20print!(%22%7B%7D%2C%20%22%2C%20*ptr)%3B%0A%20%20%20%20%7D%0A%20%20%20%20ptr%20%3D%20ptr.wrapping_offset(step)%3B%0A%7D%0A%7D&amp;edition=2018">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.offset_from" class="method has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.47.0, const unstable">1.47.0 (const: <a href="https://github.com/rust-lang/rust/issues/41079" title="Tracking issue for const_ptr_offset_from">unstable</a>)</span><a class="srclink" href="../src/core/ptr/const_ptr.rs.html#384-386" title="goto source code">[src]</a></div><a href="#method.offset_from" class="anchor"></a><h4 class="code-header">pub unsafe fn <a href="#method.offset_from" class="fnname">offset_from</a>(self, origin: <a class="primitive" href="primitive.pointer.html">*const T</a>) -&gt; <a class="primitive" href="primitive.isize.html">isize</a></h4></div></summary><div class="docblock" xpath="/html[1]/body[1]/section[1]/details[2]/div[1]/details[8]/div[1]" istranslationnode="true" main_mp="Y25yZD4/dHFyOzpia2t3cU9hZGMuLz52f39jZTRBLi9PR0ZSQVF7Q1JOTQ=="><p class="translate-text">计算两个指针之间的距离。 返回值以 T 为单位：以字节为单位的距离除以 mem::size_of::<t>()。</t></p><p>Calculates the distance between two pointers. The returned value is in
units of T: the distance in bytes is divided by <code>mem::size_of::&lt;T&gt;()</code>.</p>
<p class="translate-text">该函数是偏移量的倒数。</p><p>This function is the inverse of <a href="#method.offset"><code>offset</code></a>.</p>
<h1 id="safety-4" class="section-header"><a href="#safety-4">Safety</a></h1>
<p class="translate-text">如果违反以下任何条件，则结果为未定义行为：</p><p>If any of the following conditions are violated, the result is Undefined
Behavior:</p>
<ul>
<li class="translate-text">起始指针和其他指针都必须在边界内或超过同一分配对象的末尾一个字节。</li><li>
<p>Both the starting and other pointer must be either in bounds or one
byte past the end of the same <a href="ptr/index.html#allocated-object">allocated object</a>.</p>
</li>
<li class="translate-text">两个指针都必须从指向同一个对象的指针派生。 （请参见下面的示例。）</li><li>
<p>Both pointers must be <em>derived from</em> a pointer to the same object.
(See below for an example.)</p>
</li>
<li class="translate-text">指针之间的距离（以字节为单位）必须是 T 大小的精确倍数。</li><li>
<p>The distance between the pointers, in bytes, must be an exact multiple
of the size of <code>T</code>.</p>
</li>
<li class="translate-text">指针之间的距离（以字节为单位）不能溢出 isize。</li><li>
<p>The distance between the pointers, <strong>in bytes</strong>, cannot overflow an <code>isize</code>.</p>
</li>
<li class="translate-text">范围内的距离不能依赖于“环绕”地址空间。</li><li>
<p>The distance being in bounds cannot rely on “wrapping around” the address space.</p>
</li>
</ul>
<p class="translate-text">Rust 类型永远不会大于 isize::MAX 并且 Rust 分配永远不会环绕地址空间，因此任何 Rust 类型 T 的某个值内的两个指针将始终满足最后两个条件。 标准库通常还确保分配永远不会达到需要考虑偏移量的大小。 例如， Vec 和 Box 确保它们分配的字节数永远不会超过 isize::MAX 字节，因此 ptr_into_vec.offset_from(vec.as_ptr()) 总是满足最后两个条件。</p><p>Rust types are never larger than <code>isize::MAX</code> and Rust allocations never wrap around the
address space, so two pointers within some value of any Rust type <code>T</code> will always satisfy
the last two conditions. The standard library also generally ensures that allocations
never reach a size where an offset is a concern. For instance, <code>Vec</code> and <code>Box</code> ensure they
never allocate more than <code>isize::MAX</code> bytes, so <code>ptr_into_vec.offset_from(vec.as_ptr())</code>
always satisfies the last two conditions.</p>
<p class="translate-text">大多数平台根本无法构建如此大的分配。 例如，由于页表限制或地址空间分割，没有已知的 64 位平台可以为 263 字节的请求提供服务。 但是，一些 32 位和 16 位平台可能会成功地为超过 isize::MAX 字节的请求提供物理地址扩展等内容。 因此，直接从分配器或内存映射文件获取的内存可能太大而无法使用此函数处理。 （请注意，offset 和 add 也有类似的限制，因此也不能用于如此大的分配。）</p><p>Most platforms fundamentally can’t even construct such a large allocation.
For instance, no known 64-bit platform can ever serve a request
for 2<sup>63</sup> bytes due to page-table limitations or splitting the address space.
However, some 32-bit and 16-bit platforms may successfully serve a request for
more than <code>isize::MAX</code> bytes with things like Physical Address
Extension. As such, memory acquired directly from allocators or memory
mapped files <em>may</em> be too large to handle with this function.
(Note that <a href="#method.offset"><code>offset</code></a> and <a href="#method.add"><code>add</code></a> also have a similar limitation and hence cannot be used on
such large allocations either.)</p>
<h1 id="panics" class="section-header"><a href="#panics">Panics</a></h1>
<p class="translate-text">如果 T 是零大小类型（“ZST”），则此函数会出现panic。</p><p>This function panics if <code>T</code> is a Zero-Sized Type (“ZST”).</p>
<h1 id="examples-5" class="section-header"><a href="#examples-5">Examples</a></h1>
<p class="translate-text">基本用法：</p><p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">a</span> <span class="op">=</span> [<span class="number">0</span>; <span class="number">5</span>];
<span class="kw">let</span> <span class="ident">ptr1</span>: <span class="kw-2">*</span><span class="kw">const</span> <span class="ident">i32</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="ident">a</span>[<span class="number">1</span>];
<span class="kw">let</span> <span class="ident">ptr2</span>: <span class="kw-2">*</span><span class="kw">const</span> <span class="ident">i32</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="ident">a</span>[<span class="number">3</span>];
<span class="kw">unsafe</span> {
    <span class="macro">assert_eq!</span>(<span class="ident">ptr2</span>.<span class="ident">offset_from</span>(<span class="ident">ptr1</span>), <span class="number">2</span>);
    <span class="macro">assert_eq!</span>(<span class="ident">ptr1</span>.<span class="ident">offset_from</span>(<span class="ident">ptr2</span>), <span class="op">-</span><span class="number">2</span>);
    <span class="macro">assert_eq!</span>(<span class="ident">ptr1</span>.<span class="ident">offset</span>(<span class="number">2</span>), <span class="ident">ptr2</span>);
    <span class="macro">assert_eq!</span>(<span class="ident">ptr2</span>.<span class="ident">offset</span>(<span class="op">-</span><span class="number">2</span>), <span class="ident">ptr1</span>);
}</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20a%20%3D%20%5B0%3B%205%5D%3B%0Alet%20ptr1%3A%20*const%20i32%20%3D%20%26a%5B1%5D%3B%0Alet%20ptr2%3A%20*const%20i32%20%3D%20%26a%5B3%5D%3B%0Aunsafe%20%7B%0A%20%20%20%20assert_eq!(ptr2.offset_from(ptr1)%2C%202)%3B%0A%20%20%20%20assert_eq!(ptr1.offset_from(ptr2)%2C%20-2)%3B%0A%20%20%20%20assert_eq!(ptr1.offset(2)%2C%20ptr2)%3B%0A%20%20%20%20assert_eq!(ptr2.offset(-2)%2C%20ptr1)%3B%0A%7D%0A%7D&amp;edition=2018">Run</a></div>
<p class="translate-text">错误用法：</p><p><em>Incorrect</em> usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">ptr1</span> <span class="op">=</span> <span class="ident">Box::into_raw</span>(<span class="ident">Box::new</span>(<span class="number">0u8</span>)) <span class="kw">as</span> <span class="kw-2">*</span><span class="kw">const</span> <span class="ident">u8</span>;
<span class="kw">let</span> <span class="ident">ptr2</span> <span class="op">=</span> <span class="ident">Box::into_raw</span>(<span class="ident">Box::new</span>(<span class="number">1u8</span>)) <span class="kw">as</span> <span class="kw-2">*</span><span class="kw">const</span> <span class="ident">u8</span>;
<span class="kw">let</span> <span class="ident">diff</span> <span class="op">=</span> (<span class="ident">ptr2</span> <span class="kw">as</span> <span class="ident">isize</span>).<span class="ident">wrapping_sub</span>(<span class="ident">ptr1</span> <span class="kw">as</span> <span class="ident">isize</span>);
<span class="comment">// Make ptr2_other an &quot;alias&quot; of ptr2, but derived from ptr1.</span>
<span class="kw">let</span> <span class="ident">ptr2_other</span> <span class="op">=</span> (<span class="ident">ptr1</span> <span class="kw">as</span> <span class="kw-2">*</span><span class="kw">const</span> <span class="ident">u8</span>).<span class="ident">wrapping_offset</span>(<span class="ident">diff</span>);
<span class="macro">assert_eq!</span>(<span class="ident">ptr2</span> <span class="kw">as</span> <span class="ident">usize</span>, <span class="ident">ptr2_other</span> <span class="kw">as</span> <span class="ident">usize</span>);
<span class="comment">// Since ptr2_other and ptr2 are derived from pointers to different objects,</span>
<span class="comment">// computing their offset is undefined behavior, even though</span>
<span class="comment">// they point to the same address!</span>
<span class="kw">unsafe</span> {
    <span class="kw">let</span> <span class="ident">zero</span> <span class="op">=</span> <span class="ident">ptr2_other</span>.<span class="ident">offset_from</span>(<span class="ident">ptr2</span>); <span class="comment">// Undefined Behavior</span>
}</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20ptr1%20%3D%20Box%3A%3Ainto_raw(Box%3A%3Anew(0u8))%20as%20*const%20u8%3B%0Alet%20ptr2%20%3D%20Box%3A%3Ainto_raw(Box%3A%3Anew(1u8))%20as%20*const%20u8%3B%0Alet%20diff%20%3D%20(ptr2%20as%20isize).wrapping_sub(ptr1%20as%20isize)%3B%0A%2F%2F%20Make%20ptr2_other%20an%20%22alias%22%20of%20ptr2%2C%20but%20derived%20from%20ptr1.%0Alet%20ptr2_other%20%3D%20(ptr1%20as%20*const%20u8).wrapping_offset(diff)%3B%0Aassert_eq!(ptr2%20as%20usize%2C%20ptr2_other%20as%20usize)%3B%0A%2F%2F%20Since%20ptr2_other%20and%20ptr2%20are%20derived%20from%20pointers%20to%20different%20objects%2C%0A%2F%2F%20computing%20their%20offset%20is%20undefined%20behavior%2C%20even%20though%0A%2F%2F%20they%20point%20to%20the%20same%20address!%0Aunsafe%20%7B%0A%20%20%20%20let%20zero%20%3D%20ptr2_other.offset_from(ptr2)%3B%20%2F%2F%20Undefined%20Behavior%0A%7D%0A%7D&amp;edition=2018">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.guaranteed_eq" class="method has-srclink"><div class="rightside"><a class="srclink" href="../src/core/ptr/const_ptr.rs.html#418-420" title="goto source code">[src]</a></div><a href="#method.guaranteed_eq" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.guaranteed_eq" class="fnname">guaranteed_eq</a>(self, other: <a class="primitive" href="primitive.pointer.html">*const T</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></div><div class="item-info"><div class="stab unstable"><span class="emoji">🔬</span> This is a nightly-only experimental API. (<code>const_raw_ptr_comparison</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/53020">#53020</a>)</div></div></summary><div class="docblock" xpath="/html[1]/body[1]/section[1]/details[2]/div[1]/details[9]/div[1]" istranslationnode="true" main_mp="Y25yZD4/dHFyOzpia2t3cU9hZGMuLz52f39jZTRBLi9HVEFTRUtQQEVFf0RV"><p class="translate-text">返回是否保证两个指针相等。</p><p>Returns whether two pointers are guaranteed to be equal.</p>
<p class="translate-text">在运行时，此函数的行为类似于 self == other。 但是，在某些情况下（例如，编译时评估），并不总是可以确定两个指针的相等性，因此该函数可能会虚假地为后来实际上相等的指针返回 false。 但是当它返回 true 时，指针保证是相等的。</p><p>At runtime this function behaves like <code>self == other</code>.
However, in some contexts (e.g., compile-time evaluation),
it is not always possible to determine equality of two pointers, so this function may
spuriously return <code>false</code> for pointers that later actually turn out to be equal.
But when it returns <code>true</code>, the pointers are guaranteed to be equal.</p>
<p class="translate-text">这个函数是Guaranteed_ne 的镜像，但不是它的逆函数。 存在两个函数都返回 false 的指针比较。</p><p>This function is the mirror of <a href="#method.guaranteed_ne"><code>guaranteed_ne</code></a>, but not its inverse. There are pointer
comparisons for which both functions return <code>false</code>.</p>
<p class="translate-text">返回值可能会根据编译器版本而变化，并且不安全的代码可能不依赖此函数的结果来保证可靠性。 建议仅将此函数用于性能优化，其中此函数的虚假返回值不会影响结果，而只会影响性能。 尚未探索使用此方法使运行时和编译时代码行为不同的后果。 这种方法不应该用来引入这样的差异，在我们对这个问题有更好的理解之前，它也不应该被稳定下来。</p><p>The return value may change depending on the compiler version and unsafe code might not
rely on the result of this function for soundness. It is suggested to only use this function
for performance optimizations where spurious <code>false</code> return values by this function do not
affect the outcome, but just the performance.
The consequences of using this method to make runtime and compile-time code behave
differently have not been explored. This method should not be used to introduce such
differences, and it should also not be stabilized before we have a better understanding
of this issue.</p>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.guaranteed_ne" class="method has-srclink"><div class="rightside"><a class="srclink" href="../src/core/ptr/const_ptr.rs.html#449-451" title="goto source code">[src]</a></div><a href="#method.guaranteed_ne" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.guaranteed_ne" class="fnname">guaranteed_ne</a>(self, other: <a class="primitive" href="primitive.pointer.html">*const T</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></div><div class="item-info"><div class="stab unstable"><span class="emoji">🔬</span> This is a nightly-only experimental API. (<code>const_raw_ptr_comparison</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/53020">#53020</a>)</div></div></summary><div class="docblock" xpath="/html[1]/body[1]/section[1]/details[2]/div[1]/details[10]/div[1]" istranslationnode="true" main_mp="Y25yZD4/dHFyOzpia2t3cU9hZGMuLz52f39jZTRBLi9HVEFTRUtQQEVFf09B"><p class="translate-text">返回是否保证两个指针不相等。</p><p>Returns whether two pointers are guaranteed to be unequal.</p>
<p class="translate-text">在运行时，此函数的行为类似于 self != other。 但是，在某些情况下（例如，编译时评估），并不总是可以确定两个指针的不等式，因此该函数可能会虚假地返回 false，因为这些指针后来实际上是不等的。 但是当它返回 true 时，指针保证不相等。</p><p>At runtime this function behaves like <code>self != other</code>.
However, in some contexts (e.g., compile-time evaluation),
it is not always possible to determine the inequality of two pointers, so this function may
spuriously return <code>false</code> for pointers that later actually turn out to be unequal.
But when it returns <code>true</code>, the pointers are guaranteed to be unequal.</p>
<p class="translate-text">这个函数是Guaranteed_eq 的镜像，但不是它的倒数。 存在两个函数都返回 false 的指针比较。</p><p>This function is the mirror of <a href="#method.guaranteed_eq"><code>guaranteed_eq</code></a>, but not its inverse. There are pointer
comparisons for which both functions return <code>false</code>.</p>
<p class="translate-text">返回值可能会根据编译器版本而变化，并且不安全的代码可能不依赖此函数的结果来保证可靠性。 建议仅将此函数用于性能优化，其中此函数的虚假返回值不会影响结果，而只会影响性能。 尚未探索使用此方法使运行时和编译时代码行为不同的后果。 这种方法不应该用来引入这样的差异，在我们对这个问题有更好的理解之前，它也不应该被稳定下来。</p><p>The return value may change depending on the compiler version and unsafe code might not
rely on the result of this function for soundness. It is suggested to only use this function
for performance optimizations where spurious <code>false</code> return values by this function do not
affect the outcome, but just the performance.
The consequences of using this method to make runtime and compile-time code behave
differently have not been explored. This method should not be used to introduce such
differences, and it should also not be stabilized before we have a better understanding
of this issue.</p>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.add" class="method has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.26.0, const unstable">1.26.0 (const: <a href="https://github.com/rust-lang/rust/issues/71499" title="Tracking issue for const_ptr_offset">unstable</a>)</span><a class="srclink" href="../src/core/ptr/const_ptr.rs.html#511-513" title="goto source code">[src]</a></div><a href="#method.add" class="anchor"></a><h4 class="code-header">pub unsafe fn <a href="#method.add" class="fnname">add</a>(self, count: <a class="primitive" href="primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="primitive.pointer.html">*const T</a></h4></div></summary><div class="docblock" xpath="/html[1]/body[1]/section[1]/details[2]/div[1]/details[11]/div[1]" istranslationnode="true" main_mp="Y25yZD4/dHFyOzpia2t3cU9hZGMuLz52f39jZTRBLi9BRUQ="><p class="translate-text">计算指针的偏移量（.offset(count as isize) 的便利）。</p><p>Calculates the offset from a pointer (convenience for <code>.offset(count as isize)</code>).</p>
<p class="translate-text">计数以 T 为单位； 例如，计数 3 表示 3 * size_of::<t>() 字节的指针偏移量。</t></p><p><code>count</code> is in units of T; e.g., a <code>count</code> of 3 represents a pointer
offset of <code>3 * size_of::&lt;T&gt;()</code> bytes.</p>
<h1 id="safety-5" class="section-header"><a href="#safety-5">Safety</a></h1>
<p class="translate-text">如果违反以下任何条件，则结果为未定义行为：</p><p>If any of the following conditions are violated, the result is Undefined
Behavior:</p>
<ul>
<li class="translate-text">起始指针和结果指针都必须在边界内或超过同一分配对象的末尾一个字节。</li><li>
<p>Both the starting and resulting pointer must be either in bounds or one
byte past the end of the same <a href="ptr/index.html#allocated-object">allocated object</a>.</p>
</li>
<li class="translate-text">计算的偏移量（以字节为单位）不能溢出 isize。</li><li>
<p>The computed offset, <strong>in bytes</strong>, cannot overflow an <code>isize</code>.</p>
</li>
<li class="translate-text">范围内的偏移量不能依赖于“环绕”地址空间。 也就是说，无限精度和必须适合使用大小。</li><li>
<p>The offset being in bounds cannot rely on “wrapping around” the address
space. That is, the infinite-precision sum must fit in a <code>usize</code>.</p>
</li>
</ul>
<p class="translate-text">编译器和标准库通常会尝试确保分配永远不会达到需要考虑偏移量的大小。 例如， Vec 和 Box 确保它们分配的字节数永远不会超过 isize::MAX 字节，因此 vec.as_ptr().add(vec.len()) 总是安全的。</p><p>The compiler and standard library generally tries to ensure allocations
never reach a size where an offset is a concern. For instance, <code>Vec</code>
and <code>Box</code> ensure they never allocate more than <code>isize::MAX</code> bytes, so
<code>vec.as_ptr().add(vec.len())</code> is always safe.</p>
<p class="translate-text">大多数平台根本无法构建这样的分配。 例如，由于页表限制或地址空间分割，没有已知的 64 位平台可以为 263 字节的请求提供服务。 但是，一些 32 位和 16 位平台可能会成功地为超过 isize::MAX 字节的请求提供物理地址扩展等内容。 因此，直接从分配器或内存映射文件获取的内存可能太大而无法使用此函数处理。</p><p>Most platforms fundamentally can’t even construct such an allocation.
For instance, no known 64-bit platform can ever serve a request
for 2<sup>63</sup> bytes due to page-table limitations or splitting the address space.
However, some 32-bit and 16-bit platforms may successfully serve a request for
more than <code>isize::MAX</code> bytes with things like Physical Address
Extension. As such, memory acquired directly from allocators or memory
mapped files <em>may</em> be too large to handle with this function.</p>
<p class="translate-text">如果这些约束难以满足，请考虑使用 wrapping_add。 这种方法的唯一优点是它可以实现更积极的编译器优化。</p><p>Consider using <a href="#method.wrapping_add"><code>wrapping_add</code></a> instead if these constraints are
difficult to satisfy. The only advantage of this method is that it
enables more aggressive compiler optimizations.</p>
<h1 id="examples-6" class="section-header"><a href="#examples-6">Examples</a></h1>
<p class="translate-text">基本用法：</p><p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">s</span>: <span class="kw-2">&amp;</span><span class="ident">str</span> <span class="op">=</span> <span class="string">&quot;123&quot;</span>;
<span class="kw">let</span> <span class="ident">ptr</span>: <span class="kw-2">*</span><span class="kw">const</span> <span class="ident">u8</span> <span class="op">=</span> <span class="ident">s</span>.<span class="ident">as_ptr</span>();

<span class="kw">unsafe</span> {
    <span class="macro">println!</span>(<span class="string">&quot;{}&quot;</span>, <span class="kw-2">*</span><span class="ident">ptr</span>.<span class="ident">add</span>(<span class="number">1</span>) <span class="kw">as</span> <span class="ident">char</span>);
    <span class="macro">println!</span>(<span class="string">&quot;{}&quot;</span>, <span class="kw-2">*</span><span class="ident">ptr</span>.<span class="ident">add</span>(<span class="number">2</span>) <span class="kw">as</span> <span class="ident">char</span>);
}</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20s%3A%20%26str%20%3D%20%22123%22%3B%0Alet%20ptr%3A%20*const%20u8%20%3D%20s.as_ptr()%3B%0A%0Aunsafe%20%7B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20*ptr.add(1)%20as%20char)%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20*ptr.add(2)%20as%20char)%3B%0A%7D%0A%7D&amp;edition=2018">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.sub" class="method has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.26.0, const unstable">1.26.0 (const: <a href="https://github.com/rust-lang/rust/issues/71499" title="Tracking issue for const_ptr_offset">unstable</a>)</span><a class="srclink" href="../src/core/ptr/const_ptr.rs.html#575-577" title="goto source code">[src]</a></div><a href="#method.sub" class="anchor"></a><h4 class="code-header">pub unsafe fn <a href="#method.sub" class="fnname">sub</a>(self, count: <a class="primitive" href="primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="primitive.pointer.html">*const T</a></h4></div></summary><div class="docblock" xpath="/html[1]/body[1]/section[1]/details[2]/div[1]/details[12]/div[1]" istranslationnode="true" main_mp="Y25yZD4/dHFyOzpia2t3cU9hZGMuLz52f39jZTRBLi9TVEI="><p class="translate-text">计算指针的偏移量（方便 .offset((count as isize).wrapping_neg())）。</p><p>Calculates the offset from a pointer (convenience for
<code>.offset((count as isize).wrapping_neg())</code>).</p>
<p class="translate-text">计数以 T 为单位； 例如，计数 3 表示 3 * size_of::<t>() 字节的指针偏移量。</t></p><p><code>count</code> is in units of T; e.g., a <code>count</code> of 3 represents a pointer
offset of <code>3 * size_of::&lt;T&gt;()</code> bytes.</p>
<h1 id="safety-6" class="section-header"><a href="#safety-6">Safety</a></h1>
<p class="translate-text">如果违反以下任何条件，则结果为未定义行为：</p><p>If any of the following conditions are violated, the result is Undefined
Behavior:</p>
<ul>
<li class="translate-text">起始指针和结果指针都必须在边界内或超过同一分配对象的末尾一个字节。</li><li>
<p>Both the starting and resulting pointer must be either in bounds or one
byte past the end of the same <a href="ptr/index.html#allocated-object">allocated object</a>.</p>
</li>
<li class="translate-text">计算出的偏移量不能超过 isize::MAX 字节。</li><li>
<p>The computed offset cannot exceed <code>isize::MAX</code> <strong>bytes</strong>.</p>
</li>
<li class="translate-text">范围内的偏移量不能依赖于“环绕”地址空间。 也就是说，无限精度和必须适合使用大小。</li><li>
<p>The offset being in bounds cannot rely on “wrapping around” the address
space. That is, the infinite-precision sum must fit in a usize.</p>
</li>
</ul>
<p class="translate-text">编译器和标准库通常会尝试确保分配永远不会达到需要考虑偏移量的大小。 例如， Vec 和 Box 确保它们分配的字节数永远不会超过 isize::MAX 字节，因此 vec.as_ptr().add(vec.len()).sub(vec.len()) 总是安全的。</p><p>The compiler and standard library generally tries to ensure allocations
never reach a size where an offset is a concern. For instance, <code>Vec</code>
and <code>Box</code> ensure they never allocate more than <code>isize::MAX</code> bytes, so
<code>vec.as_ptr().add(vec.len()).sub(vec.len())</code> is always safe.</p>
<p class="translate-text">大多数平台根本无法构建这样的分配。 例如，由于页表限制或地址空间分割，没有已知的 64 位平台可以为 263 字节的请求提供服务。 但是，一些 32 位和 16 位平台可能会成功地为超过 isize::MAX 字节的请求提供物理地址扩展等内容。 因此，直接从分配器或内存映射文件获取的内存可能太大而无法使用此函数处理。</p><p>Most platforms fundamentally can’t even construct such an allocation.
For instance, no known 64-bit platform can ever serve a request
for 2<sup>63</sup> bytes due to page-table limitations or splitting the address space.
However, some 32-bit and 16-bit platforms may successfully serve a request for
more than <code>isize::MAX</code> bytes with things like Physical Address
Extension. As such, memory acquired directly from allocators or memory
mapped files <em>may</em> be too large to handle with this function.</p>
<p class="translate-text">如果这些约束难以满足，请考虑使用 wrapping_sub。 这种方法的唯一优点是它可以实现更积极的编译器优化。</p><p>Consider using <a href="#method.wrapping_sub"><code>wrapping_sub</code></a> instead if these constraints are
difficult to satisfy. The only advantage of this method is that it
enables more aggressive compiler optimizations.</p>
<h1 id="examples-7" class="section-header"><a href="#examples-7">Examples</a></h1>
<p class="translate-text">基本用法：</p><p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">s</span>: <span class="kw-2">&amp;</span><span class="ident">str</span> <span class="op">=</span> <span class="string">&quot;123&quot;</span>;

<span class="kw">unsafe</span> {
    <span class="kw">let</span> <span class="ident">end</span>: <span class="kw-2">*</span><span class="kw">const</span> <span class="ident">u8</span> <span class="op">=</span> <span class="ident">s</span>.<span class="ident">as_ptr</span>().<span class="ident">add</span>(<span class="number">3</span>);
    <span class="macro">println!</span>(<span class="string">&quot;{}&quot;</span>, <span class="kw-2">*</span><span class="ident">end</span>.<span class="ident">sub</span>(<span class="number">1</span>) <span class="kw">as</span> <span class="ident">char</span>);
    <span class="macro">println!</span>(<span class="string">&quot;{}&quot;</span>, <span class="kw-2">*</span><span class="ident">end</span>.<span class="ident">sub</span>(<span class="number">2</span>) <span class="kw">as</span> <span class="ident">char</span>);
}</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20s%3A%20%26str%20%3D%20%22123%22%3B%0A%0Aunsafe%20%7B%0A%20%20%20%20let%20end%3A%20*const%20u8%20%3D%20s.as_ptr().add(3)%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20*end.sub(1)%20as%20char)%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20*end.sub(2)%20as%20char)%3B%0A%7D%0A%7D&amp;edition=2018">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.wrapping_add" class="method has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.26.0, const unstable">1.26.0 (const: <a href="https://github.com/rust-lang/rust/issues/71499" title="Tracking issue for const_ptr_offset">unstable</a>)</span><a class="srclink" href="../src/core/ptr/const_ptr.rs.html#638-640" title="goto source code">[src]</a></div><a href="#method.wrapping_add" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.wrapping_add" class="fnname">wrapping_add</a>(self, count: <a class="primitive" href="primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="primitive.pointer.html">*const T</a></h4></div></summary><div class="docblock" xpath="/html[1]/body[1]/section[1]/details[2]/div[1]/details[13]/div[1]" istranslationnode="true" main_mp="Y25yZD4/dHFyOzpia2t3cU9hZGMuLz52f39jZTRBLi9XU0FRVExKQn9AREU="><p class="translate-text">使用环绕算法计算指针的偏移量。 （方便.wrapping_offset（计为isize））</p><p>Calculates the offset from a pointer using wrapping arithmetic.
(convenience for <code>.wrapping_offset(count as isize)</code>)</p>
<p class="translate-text">计数以 T 为单位； 例如，计数 3 表示 3 * size_of::<t>() 字节的指针偏移量。</t></p><p><code>count</code> is in units of T; e.g., a <code>count</code> of 3 represents a pointer
offset of <code>3 * size_of::&lt;T&gt;()</code> bytes.</p>
<h1 id="safety-7" class="section-header"><a href="#safety-7">Safety</a></h1>
<p class="translate-text">这个操作本身总是安全的，但使用结果指针却不是。</p><p>This operation itself is always safe, but using the resulting pointer is not.</p>
<p class="translate-text">结果指针“记住”了 self 指向的已分配对象； 它不能用于读取或写入其他分配的对象。</p><p>The resulting pointer “remembers” the <a href="ptr/index.html#allocated-object">allocated object</a> that <code>self</code> points to; it must not
be used to read or write other allocated objects.</p>
<p class="translate-text">换句话说，即使我们假设 T 的大小为 1 并且没有溢出， let z = x.wrapping_add((y as usize) - (x as usize)) 也不会使 z 与 y 相同：z 仍然附加到 对象 x 附加到，并且取消引用它是未定义的行为，除非 x 和 y 指向同一个分配的对象。</p><p>In other words, <code>let z = x.wrapping_add((y as usize) - (x as usize))</code> does <em>not</em> make <code>z</code>
the same as <code>y</code> even if we assume <code>T</code> has size <code>1</code> and there is no overflow: <code>z</code> is still
attached to the object <code>x</code> is attached to, and dereferencing it is Undefined Behavior unless
<code>x</code> and <code>y</code> point into the same allocated object.</p>
<p class="translate-text">与add相比，这种方法基本上延迟了停留在同一个分配对象内的要求：add是跨越对象边界时立即发生的Undefined Behavior； wrapping_add 会产生一个指针，但如果指针在其附加到的对象超出范围时被取消引用，它仍会导致未定义行为。 add 可以更好地优化，因此在性能敏感的代码中更可取。</p><p>Compared to <a href="#method.add"><code>add</code></a>, this method basically delays the requirement of staying within the
same allocated object: <a href="#method.add"><code>add</code></a> is immediate Undefined Behavior when crossing object
boundaries; <code>wrapping_add</code> produces a pointer but still leads to Undefined Behavior if a
pointer is dereferenced when it is out-of-bounds of the object it is attached to. <a href="#method.add"><code>add</code></a>
can be optimized better and is thus preferable in performance-sensitive code.</p>
<p class="translate-text">延迟检查仅考虑被取消引用的指针的值，而不考虑在计算最终结果期间使用的中间值。 例如，x.wrapping_add(o).wrapping_sub(o) 总是与 x 相同。 换句话说，允许离开分配的对象，然后再重新进入它。</p><p>The delayed check only considers the value of the pointer that was dereferenced, not the
intermediate values used during the computation of the final result. For example,
<code>x.wrapping_add(o).wrapping_sub(o)</code> is always the same as <code>x</code>. In other words, leaving the
allocated object and then re-entering it later is permitted.</p>
<h1 id="examples-8" class="section-header"><a href="#examples-8">Examples</a></h1>
<p class="translate-text">基本用法：</p><p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Iterate using a raw pointer in increments of two elements</span>
<span class="kw">let</span> <span class="ident">data</span> <span class="op">=</span> [<span class="number">1u8</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">ptr</span>: <span class="kw-2">*</span><span class="kw">const</span> <span class="ident">u8</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">as_ptr</span>();
<span class="kw">let</span> <span class="ident">step</span> <span class="op">=</span> <span class="number">2</span>;
<span class="kw">let</span> <span class="ident">end_rounded_up</span> <span class="op">=</span> <span class="ident">ptr</span>.<span class="ident">wrapping_add</span>(<span class="number">6</span>);

<span class="comment">// This loop prints &quot;1, 3, 5, &quot;</span>
<span class="kw">while</span> <span class="ident">ptr</span> <span class="op">!</span><span class="op">=</span> <span class="ident">end_rounded_up</span> {
    <span class="kw">unsafe</span> {
        <span class="macro">print!</span>(<span class="string">&quot;{}, &quot;</span>, <span class="kw-2">*</span><span class="ident">ptr</span>);
    }
    <span class="ident">ptr</span> <span class="op">=</span> <span class="ident">ptr</span>.<span class="ident">wrapping_add</span>(<span class="ident">step</span>);
}</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%2F%2F%20Iterate%20using%20a%20raw%20pointer%20in%20increments%20of%20two%20elements%0Afn%20main()%20%7B%0Alet%20data%20%3D%20%5B1u8%2C%202%2C%203%2C%204%2C%205%5D%3B%0Alet%20mut%20ptr%3A%20*const%20u8%20%3D%20data.as_ptr()%3B%0Alet%20step%20%3D%202%3B%0Alet%20end_rounded_up%20%3D%20ptr.wrapping_add(6)%3B%0A%0A%2F%2F%20This%20loop%20prints%20%221%2C%203%2C%205%2C%20%22%0Awhile%20ptr%20!%3D%20end_rounded_up%20%7B%0A%20%20%20%20unsafe%20%7B%0A%20%20%20%20%20%20%20%20print!(%22%7B%7D%2C%20%22%2C%20*ptr)%3B%0A%20%20%20%20%7D%0A%20%20%20%20ptr%20%3D%20ptr.wrapping_add(step)%3B%0A%7D%0A%7D&amp;edition=2018">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.wrapping_sub" class="method has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.26.0, const unstable">1.26.0 (const: <a href="https://github.com/rust-lang/rust/issues/71499" title="Tracking issue for const_ptr_offset">unstable</a>)</span><a class="srclink" href="../src/core/ptr/const_ptr.rs.html#700-702" title="goto source code">[src]</a></div><a href="#method.wrapping_sub" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.wrapping_sub" class="fnname">wrapping_sub</a>(self, count: <a class="primitive" href="primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="primitive.pointer.html">*const T</a></h4></div></summary><div class="docblock" xpath="/html[1]/body[1]/section[1]/details[2]/div[1]/details[14]/div[1]" istranslationnode="true" main_mp="Y25yZD4/dHFyOzpia2t3cU9hZGMuLz52f39jZTRBLi9XU0FRVExKQn9SVUM="><p class="translate-text">使用环绕算法计算指针的偏移量。 （方便.wrapping_offset（（计为isize）.wrapping_neg（）））</p><p>Calculates the offset from a pointer using wrapping arithmetic.
(convenience for <code>.wrapping_offset((count as isize).wrapping_neg())</code>)</p>
<p class="translate-text">计数以 T 为单位； 例如，计数 3 表示 3 * size_of::<t>() 字节的指针偏移量。</t></p><p><code>count</code> is in units of T; e.g., a <code>count</code> of 3 represents a pointer
offset of <code>3 * size_of::&lt;T&gt;()</code> bytes.</p>
<h1 id="safety-8" class="section-header"><a href="#safety-8">Safety</a></h1>
<p class="translate-text">这个操作本身总是安全的，但使用结果指针却不是。</p><p>This operation itself is always safe, but using the resulting pointer is not.</p>
<p class="translate-text">结果指针“记住”了 self 指向的已分配对象； 它不能用于读取或写入其他分配的对象。</p><p>The resulting pointer “remembers” the <a href="ptr/index.html#allocated-object">allocated object</a> that <code>self</code> points to; it must not
be used to read or write other allocated objects.</p>
<p class="translate-text">换句话说，即使我们假设 T 的大小为 1 并且没有溢出， let z = x.wrapping_sub((x as usize) - (y as usize)) 也不会使 z 与 y 相同：z 仍然附加到 对象 x 附加到，并且取消引用它是未定义的行为，除非 x 和 y 指向同一个分配的对象。</p><p>In other words, <code>let z = x.wrapping_sub((x as usize) - (y as usize))</code> does <em>not</em> make <code>z</code>
the same as <code>y</code> even if we assume <code>T</code> has size <code>1</code> and there is no overflow: <code>z</code> is still
attached to the object <code>x</code> is attached to, and dereferencing it is Undefined Behavior unless
<code>x</code> and <code>y</code> point into the same allocated object.</p>
<p class="translate-text">与sub相比，这种方法基本上延迟了停留在同一个分配对象内的要求：sub是跨越对象边界时立即发生的Undefined Behavior； wrapping_sub 会产生一个指针，但如果指针在其附加到的对象超出范围时被取消引用，它仍会导致未定义行为。 sub 可以更好地优化，因此在性能敏感的代码中更可取。</p><p>Compared to <a href="#method.sub"><code>sub</code></a>, this method basically delays the requirement of staying within the
same allocated object: <a href="#method.sub"><code>sub</code></a> is immediate Undefined Behavior when crossing object
boundaries; <code>wrapping_sub</code> produces a pointer but still leads to Undefined Behavior if a
pointer is dereferenced when it is out-of-bounds of the object it is attached to. <a href="#method.sub"><code>sub</code></a>
can be optimized better and is thus preferable in performance-sensitive code.</p>
<p class="translate-text">延迟检查仅考虑被取消引用的指针的值，而不考虑在计算最终结果期间使用的中间值。 例如，x.wrapping_add(o).wrapping_sub(o) 总是与 x 相同。 换句话说，允许离开分配的对象，然后再重新进入它。</p><p>The delayed check only considers the value of the pointer that was dereferenced, not the
intermediate values used during the computation of the final result. For example,
<code>x.wrapping_add(o).wrapping_sub(o)</code> is always the same as <code>x</code>. In other words, leaving the
allocated object and then re-entering it later is permitted.</p>
<h1 id="examples-9" class="section-header"><a href="#examples-9">Examples</a></h1>
<p class="translate-text">基本用法：</p><p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Iterate using a raw pointer in increments of two elements (backwards)</span>
<span class="kw">let</span> <span class="ident">data</span> <span class="op">=</span> [<span class="number">1u8</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">ptr</span>: <span class="kw-2">*</span><span class="kw">const</span> <span class="ident">u8</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">as_ptr</span>();
<span class="kw">let</span> <span class="ident">start_rounded_down</span> <span class="op">=</span> <span class="ident">ptr</span>.<span class="ident">wrapping_sub</span>(<span class="number">2</span>);
<span class="ident">ptr</span> <span class="op">=</span> <span class="ident">ptr</span>.<span class="ident">wrapping_add</span>(<span class="number">4</span>);
<span class="kw">let</span> <span class="ident">step</span> <span class="op">=</span> <span class="number">2</span>;
<span class="comment">// This loop prints &quot;5, 3, 1, &quot;</span>
<span class="kw">while</span> <span class="ident">ptr</span> <span class="op">!</span><span class="op">=</span> <span class="ident">start_rounded_down</span> {
    <span class="kw">unsafe</span> {
        <span class="macro">print!</span>(<span class="string">&quot;{}, &quot;</span>, <span class="kw-2">*</span><span class="ident">ptr</span>);
    }
    <span class="ident">ptr</span> <span class="op">=</span> <span class="ident">ptr</span>.<span class="ident">wrapping_sub</span>(<span class="ident">step</span>);
}</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%2F%2F%20Iterate%20using%20a%20raw%20pointer%20in%20increments%20of%20two%20elements%20(backwards)%0Afn%20main()%20%7B%0Alet%20data%20%3D%20%5B1u8%2C%202%2C%203%2C%204%2C%205%5D%3B%0Alet%20mut%20ptr%3A%20*const%20u8%20%3D%20data.as_ptr()%3B%0Alet%20start_rounded_down%20%3D%20ptr.wrapping_sub(2)%3B%0Aptr%20%3D%20ptr.wrapping_add(4)%3B%0Alet%20step%20%3D%202%3B%0A%2F%2F%20This%20loop%20prints%20%225%2C%203%2C%201%2C%20%22%0Awhile%20ptr%20!%3D%20start_rounded_down%20%7B%0A%20%20%20%20unsafe%20%7B%0A%20%20%20%20%20%20%20%20print!(%22%7B%7D%2C%20%22%2C%20*ptr)%3B%0A%20%20%20%20%7D%0A%20%20%20%20ptr%20%3D%20ptr.wrapping_sub(step)%3B%0A%7D%0A%7D&amp;edition=2018">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.set_ptr_value" class="method has-srclink"><div class="rightside"><a class="srclink" href="../src/core/ptr/const_ptr.rs.html#738" title="goto source code">[src]</a></div><a href="#method.set_ptr_value" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.set_ptr_value" class="fnname">set_ptr_value</a>(self, val: <a class="primitive" href="primitive.pointer.html">*const </a><a class="primitive" href="primitive.u8.html">u8</a>) -&gt; <a class="primitive" href="primitive.pointer.html">*const T</a></h4></div><div class="item-info"><div class="stab unstable"><span class="emoji">🔬</span> This is a nightly-only experimental API. (<code>set_ptr_value</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/75091">#75091</a>)</div></div></summary><div class="docblock" xpath="/html[1]/body[1]/section[1]/details[2]/div[1]/details[15]/div[1]" istranslationnode="true" main_mp="Y25yZD4/dHFyOzpia2t3cU9hZGMuLz52f39jZTRBLi9TRFR+VFFWelZATFRB"><p class="translate-text">将指针值设置为 ptr。</p><p>Sets the pointer value to <code>ptr</code>.</p>
<p class="translate-text">如果 self 是指向未调整类型的（胖）指针，则此操作只会影响指针部分，而对于指向已调整类型的（瘦）指针，这与简单赋值具有相同的效果。</p><p>In case <code>self</code> is a (fat) pointer to an unsized type, this operation
will only affect the pointer part, whereas for (thin) pointers to
sized types, this has the same effect as a simple assignment.</p>
<p class="translate-text">结果指针将具有 val 的出处，即，对于胖指针，此操作在语义上与使用 val 的数据指针值但 self 的元数据创建一个新的胖指针相同。</p><p>The resulting pointer will have provenance of <code>val</code>, i.e., for a fat
pointer, this operation is semantically the same as creating a new
fat pointer with the data pointer value of <code>val</code> but the metadata of
<code>self</code>.</p>
<h1 id="examples-10" class="section-header"><a href="#examples-10">Examples</a></h1>
<p class="translate-text">此函数主要用于允许对潜在的胖指针进行字节指针运算：</p><p>This function is primarily useful for allowing byte-wise pointer
arithmetic on potentially fat pointers:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attribute">#![<span class="ident">feature</span>(<span class="ident">set_ptr_value</span>)]</span>
<span class="kw">let</span> <span class="ident">arr</span>: [<span class="ident">i32</span>; <span class="number">3</span>] <span class="op">=</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">ptr</span> <span class="op">=</span> <span class="ident">arr</span>.<span class="ident">as_ptr</span>() <span class="kw">as</span> <span class="kw-2">*</span><span class="kw">const</span> <span class="kw">dyn</span> <span class="ident">Debug</span>;
<span class="kw">let</span> <span class="ident">thin</span> <span class="op">=</span> <span class="ident">ptr</span> <span class="kw">as</span> <span class="kw-2">*</span><span class="kw">const</span> <span class="ident">u8</span>;
<span class="kw">unsafe</span> {
    <span class="ident">ptr</span> <span class="op">=</span> <span class="ident">ptr</span>.<span class="ident">set_ptr_value</span>(<span class="ident">thin</span>.<span class="ident">add</span>(<span class="number">8</span>));
    <span class="macro">println!</span>(<span class="string">&quot;{:?}&quot;</span>, <span class="kw-2">&amp;</span><span class="kw-2">*</span><span class="ident">ptr</span>); <span class="comment">// will print &quot;3&quot;</span>
}</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(set_ptr_value)%5D%0Afn%20main()%20%7B%0Ause%20core%3A%3Afmt%3A%3ADebug%3B%0Alet%20arr%3A%20%5Bi32%3B%203%5D%20%3D%20%5B1%2C%202%2C%203%5D%3B%0Alet%20mut%20ptr%20%3D%20arr.as_ptr()%20as%20*const%20dyn%20Debug%3B%0Alet%20thin%20%3D%20ptr%20as%20*const%20u8%3B%0Aunsafe%20%7B%0A%20%20%20%20ptr%20%3D%20ptr.set_ptr_value(thin.add(8))%3B%0Aassert_eq!(*(ptr%20as%20*const%20i32)%2C%203)%3B%0A%20%20%20%20println!(%22%7B%3A%3F%7D%22%2C%20%26*ptr)%3B%20%2F%2F%20will%20print%20%223%22%0A%7D%0A%7D&amp;version=nightly&amp;edition=2018">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.read" class="method has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.26.0, const unstable">1.26.0 (const: <a href="https://github.com/rust-lang/rust/issues/80377" title="Tracking issue for const_ptr_read">unstable</a>)</span><a class="srclink" href="../src/core/ptr/const_ptr.rs.html#757-759" title="goto source code">[src]</a></div><a href="#method.read" class="anchor"></a><h4 class="code-header">pub unsafe fn <a href="#method.read" class="fnname">read</a>(self) -&gt; T</h4></div></summary><div class="docblock" xpath="/html[1]/body[1]/section[1]/details[2]/div[1]/details[16]/div[1]" istranslationnode="true" main_mp="Y25yZD4/dHFyOzpia2t3cU9hZGMuLz52f39jZTRBLi9SREFF"><p class="translate-text">从 self 读取值而不移动它。 这使 self 中的内存保持不变。</p><p>Reads the value from <code>self</code> without moving it. This leaves the
memory in <code>self</code> unchanged.</p>
<p class="translate-text">有关安全问题和示例，请参见 ptr::read。</p><p>See <a href="ptr/fn.read.html"><code>ptr::read</code></a> for safety concerns and examples.</p>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.read_volatile" class="method has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.26.0">1.26.0</span><a class="srclink" href="../src/core/ptr/const_ptr.rs.html#777-779" title="goto source code">[src]</a></div><a href="#method.read_volatile" class="anchor"></a><h4 class="code-header">pub unsafe fn <a href="#method.read_volatile" class="fnname">read_volatile</a>(self) -&gt; T</h4></div></summary><div class="docblock" xpath="/html[1]/body[1]/section[1]/details[2]/div[1]/details[17]/div[1]" istranslationnode="true" main_mp="Y25yZD4/dHFyOzpia2t3cU9hZGMuLz52f39jZTRBLi9SREFFe1NLSUFVSU1B"><p class="translate-text">对 self 的值执行易失性读取而不移动它。 这使 self 中的内存保持不变。</p><p>Performs a volatile read of the value from <code>self</code> without moving it. This
leaves the memory in <code>self</code> unchanged.</p>
<p class="translate-text">易失性操作旨在作用于 I/O 内存，并保证编译器不会在其他易失性操作中忽略或重新排序。</p><p>Volatile operations are intended to act on I/O memory, and are guaranteed
to not be elided or reordered by the compiler across other volatile
operations.</p>
<p class="translate-text">有关安全问题和示例，请参见 ptr::read_volatile。</p><p>See <a href="ptr/fn.read_volatile.html"><code>ptr::read_volatile</code></a> for safety concerns and examples.</p>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.read_unaligned" class="method has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.26.0, const unstable">1.26.0 (const: <a href="https://github.com/rust-lang/rust/issues/80377" title="Tracking issue for const_ptr_read">unstable</a>)</span><a class="srclink" href="../src/core/ptr/const_ptr.rs.html#796-798" title="goto source code">[src]</a></div><a href="#method.read_unaligned" class="anchor"></a><h4 class="code-header">pub unsafe fn <a href="#method.read_unaligned" class="fnname">read_unaligned</a>(self) -&gt; T</h4></div></summary><div class="docblock" xpath="/html[1]/body[1]/section[1]/details[2]/div[1]/details[18]/div[1]" istranslationnode="true" main_mp="Y25yZD4/dHFyOzpia2t3cU9hZGMuLz52f39jZTRBLi9SREFFe1BKRExIR09BQQ=="><p class="translate-text">从 self 读取值而不移动它。 这使 self 中的内存保持不变。</p><p>Reads the value from <code>self</code> without moving it. This leaves the
memory in <code>self</code> unchanged.</p>
<p class="translate-text">与读取不同，指针可能未对齐。</p><p>Unlike <code>read</code>, the pointer may be unaligned.</p>
<p class="translate-text">有关安全问题和示例，请参阅 ptr::read_unaligned。</p><p>See <a href="ptr/fn.read_unaligned.html"><code>ptr::read_unaligned</code></a> for safety concerns and examples.</p>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.copy_to" class="method has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.26.0, const unstable">1.26.0 (const: <a href="https://github.com/rust-lang/rust/issues/80697" title="Tracking issue for const_intrinsic_copy">unstable</a>)</span><a class="srclink" href="../src/core/ptr/const_ptr.rs.html#815-817" title="goto source code">[src]</a></div><a href="#method.copy_to" class="anchor"></a><h4 class="code-header">pub unsafe fn <a href="#method.copy_to" class="fnname">copy_to</a>(self, dest: <a class="primitive" href="primitive.pointer.html">*mut T</a>, count: <a class="primitive" href="primitive.usize.html">usize</a>)</h4></div></summary><div class="docblock" xpath="/html[1]/body[1]/section[1]/details[2]/div[1]/details[19]/div[1]" istranslationnode="true" main_mp="Y25yZD4/dHFyOzpia2t3cU9hZGMuLz52f39jZTRBLi9DTlBYe1FL"><p class="translate-text">将 count * size_of<t> 个字节从 self 复制到 dest。 源和目标可能重叠。</t></p><p>Copies <code>count * size_of&lt;T&gt;</code> bytes from <code>self</code> to <code>dest</code>. The source
and destination may overlap.</p>
<p class="translate-text">注意：这与 ptr::copy 具有相同的参数顺序。</p><p>NOTE: this has the <em>same</em> argument order as <a href="ptr/fn.copy.html"><code>ptr::copy</code></a>.</p>
<p class="translate-text">有关安全问题和示例，请参见 ptr::copy。</p><p>See <a href="ptr/fn.copy.html"><code>ptr::copy</code></a> for safety concerns and examples.</p>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.copy_to_nonoverlapping" class="method has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.26.0, const unstable">1.26.0 (const: <a href="https://github.com/rust-lang/rust/issues/80697" title="Tracking issue for const_intrinsic_copy">unstable</a>)</span><a class="srclink" href="../src/core/ptr/const_ptr.rs.html#834-836" title="goto source code">[src]</a></div><a href="#method.copy_to_nonoverlapping" class="anchor"></a><h4 class="code-header">pub unsafe fn <a href="#method.copy_to_nonoverlapping" class="fnname">copy_to_nonoverlapping</a>(self, dest: <a class="primitive" href="primitive.pointer.html">*mut T</a>, count: <a class="primitive" href="primitive.usize.html">usize</a>)</h4></div></summary><div class="docblock" xpath="/html[1]/body[1]/section[1]/details[2]/div[1]/details[20]/div[1]" istranslationnode="true" main_mp="Y25yZD4/dHFyOzpia2t3cU9hZGMuLz52f39jZTRBLi9DTlBYe1FLek5OTk5SQFZJUUFAWFpS"><p class="translate-text">将 count * size_of<t> 个字节从 self 复制到 dest。 源和目标不能重叠。</t></p><p>Copies <code>count * size_of&lt;T&gt;</code> bytes from <code>self</code> to <code>dest</code>. The source
and destination may <em>not</em> overlap.</p>
<p class="translate-text">注意：这与 ptr::copy_nonoverlapping 具有相同的参数顺序。</p><p>NOTE: this has the <em>same</em> argument order as <a href="ptr/fn.copy_nonoverlapping.html"><code>ptr::copy_nonoverlapping</code></a>.</p>
<p class="translate-text">有关安全问题和示例，请参阅 ptr::copy_nonoverlapping。</p><p>See <a href="ptr/fn.copy_nonoverlapping.html"><code>ptr::copy_nonoverlapping</code></a> for safety concerns and examples.</p>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.align_offset" class="method has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.36.0">1.36.0</span><a class="srclink" href="../src/core/ptr/const_ptr.rs.html#882-884" title="goto source code">[src]</a></div><a href="#method.align_offset" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.align_offset" class="fnname">align_offset</a>(self, align: <a class="primitive" href="primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="primitive.usize.html">usize</a></h4></div></summary><div class="docblock" xpath="/html[1]/body[1]/section[1]/details[2]/div[1]/details[21]/div[1]" istranslationnode="true" main_mp="Y25yZD4/dHFyOzpia2t3cU9hZGMuLz52f39jZTRBLi9BTUlGSnpLQ0ZSRVU="><p class="translate-text">计算需要应用于指针以使其对齐对齐的偏移量。</p><p>Computes the offset that needs to be applied to the pointer in order to make it aligned to
<code>align</code>.</p>
<p class="translate-text">如果无法对齐指针，则实现返回 usize::MAX。 允许实现总是返回 usize::MAX。 只有你的算法的性能取决于在这里获得一个可用的偏移量，而不是它的正确性。</p><p>If it is not possible to align the pointer, the implementation returns
<code>usize::MAX</code>. It is permissible for the implementation to <em>always</em>
return <code>usize::MAX</code>. Only your algorithm’s performance can depend
on getting a usable offset here, not its correctness.</p>
<p class="translate-text">偏移量以 T 个元素的数量表示，而不是字节数。 返回的值可以与 wrapping_add 方法一起使用。</p><p>The offset is expressed in number of <code>T</code> elements, and not bytes. The value returned can be
used with the <code>wrapping_add</code> method.</p>
<p class="translate-text">无法保证偏移指针不会溢出或超出指针指向的分配。 由调用者确保返回的偏移量在除对齐之外的所有方面都是正确的。</p><p>There are no guarantees whatsoever that offsetting the pointer will not overflow or go
beyond the allocation that the pointer points into. It is up to the caller to ensure that
the returned offset is correct in all terms other than alignment.</p>
<h1 id="panics-1" class="section-header"><a href="#panics-1">Panics</a></h1>
<p class="translate-text">如果 align 不是 2 的幂，则函数会出现panic。</p><p>The function panics if <code>align</code> is not a power-of-two.</p>
<h1 id="examples-11" class="section-header"><a href="#examples-11">Examples</a></h1>
<p class="translate-text">以 u16 访问相邻的 u8</p><p>Accessing adjacent <code>u8</code> as <code>u16</code></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> [<span class="number">5u8</span>, <span class="number">6u8</span>, <span class="number">7u8</span>, <span class="number">8u8</span>, <span class="number">9u8</span>];
<span class="kw">let</span> <span class="ident">ptr</span> <span class="op">=</span> <span class="ident">x</span>.<span class="ident">as_ptr</span>().<span class="ident">add</span>(<span class="ident">n</span>) <span class="kw">as</span> <span class="kw-2">*</span><span class="kw">const</span> <span class="ident">u8</span>;
<span class="kw">let</span> <span class="ident">offset</span> <span class="op">=</span> <span class="ident">ptr</span>.<span class="ident">align_offset</span>(<span class="ident">align_of</span>::<span class="op">&lt;</span><span class="ident">u16</span><span class="op">&gt;</span>());
<span class="kw">if</span> <span class="ident">offset</span> <span class="op">&lt;</span> <span class="ident">x</span>.<span class="ident">len</span>() <span class="op">-</span> <span class="ident">n</span> <span class="op">-</span> <span class="number">1</span> {
    <span class="kw">let</span> <span class="ident">u16_ptr</span> <span class="op">=</span> <span class="ident">ptr</span>.<span class="ident">add</span>(<span class="ident">offset</span>) <span class="kw">as</span> <span class="kw-2">*</span><span class="kw">const</span> <span class="ident">u16</span>;
    <span class="macro">assert_ne!</span>(<span class="kw-2">*</span><span class="ident">u16_ptr</span>, <span class="number">500</span>);
} <span class="kw">else</span> {
    <span class="comment">// while the pointer can be aligned via `offset`, it would point</span>
    <span class="comment">// outside the allocation</span>
}</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Afn%20foo(n%3A%20usize)%20%7B%0Ause%20std%3A%3Amem%3A%3Aalign_of%3B%0Aunsafe%20%7B%0Alet%20x%20%3D%20%5B5u8%2C%206u8%2C%207u8%2C%208u8%2C%209u8%5D%3B%0Alet%20ptr%20%3D%20x.as_ptr().add(n)%20as%20*const%20u8%3B%0Alet%20offset%20%3D%20ptr.align_offset(align_of%3A%3A%3Cu16%3E())%3B%0Aif%20offset%20%3C%20x.len()%20-%20n%20-%201%20%7B%0A%20%20%20%20let%20u16_ptr%20%3D%20ptr.add(offset)%20as%20*const%20u16%3B%0A%20%20%20%20assert_ne!(*u16_ptr%2C%20500)%3B%0A%7D%20else%20%7B%0A%20%20%20%20%2F%2F%20while%20the%20pointer%20can%20be%20aligned%20via%20%60offset%60%2C%20it%20would%20point%0A%20%20%20%20%2F%2F%20outside%20the%20allocation%0A%7D%0A%7D%20%7D%0A%7D&amp;edition=2018">Run</a></div>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open=""><summary><div id="impl-1" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/ptr/mut_ptr.rs.html#7-1154" title="goto source code">[src]</a></div><a href="#impl-1" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="primitive" href="primitive.pointer.html">*mut T</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,&nbsp;</span></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.is_null-1" class="method has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.0.0, const unstable">1.0.0 (const: <a href="https://github.com/rust-lang/rust/issues/74939" title="Tracking issue for const_ptr_is_null">unstable</a>)</span><a class="srclink" href="../src/core/ptr/mut_ptr.rs.html#36" title="goto source code">[src]</a></div><a href="#method.is_null-1" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.is_null-1" class="fnname">is_null</a>(self) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></div></summary><div class="docblock" xpath="/html[1]/body[1]/section[1]/details[3]/div[1]/details[1]/div[1]" istranslationnode="true" main_mp="Y25yZD4/dHFyOzpscXFbdWRjKis+eGFhMEUqK31mS3tVTUw="><p class="translate-text">如果指针为空，则返回 true。</p><p>Returns <code>true</code> if the pointer is null.</p>
<p class="translate-text">请注意，未调整大小的类型有许多可能的空指针，因为只考虑原始数据指针，而不考虑它们的长度、vtable 等。因此，两个为空的指针可能仍然不能相互比较。</p><p>Note that unsized types have many possible null pointers, as only the
raw data pointer is considered, not their length, vtable, etc.
Therefore, two pointers that are null may still not compare equal to
each other.</p>
<h2 id="behavior-during-const-evaluation-1" class="section-header"><a href="#behavior-during-const-evaluation-1">Behavior during const evaluation</a></h2>
<p class="translate-text">在 const 评估期间使用此函数时，对于在运行时结果为空的指针，它可能会返回 false。 具体来说，当指向某个内存的指针以这样的方式偏移超出其边界以致结果指针为空时，该函数仍将返回 false。 CTFE 无法知道该内存的绝对位置，因此我们无法判断指针是否为空。</p><p>When this function is used during const evaluation, it may return <code>false</code> for pointers
that turn out to be null at runtime. Specifically, when a pointer to some memory
is offset beyond its bounds in such a way that the resulting pointer is null,
the function will still return <code>false</code>. There is no way for CTFE to know
the absolute position of that memory, so we cannot tell if the pointer is
null or not.</p>
<h1 id="examples-12" class="section-header"><a href="#examples-12">Examples</a></h1>
<p class="translate-text">基本用法：</p><p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">s</span> <span class="op">=</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];
<span class="kw">let</span> <span class="ident">ptr</span>: <span class="kw-2">*</span><span class="kw-2">mut</span> <span class="ident">u32</span> <span class="op">=</span> <span class="ident">s</span>.<span class="ident">as_mut_ptr</span>();
<span class="macro">assert!</span>(<span class="op">!</span><span class="ident">ptr</span>.<span class="ident">is_null</span>());</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20mut%20s%20%3D%20%5B1%2C%202%2C%203%5D%3B%0Alet%20ptr%3A%20*mut%20u32%20%3D%20s.as_mut_ptr()%3B%0Aassert!(!ptr.is_null())%3B%0A%7D&amp;edition=2018">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.cast-1" class="method has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.38.0, const since 1.38.0">1.38.0 (const: 1.38.0)</span><a class="srclink" href="../src/core/ptr/mut_ptr.rs.html#46" title="goto source code">[src]</a></div><a href="#method.cast-1" class="anchor"></a><h4 class="code-header">pub const fn <a href="#method.cast-1" class="fnname">cast</a>&lt;U&gt;(self) -&gt; <a class="primitive" href="primitive.pointer.html">*mut U</a></h4></div></summary><div class="docblock" xpath="/html[1]/body[1]/section[1]/details[3]/div[1]/details[2]/div[1]" istranslationnode="true" main_mp="Y25yZD4/dHFyOzpscXFbdWRjKis+eGFhMEUqK3d0Z2E="><p class="translate-text">转换为另一种类型的指针。</p><p>Casts to a pointer of another type.</p>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.to_raw_parts-1" class="method has-srclink"><div class="rightside"><a class="srclink" href="../src/core/ptr/mut_ptr.rs.html#56" title="goto source code">[src]</a></div><a href="#method.to_raw_parts-1" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.to_raw_parts-1" class="fnname">to_raw_parts</a>(self) -&gt; <a class="primitive" href="primitive.tuple.html">(</a><a class="primitive" href="primitive.pointer.html">*mut </a><a class="primitive" href="primitive.unit.html">()</a>, &lt;T as <a class="trait" href="ptr/trait.Pointee.html" title="trait std::ptr::Pointee">Pointee</a>&gt;::<a class="type" href="ptr/trait.Pointee.html#associatedtype.Metadata" title="type std::ptr::Pointee::Metadata">Metadata</a><a class="primitive" href="primitive.tuple.html">)</a></h4></div><div class="item-info"><div class="stab unstable"><span class="emoji">🔬</span> This is a nightly-only experimental API. (<code>ptr_metadata</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/81513">#81513</a>)</div></div></summary><div class="docblock" xpath="/html[1]/body[1]/section[1]/details[3]/div[1]/details[3]/div[1]" istranslationnode="true" main_mp="Y25yZD4/dHFyOzpscXFbdWRjKis+eGFhMEUqK2B6S2dBVn9RRVdQVg=="><p class="translate-text">将（可能是宽的）指针分解为其地址和元数据组件。</p><p>Decompose a (possibly wide) pointer into its address and metadata components.</p>
<p class="translate-text">稍后可以使用 from_raw_parts_mut 重建指针。</p><p>The pointer can be later reconstructed with <a href="ptr/fn.from_raw_parts_mut.html" title="from_raw_parts_mut"><code>from_raw_parts_mut</code></a>.</p>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.as_ref-1" class="method has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.9.0">1.9.0</span><a class="srclink" href="../src/core/ptr/mut_ptr.rs.html#121" title="goto source code">[src]</a></div><a href="#method.as_ref-1" class="anchor"></a><h4 class="code-header">pub unsafe fn <a href="#method.as_ref-1" class="fnname">as_ref</a>&lt;'a&gt;(self) -&gt; <a class="enum" href="option/enum.Option.html" title="enum std::option::Option">Option</a>&lt;<a class="primitive" href="primitive.reference.html">&amp;'a </a>T&gt;</h4></div></summary><div class="docblock" xpath="/html[1]/body[1]/section[1]/details[3]/div[1]/details[4]/div[1]" istranslationnode="true" main_mp="Y25yZD4/dHFyOzpscXFbdWRjKis+eGFhMEUqK3VmS2dFRw=="><p class="translate-text">如果指针为 null，则返回 None，否则返回对 Some 中包装的值的共享引用。 如果该值可能未初始化，则必须改用 as_uninit_ref。</p><p>Returns <code>None</code> if the pointer is null, or else returns a shared reference to
the value wrapped in <code>Some</code>. If the value may be uninitialized, <a href="#method.as_uninit_ref-1"><code>as_uninit_ref</code></a>
must be used instead.</p>
<p class="translate-text">对于可变对应物，请参见 as_mut。</p><p>For the mutable counterpart see <a href="#method.as_mut"><code>as_mut</code></a>.</p>
<h1 id="safety-9" class="section-header"><a href="#safety-9">Safety</a></h1>
<p class="translate-text">调用此方法时，您必须确保指针为空或以下所有条件都为真：</p><p>When calling this method, you have to ensure that <em>either</em> the pointer is null <em>or</em>
all of the following is true:</p>
<ul>
<li class="translate-text">指针必须正确对齐。</li><li>
<p>The pointer must be properly aligned.</p>
</li>
<li class="translate-text">在模块文档中定义的意义上，它必须是“可解引用的”。</li><li>
<p>It must be “dereferencable” in the sense defined in <a href="ptr/index.html#safety">the module documentation</a>.</p>
</li>
<li class="translate-text">指针必须指向 T 的初始化实例。</li><li>
<p>The pointer must point to an initialized instance of <code>T</code>.</p>
</li>
<li class="translate-text">您必须强制执行 Rust 的别名规则，因为返回的生命周期 'a 是任意选择的，不一定反映数据的实际生命周期。 特别是，在此生命周期内，指针指向的内存不得发生可变（UnsafeCell 内除外）。</li><li>
<p>You must enforce Rust’s aliasing rules, since the returned lifetime <code>'a</code> is
arbitrarily chosen and does not necessarily reflect the actual lifetime of the data.
In particular, for the duration of this lifetime, the memory the pointer points to must
not get mutated (except inside <code>UnsafeCell</code>).</p>
</li>
</ul>
<p class="translate-text">即使此方法的结果未使用，这也适用！ （关于被初始化的部分尚未完全确定，但在确定之前，唯一安全的方法是确保它们确实被初始化。）</p><p>This applies even if the result of this method is unused!
(The part about being initialized is not yet fully decided, but until
it is, the only safe approach is to ensure that they are indeed initialized.)</p>
<h1 id="examples-13" class="section-header"><a href="#examples-13">Examples</a></h1>
<p class="translate-text">基本用法：</p><p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">ptr</span>: <span class="kw-2">*</span><span class="kw-2">mut</span> <span class="ident">u8</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="number">10u8</span> <span class="kw">as</span> <span class="kw-2">*</span><span class="kw-2">mut</span> <span class="ident">u8</span>;

<span class="kw">unsafe</span> {
    <span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>(<span class="ident">val_back</span>) <span class="op">=</span> <span class="ident">ptr</span>.<span class="ident">as_ref</span>() {
        <span class="macro">println!</span>(<span class="string">&quot;We got back the value: {}!&quot;</span>, <span class="ident">val_back</span>);
    }
}</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20ptr%3A%20*mut%20u8%20%3D%20%26mut%2010u8%20as%20*mut%20u8%3B%0A%0Aunsafe%20%7B%0A%20%20%20%20if%20let%20Some(val_back)%20%3D%20ptr.as_ref()%20%7B%0A%20%20%20%20%20%20%20%20println!(%22We%20got%20back%20the%20value%3A%20%7B%7D!%22%2C%20val_back)%3B%0A%20%20%20%20%7D%0A%7D%0A%7D&amp;edition=2018">Run</a></div>
<h1 id="null-unchecked-version-1" class="section-header"><a href="#null-unchecked-version-1">Null-unchecked version</a></h1>
<p class="translate-text">如果您确定指针永远不会为空并且正在寻找某种返回 &T 而不是 Option<&T> 的 as_ref_unchecked，请知道您可以直接取消引用指针。</p><p>If you are sure the pointer can never be null and are looking for some kind of
<code>as_ref_unchecked</code> that returns the <code>&amp;T</code> instead of <code>Option&lt;&amp;T&gt;</code>, know that you can
dereference the pointer directly.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">ptr</span>: <span class="kw-2">*</span><span class="kw-2">mut</span> <span class="ident">u8</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="number">10u8</span> <span class="kw">as</span> <span class="kw-2">*</span><span class="kw-2">mut</span> <span class="ident">u8</span>;

<span class="kw">unsafe</span> {
    <span class="kw">let</span> <span class="ident">val_back</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="kw-2">*</span><span class="ident">ptr</span>;
    <span class="macro">println!</span>(<span class="string">&quot;We got back the value: {}!&quot;</span>, <span class="ident">val_back</span>);
}</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20ptr%3A%20*mut%20u8%20%3D%20%26mut%2010u8%20as%20*mut%20u8%3B%0A%0Aunsafe%20%7B%0A%20%20%20%20let%20val_back%20%3D%20%26*ptr%3B%0A%20%20%20%20println!(%22We%20got%20back%20the%20value%3A%20%7B%7D!%22%2C%20val_back)%3B%0A%7D%0A%7D&amp;edition=2018">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.as_uninit_ref-1" class="method has-srclink"><div class="rightside"><a class="srclink" href="../src/core/ptr/mut_ptr.rs.html#171-173" title="goto source code">[src]</a></div><a href="#method.as_uninit_ref-1" class="anchor"></a><h4 class="code-header">pub unsafe fn <a href="#method.as_uninit_ref-1" class="fnname">as_uninit_ref</a>&lt;'a&gt;(self) -&gt; <a class="enum" href="option/enum.Option.html" title="enum std::option::Option">Option</a>&lt;&amp;'a <a class="union" href="mem/union.MaybeUninit.html" title="union std::mem::MaybeUninit">MaybeUninit</a>&lt;T&gt;&gt;</h4></div><div class="item-info"><div class="stab unstable"><span class="emoji">🔬</span> This is a nightly-only experimental API. (<code>ptr_as_uninit</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/75402">#75402</a>)</div></div></summary><div class="docblock" xpath="/html[1]/body[1]/section[1]/details[3]/div[1]/details[5]/div[1]" istranslationnode="true" main_mp="Y25yZD4/dHFyOzpscXFbdWRjKis+eGFhMEUqK3VmS2BOSE5IUHpWQEY="><p class="translate-text">如果指针为 null，则返回 None，否则返回对 Some 中包装的值的共享引用。 与 as_ref 相比，这不需要初始化值。</p><p>Returns <code>None</code> if the pointer is null, or else returns a shared reference to
the value wrapped in <code>Some</code>. In contrast to <a href="#method.as_ref-1"><code>as_ref</code></a>, this does not require
that the value has to be initialized.</p>
<p class="translate-text">对于可变对应物，请参见 as_uninit_mut。</p><p>For the mutable counterpart see <a href="#method.as_uninit_mut"><code>as_uninit_mut</code></a>.</p>
<h1 id="safety-10" class="section-header"><a href="#safety-10">Safety</a></h1>
<p class="translate-text">调用此方法时，您必须确保指针为空或以下所有条件都为真：</p><p>When calling this method, you have to ensure that <em>either</em> the pointer is null <em>or</em>
all of the following is true:</p>
<ul>
<li class="translate-text">指针必须正确对齐。</li><li>
<p>The pointer must be properly aligned.</p>
</li>
<li class="translate-text">在模块文档中定义的意义上，它必须是“可解引用的”。</li><li>
<p>It must be “dereferencable” in the sense defined in <a href="ptr/index.html#safety">the module documentation</a>.</p>
</li>
<li class="translate-text">您必须强制执行 Rust 的别名规则，因为返回的生命周期 'a 是任意选择的，不一定反映数据的实际生命周期。 特别是，在此生命周期内，指针指向的内存不得发生可变（UnsafeCell 内除外）。</li><li>
<p>You must enforce Rust’s aliasing rules, since the returned lifetime <code>'a</code> is
arbitrarily chosen and does not necessarily reflect the actual lifetime of the data.
In particular, for the duration of this lifetime, the memory the pointer points to must
not get mutated (except inside <code>UnsafeCell</code>).</p>
</li>
</ul>
<p class="translate-text">即使此方法的结果未使用，这也适用！</p><p>This applies even if the result of this method is unused!</p>
<h1 id="examples-14" class="section-header"><a href="#examples-14">Examples</a></h1>
<p class="translate-text">基本用法：</p><p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attribute">#![<span class="ident">feature</span>(<span class="ident">ptr_as_uninit</span>)]</span>

<span class="kw">let</span> <span class="ident">ptr</span>: <span class="kw-2">*</span><span class="kw-2">mut</span> <span class="ident">u8</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="number">10u8</span> <span class="kw">as</span> <span class="kw-2">*</span><span class="kw-2">mut</span> <span class="ident">u8</span>;

<span class="kw">unsafe</span> {
    <span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>(<span class="ident">val_back</span>) <span class="op">=</span> <span class="ident">ptr</span>.<span class="ident">as_uninit_ref</span>() {
        <span class="macro">println!</span>(<span class="string">&quot;We got back the value: {}!&quot;</span>, <span class="ident">val_back</span>.<span class="ident">assume_init</span>());
    }
}</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(ptr_as_uninit)%5D%0A%0Afn%20main()%20%7B%0Alet%20ptr%3A%20*mut%20u8%20%3D%20%26mut%2010u8%20as%20*mut%20u8%3B%0A%0Aunsafe%20%7B%0A%20%20%20%20if%20let%20Some(val_back)%20%3D%20ptr.as_uninit_ref()%20%7B%0A%20%20%20%20%20%20%20%20println!(%22We%20got%20back%20the%20value%3A%20%7B%7D!%22%2C%20val_back.assume_init())%3B%0A%20%20%20%20%7D%0A%7D%0A%7D&amp;version=nightly&amp;edition=2018">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.offset-1" class="method has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.0.0, const unstable">1.0.0 (const: <a href="https://github.com/rust-lang/rust/issues/71499" title="Tracking issue for const_ptr_offset">unstable</a>)</span><a class="srclink" href="../src/core/ptr/mut_ptr.rs.html#235-237" title="goto source code">[src]</a></div><a href="#method.offset-1" class="anchor"></a><h4 class="code-header">pub unsafe fn <a href="#method.offset-1" class="fnname">offset</a>(self, count: <a class="primitive" href="primitive.isize.html">isize</a>) -&gt; <a class="primitive" href="primitive.pointer.html">*mut T</a></h4></div></summary><div class="docblock" xpath="/html[1]/body[1]/section[1]/details[3]/div[1]/details[6]/div[1]" istranslationnode="true" main_mp="Y25yZD4/dHFyOzpscXFbdWRjKis+eGFhMEUqK3tzcmZFVQ=="><p class="translate-text">计算与指针的偏移量。</p><p>Calculates the offset from a pointer.</p>
<p class="translate-text">计数以 T 为单位； 例如，计数 3 表示 3 * size_of::<t>() 字节的指针偏移量。</t></p><p><code>count</code> is in units of T; e.g., a <code>count</code> of 3 represents a pointer
offset of <code>3 * size_of::&lt;T&gt;()</code> bytes.</p>
<h1 id="safety-11" class="section-header"><a href="#safety-11">Safety</a></h1>
<p class="translate-text">如果违反以下任何条件，则结果为未定义行为：</p><p>If any of the following conditions are violated, the result is Undefined
Behavior:</p>
<ul>
<li class="translate-text">起始指针和结果指针都必须在边界内或超过同一分配对象的末尾一个字节。</li><li>
<p>Both the starting and resulting pointer must be either in bounds or one
byte past the end of the same <a href="ptr/index.html#allocated-object">allocated object</a>.</p>
</li>
<li class="translate-text">计算的偏移量（以字节为单位）不能溢出 isize。</li><li>
<p>The computed offset, <strong>in bytes</strong>, cannot overflow an <code>isize</code>.</p>
</li>
<li class="translate-text">范围内的偏移量不能依赖于“环绕”地址空间。 也就是说，以字节为单位的无限精度和必须适合使用大小。</li><li>
<p>The offset being in bounds cannot rely on “wrapping around” the address
space. That is, the infinite-precision sum, <strong>in bytes</strong> must fit in a usize.</p>
</li>
</ul>
<p class="translate-text">编译器和标准库通常会尝试确保分配永远不会达到需要考虑偏移量的大小。 例如， Vec 和 Box 确保它们分配的字节数永远不会超过 isize::MAX 字节，因此 vec.as_ptr().add(vec.len()) 总是安全的。</p><p>The compiler and standard library generally tries to ensure allocations
never reach a size where an offset is a concern. For instance, <code>Vec</code>
and <code>Box</code> ensure they never allocate more than <code>isize::MAX</code> bytes, so
<code>vec.as_ptr().add(vec.len())</code> is always safe.</p>
<p class="translate-text">大多数平台根本无法构建这样的分配。 例如，由于页表限制或地址空间分割，没有已知的 64 位平台可以为 263 字节的请求提供服务。 但是，一些 32 位和 16 位平台可能会成功地为超过 isize::MAX 字节的请求提供物理地址扩展等内容。 因此，直接从分配器或内存映射文件获取的内存可能太大而无法使用此函数处理。</p><p>Most platforms fundamentally can’t even construct such an allocation.
For instance, no known 64-bit platform can ever serve a request
for 2<sup>63</sup> bytes due to page-table limitations or splitting the address space.
However, some 32-bit and 16-bit platforms may successfully serve a request for
more than <code>isize::MAX</code> bytes with things like Physical Address
Extension. As such, memory acquired directly from allocators or memory
mapped files <em>may</em> be too large to handle with this function.</p>
<p class="translate-text">如果这些约束难以满足，请考虑使用 wrapping_offset。 这种方法的唯一优点是它可以实现更积极的编译器优化。</p><p>Consider using <a href="#method.wrapping_offset"><code>wrapping_offset</code></a> instead if these constraints are
difficult to satisfy. The only advantage of this method is that it
enables more aggressive compiler optimizations.</p>
<h1 id="examples-15" class="section-header"><a href="#examples-15">Examples</a></h1>
<p class="translate-text">基本用法：</p><p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">s</span> <span class="op">=</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];
<span class="kw">let</span> <span class="ident">ptr</span>: <span class="kw-2">*</span><span class="kw-2">mut</span> <span class="ident">u32</span> <span class="op">=</span> <span class="ident">s</span>.<span class="ident">as_mut_ptr</span>();

<span class="kw">unsafe</span> {
    <span class="macro">println!</span>(<span class="string">&quot;{}&quot;</span>, <span class="kw-2">*</span><span class="ident">ptr</span>.<span class="ident">offset</span>(<span class="number">1</span>));
    <span class="macro">println!</span>(<span class="string">&quot;{}&quot;</span>, <span class="kw-2">*</span><span class="ident">ptr</span>.<span class="ident">offset</span>(<span class="number">2</span>));
}</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20mut%20s%20%3D%20%5B1%2C%202%2C%203%5D%3B%0Alet%20ptr%3A%20*mut%20u32%20%3D%20s.as_mut_ptr()%3B%0A%0Aunsafe%20%7B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20*ptr.offset(1))%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20*ptr.offset(2))%3B%0A%7D%0A%7D&amp;edition=2018">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.wrapping_offset-1" class="method has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.16.0, const unstable">1.16.0 (const: <a href="https://github.com/rust-lang/rust/issues/71499" title="Tracking issue for const_ptr_offset">unstable</a>)</span><a class="srclink" href="../src/core/ptr/mut_ptr.rs.html#298-300" title="goto source code">[src]</a></div><a href="#method.wrapping_offset-1" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.wrapping_offset-1" class="fnname">wrapping_offset</a>(self, count: <a class="primitive" href="primitive.isize.html">isize</a>) -&gt; <a class="primitive" href="primitive.pointer.html">*mut T</a></h4></div></summary><div class="docblock" xpath="/html[1]/body[1]/section[1]/details[3]/div[1]/details[7]/div[1]" istranslationnode="true" main_mp="Y25yZD4/dHFyOzpscXFbdWRjKis+eGFhMEUqK2NndWVQSE5Ge0pCQ1NEVA=="><p class="translate-text">使用环绕算法计算指针的偏移量。 计数以 T 为单位； 例如，计数 3 表示 3 * size_of::<t>() 字节的指针偏移量。</t></p><p>Calculates the offset from a pointer using wrapping arithmetic.
<code>count</code> is in units of T; e.g., a <code>count</code> of 3 represents a pointer
offset of <code>3 * size_of::&lt;T&gt;()</code> bytes.</p>
<h1 id="safety-12" class="section-header"><a href="#safety-12">Safety</a></h1>
<p class="translate-text">这个操作本身总是安全的，但使用结果指针却不是。</p><p>This operation itself is always safe, but using the resulting pointer is not.</p>
<p class="translate-text">结果指针“记住”了 self 指向的已分配对象； 它不能用于读取或写入其他分配的对象。</p><p>The resulting pointer “remembers” the <a href="ptr/index.html#allocated-object">allocated object</a> that <code>self</code> points to; it must not
be used to read or write other allocated objects.</p>
<p class="translate-text">换句话说，即使我们假设 T 的大小为 1 并且没有溢出， let z = x.wrapping_offset((y as isize) - (x as isize)) 也不会使 z 与 y 相同：z 仍然附加到 对象 x 附加到，并且取消引用它是未定义的行为，除非 x 和 y 指向同一个分配的对象。</p><p>In other words, <code>let z = x.wrapping_offset((y as isize) - (x as isize))</code> does <em>not</em> make <code>z</code>
the same as <code>y</code> even if we assume <code>T</code> has size <code>1</code> and there is no overflow: <code>z</code> is still
attached to the object <code>x</code> is attached to, and dereferencing it is Undefined Behavior unless
<code>x</code> and <code>y</code> point into the same allocated object.</p>
<p class="translate-text">与offset相比，这种方法基本上延迟了停留在同一个分配对象内的要求：offset是立即跨越对象边界时的未定义行为； wrapping_offset 会产生一个指针，但如果指针在其附加到的对象超出范围时被取消引用，它仍会导致未定义行为。 offset 可以更好地优化，因此在性能敏感的代码中更可取。</p><p>Compared to <a href="#method.offset"><code>offset</code></a>, this method basically delays the requirement of staying within the
same allocated object: <a href="#method.offset"><code>offset</code></a> is immediate Undefined Behavior when crossing object
boundaries; <code>wrapping_offset</code> produces a pointer but still leads to Undefined Behavior if a
pointer is dereferenced when it is out-of-bounds of the object it is attached to. <a href="#method.offset"><code>offset</code></a>
can be optimized better and is thus preferable in performance-sensitive code.</p>
<p class="translate-text">延迟检查仅考虑被取消引用的指针的值，而不考虑在计算最终结果期间使用的中间值。 例如，x.wrapping_offset(o).wrapping_offset(o.wrapping_neg()) 总是与 x 相同。 换句话说，允许离开分配的对象，然后再重新进入它。</p><p>The delayed check only considers the value of the pointer that was dereferenced, not the
intermediate values used during the computation of the final result. For example,
<code>x.wrapping_offset(o).wrapping_offset(o.wrapping_neg())</code> is always the same as <code>x</code>. In other
words, leaving the allocated object and then re-entering it later is permitted.</p>
<h1 id="examples-16" class="section-header"><a href="#examples-16">Examples</a></h1>
<p class="translate-text">基本用法：</p><p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Iterate using a raw pointer in increments of two elements</span>
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">data</span> <span class="op">=</span> [<span class="number">1u8</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">ptr</span>: <span class="kw-2">*</span><span class="kw-2">mut</span> <span class="ident">u8</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">as_mut_ptr</span>();
<span class="kw">let</span> <span class="ident">step</span> <span class="op">=</span> <span class="number">2</span>;
<span class="kw">let</span> <span class="ident">end_rounded_up</span> <span class="op">=</span> <span class="ident">ptr</span>.<span class="ident">wrapping_offset</span>(<span class="number">6</span>);

<span class="kw">while</span> <span class="ident">ptr</span> <span class="op">!</span><span class="op">=</span> <span class="ident">end_rounded_up</span> {
    <span class="kw">unsafe</span> {
        <span class="kw-2">*</span><span class="ident">ptr</span> <span class="op">=</span> <span class="number">0</span>;
    }
    <span class="ident">ptr</span> <span class="op">=</span> <span class="ident">ptr</span>.<span class="ident">wrapping_offset</span>(<span class="ident">step</span>);
}
<span class="macro">assert_eq!</span>(<span class="kw-2">&amp;</span><span class="ident">data</span>, <span class="kw-2">&amp;</span>[<span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">0</span>]);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%2F%2F%20Iterate%20using%20a%20raw%20pointer%20in%20increments%20of%20two%20elements%0Afn%20main()%20%7B%0Alet%20mut%20data%20%3D%20%5B1u8%2C%202%2C%203%2C%204%2C%205%5D%3B%0Alet%20mut%20ptr%3A%20*mut%20u8%20%3D%20data.as_mut_ptr()%3B%0Alet%20step%20%3D%202%3B%0Alet%20end_rounded_up%20%3D%20ptr.wrapping_offset(6)%3B%0A%0Awhile%20ptr%20!%3D%20end_rounded_up%20%7B%0A%20%20%20%20unsafe%20%7B%0A%20%20%20%20%20%20%20%20*ptr%20%3D%200%3B%0A%20%20%20%20%7D%0A%20%20%20%20ptr%20%3D%20ptr.wrapping_offset(step)%3B%0A%7D%0Aassert_eq!(%26data%2C%20%26%5B0%2C%202%2C%200%2C%204%2C%200%5D)%3B%0A%7D&amp;edition=2018">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.as_mut" class="method has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.9.0">1.9.0</span><a class="srclink" href="../src/core/ptr/mut_ptr.rs.html#366" title="goto source code">[src]</a></div><a href="#method.as_mut" class="anchor"></a><h4 class="code-header">pub unsafe fn <a href="#method.as_mut" class="fnname">as_mut</a>&lt;'a&gt;(self) -&gt; <a class="enum" href="option/enum.Option.html" title="enum std::option::Option">Option</a>&lt;<a class="primitive" href="primitive.reference.html">&amp;'a mut </a>T&gt;</h4></div></summary><div class="docblock" xpath="/html[1]/body[1]/section[1]/details[3]/div[1]/details[8]/div[1]" istranslationnode="true" main_mp="Y25yZD4/dHFyOzpscXFbdWRjKis+eGFhMEUqK3VmS3hVVQ=="><p class="translate-text">如果指针为 null，则返回 None，否则返回对 Some 中包装的值的唯一引用。 如果该值可能未初始化，则必须改用 as_uninit_mut。</p><p>Returns <code>None</code> if the pointer is null, or else returns a unique reference to
the value wrapped in <code>Some</code>. If the value may be uninitialized, <a href="#method.as_uninit_mut"><code>as_uninit_mut</code></a>
must be used instead.</p>
<p class="translate-text">对于共享副本，请参见 as_ref。</p><p>For the shared counterpart see <a href="#method.as_ref-1"><code>as_ref</code></a>.</p>
<h1 id="safety-13" class="section-header"><a href="#safety-13">Safety</a></h1>
<p class="translate-text">调用此方法时，您必须确保指针为空或以下所有条件都为真：</p><p>When calling this method, you have to ensure that <em>either</em> the pointer is null <em>or</em>
all of the following is true:</p>
<ul>
<li class="translate-text">指针必须正确对齐。</li><li>
<p>The pointer must be properly aligned.</p>
</li>
<li class="translate-text">在模块文档中定义的意义上，它必须是“可解引用的”。</li><li>
<p>It must be “dereferencable” in the sense defined in <a href="ptr/index.html#safety">the module documentation</a>.</p>
</li>
<li class="translate-text">指针必须指向 T 的初始化实例。</li><li>
<p>The pointer must point to an initialized instance of <code>T</code>.</p>
</li>
<li class="translate-text">您必须强制执行 Rust 的别名规则，因为返回的生命周期 'a 是任意选择的，不一定反映数据的实际生命周期。 特别是，在此生命周期内，指针指向的内存不得通过任何其他指针访问（读取或写入）。</li><li>
<p>You must enforce Rust’s aliasing rules, since the returned lifetime <code>'a</code> is
arbitrarily chosen and does not necessarily reflect the actual lifetime of the data.
In particular, for the duration of this lifetime, the memory the pointer points to must
not get accessed (read or written) through any other pointer.</p>
</li>
</ul>
<p class="translate-text">即使此方法的结果未使用，这也适用！ （关于被初始化的部分尚未完全确定，但在确定之前，唯一安全的方法是确保它们确实被初始化。）</p><p>This applies even if the result of this method is unused!
(The part about being initialized is not yet fully decided, but until
it is, the only safe approach is to ensure that they are indeed initialized.)</p>
<h1 id="examples-17" class="section-header"><a href="#examples-17">Examples</a></h1>
<p class="translate-text">基本用法：</p><p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">s</span> <span class="op">=</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];
<span class="kw">let</span> <span class="ident">ptr</span>: <span class="kw-2">*</span><span class="kw-2">mut</span> <span class="ident">u32</span> <span class="op">=</span> <span class="ident">s</span>.<span class="ident">as_mut_ptr</span>();
<span class="kw">let</span> <span class="ident">first_value</span> <span class="op">=</span> <span class="kw">unsafe</span> { <span class="ident">ptr</span>.<span class="ident">as_mut</span>().<span class="ident">unwrap</span>() };
<span class="kw-2">*</span><span class="ident">first_value</span> <span class="op">=</span> <span class="number">4</span>;
<span class="macro">println!</span>(<span class="string">&quot;{:?}&quot;</span>, <span class="ident">s</span>); <span class="comment">// It&#39;ll print: &quot;[4, 2, 3]&quot;.</span></code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20mut%20s%20%3D%20%5B1%2C%202%2C%203%5D%3B%0Alet%20ptr%3A%20*mut%20u32%20%3D%20s.as_mut_ptr()%3B%0Alet%20first_value%20%3D%20unsafe%20%7B%20ptr.as_mut().unwrap()%20%7D%3B%0A*first_value%20%3D%204%3B%0Aassert_eq!(s%2C%20%5B4%2C%202%2C%203%5D)%3B%0Aprintln!(%22%7B%3A%3F%7D%22%2C%20s)%3B%20%2F%2F%20It'll%20print%3A%20%22%5B4%2C%202%2C%203%5D%22.%0A%7D&amp;edition=2018">Run</a></div>
<h1 id="null-unchecked-version-2" class="section-header"><a href="#null-unchecked-version-2">Null-unchecked version</a></h1>
<p class="translate-text">如果您确定指针永远不会为空并且正在寻找某种返回 &mut T 而不是 Option<&mut T> 的 as_mut_unchecked，请知道您可以直接取消引用指针。</p><p>If you are sure the pointer can never be null and are looking for some kind of
<code>as_mut_unchecked</code> that returns the <code>&amp;mut T</code> instead of <code>Option&lt;&amp;mut T&gt;</code>, know that
you can dereference the pointer directly.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">s</span> <span class="op">=</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];
<span class="kw">let</span> <span class="ident">ptr</span>: <span class="kw-2">*</span><span class="kw-2">mut</span> <span class="ident">u32</span> <span class="op">=</span> <span class="ident">s</span>.<span class="ident">as_mut_ptr</span>();
<span class="kw">let</span> <span class="ident">first_value</span> <span class="op">=</span> <span class="kw">unsafe</span> { <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="kw-2">*</span><span class="ident">ptr</span> };
<span class="kw-2">*</span><span class="ident">first_value</span> <span class="op">=</span> <span class="number">4</span>;
<span class="macro">println!</span>(<span class="string">&quot;{:?}&quot;</span>, <span class="ident">s</span>); <span class="comment">// It&#39;ll print: &quot;[4, 2, 3]&quot;.</span></code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20mut%20s%20%3D%20%5B1%2C%202%2C%203%5D%3B%0Alet%20ptr%3A%20*mut%20u32%20%3D%20s.as_mut_ptr()%3B%0Alet%20first_value%20%3D%20unsafe%20%7B%20%26mut%20*ptr%20%7D%3B%0A*first_value%20%3D%204%3B%0Aassert_eq!(s%2C%20%5B4%2C%202%2C%203%5D)%3B%0Aprintln!(%22%7B%3A%3F%7D%22%2C%20s)%3B%20%2F%2F%20It'll%20print%3A%20%22%5B4%2C%202%2C%203%5D%22.%0A%7D&amp;edition=2018">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.as_uninit_mut" class="method has-srclink"><div class="rightside"><a class="srclink" href="../src/core/ptr/mut_ptr.rs.html#400-402" title="goto source code">[src]</a></div><a href="#method.as_uninit_mut" class="anchor"></a><h4 class="code-header">pub unsafe fn <a href="#method.as_uninit_mut" class="fnname">as_uninit_mut</a>&lt;'a&gt;(self) -&gt; <a class="enum" href="option/enum.Option.html" title="enum std::option::Option">Option</a>&lt;&amp;'a mut <a class="union" href="mem/union.MaybeUninit.html" title="union std::mem::MaybeUninit">MaybeUninit</a>&lt;T&gt;&gt;</h4></div><div class="item-info"><div class="stab unstable"><span class="emoji">🔬</span> This is a nightly-only experimental API. (<code>ptr_as_uninit</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/75402">#75402</a>)</div></div></summary><div class="docblock" xpath="/html[1]/body[1]/section[1]/details[3]/div[1]/details[9]/div[1]" istranslationnode="true" main_mp="Y25yZD4/dHFyOzpscXFbdWRjKis+eGFhMEUqK3VmS2BOSE5IUHpJUFQ="><p class="translate-text">如果指针为 null，则返回 None，否则返回对 Some 中包装的值的唯一引用。 与 as_mut 不同，这不需要初始化值。</p><p>Returns <code>None</code> if the pointer is null, or else returns a unique reference to
the value wrapped in <code>Some</code>. In contrast to <a href="#method.as_mut"><code>as_mut</code></a>, this does not require
that the value has to be initialized.</p>
<p class="translate-text">对于共享副本，请参见 as_uninit_ref。</p><p>For the shared counterpart see <a href="#method.as_uninit_ref-1"><code>as_uninit_ref</code></a>.</p>
<h1 id="safety-14" class="section-header"><a href="#safety-14">Safety</a></h1>
<p class="translate-text">调用此方法时，您必须确保指针为空或以下所有条件都为真：</p><p>When calling this method, you have to ensure that <em>either</em> the pointer is null <em>or</em>
all of the following is true:</p>
<ul>
<li class="translate-text">指针必须正确对齐。</li><li>
<p>The pointer must be properly aligned.</p>
</li>
<li class="translate-text">在模块文档中定义的意义上，它必须是“可解引用的”。</li><li>
<p>It must be “dereferencable” in the sense defined in <a href="ptr/index.html#safety">the module documentation</a>.</p>
</li>
<li class="translate-text">您必须强制执行 Rust 的别名规则，因为返回的生命周期 'a 是任意选择的，不一定反映数据的实际生命周期。 特别是，在此生命周期内，指针指向的内存不得通过任何其他指针访问（读取或写入）。</li><li>
<p>You must enforce Rust’s aliasing rules, since the returned lifetime <code>'a</code> is
arbitrarily chosen and does not necessarily reflect the actual lifetime of the data.
In particular, for the duration of this lifetime, the memory the pointer points to must
not get accessed (read or written) through any other pointer.</p>
</li>
</ul>
<p class="translate-text">即使此方法的结果未使用，这也适用！</p><p>This applies even if the result of this method is unused!</p>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.guaranteed_eq-1" class="method has-srclink"><div class="rightside"><a class="srclink" href="../src/core/ptr/mut_ptr.rs.html#433-435" title="goto source code">[src]</a></div><a href="#method.guaranteed_eq-1" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.guaranteed_eq-1" class="fnname">guaranteed_eq</a>(self, other: <a class="primitive" href="primitive.pointer.html">*mut T</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></div><div class="item-info"><div class="stab unstable"><span class="emoji">🔬</span> This is a nightly-only experimental API. (<code>const_raw_ptr_comparison</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/53020">#53020</a>)</div></div></summary><div class="docblock" xpath="/html[1]/body[1]/section[1]/details[3]/div[1]/details[10]/div[1]" istranslationnode="true" main_mp="Y25yZD4/dHFyOzpscXFbdWRjKis+eGFhMEUqK3NgdWdBT1REQUF7QFE="><p class="translate-text">返回是否保证两个指针相等。</p><p>Returns whether two pointers are guaranteed to be equal.</p>
<p class="translate-text">在运行时，此函数的行为类似于 self == other。 但是，在某些情况下（例如，编译时评估），并不总是可以确定两个指针的相等性，因此该函数可能会虚假地为后来实际上相等的指针返回 false。 但是当它返回 true 时，指针保证是相等的。</p><p>At runtime this function behaves like <code>self == other</code>.
However, in some contexts (e.g., compile-time evaluation),
it is not always possible to determine equality of two pointers, so this function may
spuriously return <code>false</code> for pointers that later actually turn out to be equal.
But when it returns <code>true</code>, the pointers are guaranteed to be equal.</p>
<p class="translate-text">这个函数是Guaranteed_ne 的镜像，但不是它的逆函数。 存在两个函数都返回 false 的指针比较。</p><p>This function is the mirror of <a href="#method.guaranteed_ne"><code>guaranteed_ne</code></a>, but not its inverse. There are pointer
comparisons for which both functions return <code>false</code>.</p>
<p class="translate-text">返回值可能会根据编译器版本而变化，并且不安全的代码可能不依赖此函数的结果来保证可靠性。 建议仅将此函数用于性能优化，其中此函数的虚假返回值不会影响结果，而只会影响性能。 尚未探索使用此方法使运行时和编译时代码行为不同的后果。 这种方法不应该用来引入这样的差异，在我们对这个问题有更好的理解之前，它也不应该被稳定下来。</p><p>The return value may change depending on the compiler version and unsafe code might not
rely on the result of this function for soundness. It is suggested to only use this function
for performance optimizations where spurious <code>false</code> return values by this function do not
affect the outcome, but just the performance.
The consequences of using this method to make runtime and compile-time code behave
differently have not been explored. This method should not be used to introduce such
differences, and it should also not be stabilized before we have a better understanding
of this issue.</p>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.guaranteed_ne-1" class="method has-srclink"><div class="rightside"><a class="srclink" href="../src/core/ptr/mut_ptr.rs.html#464-466" title="goto source code">[src]</a></div><a href="#method.guaranteed_ne-1" class="anchor"></a><h4 class="code-header">pub unsafe fn <a href="#method.guaranteed_ne-1" class="fnname">guaranteed_ne</a>(self, other: <a class="primitive" href="primitive.pointer.html">*mut T</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></div><div class="item-info"><div class="stab unstable"><span class="emoji">🔬</span> This is a nightly-only experimental API. (<code>const_raw_ptr_comparison</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/53020">#53020</a>)</div></div></summary><div class="docblock" xpath="/html[1]/body[1]/section[1]/details[3]/div[1]/details[11]/div[1]" istranslationnode="true" main_mp="Y25yZD4/dHFyOzpscXFbdWRjKis+eGFhMEUqK3NgdWdBT1REQUF7S0U="><p class="translate-text">返回是否保证两个指针不相等。</p><p>Returns whether two pointers are guaranteed to be unequal.</p>
<p class="translate-text">在运行时，此函数的行为类似于 self != other。 但是，在某些情况下（例如，编译时评估），并不总是可以确定两个指针的不等式，因此该函数可能会虚假地返回 false，因为这些指针后来实际上是不等的。 但是当它返回 true 时，指针保证不相等。</p><p>At runtime this function behaves like <code>self != other</code>.
However, in some contexts (e.g., compile-time evaluation),
it is not always possible to determine the inequality of two pointers, so this function may
spuriously return <code>false</code> for pointers that later actually turn out to be unequal.
But when it returns <code>true</code>, the pointers are guaranteed to be unequal.</p>
<p class="translate-text">这个函数是Guaranteed_eq 的镜像，但不是它的倒数。 存在两个函数都返回 false 的指针比较。</p><p>This function is the mirror of <a href="#method.guaranteed_eq"><code>guaranteed_eq</code></a>, but not its inverse. There are pointer
comparisons for which both functions return <code>false</code>.</p>
<p class="translate-text">返回值可能会根据编译器版本而变化，并且不安全的代码可能不依赖此函数的结果来保证可靠性。 建议仅将此函数用于性能优化，其中此函数的虚假返回值不会影响结果，而只会影响性能。 尚未探索使用此方法使运行时和编译时代码行为不同的后果。 这种方法不应该用来引入这样的差异，在我们对这个问题有更好的理解之前，它也不应该被稳定下来。</p><p>The return value may change depending on the compiler version and unsafe code might not
rely on the result of this function for soundness. It is suggested to only use this function
for performance optimizations where spurious <code>false</code> return values by this function do not
affect the outcome, but just the performance.
The consequences of using this method to make runtime and compile-time code behave
differently have not been explored. This method should not be used to introduce such
differences, and it should also not be stabilized before we have a better understanding
of this issue.</p>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.offset_from-1" class="method has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.47.0, const unstable">1.47.0 (const: <a href="https://github.com/rust-lang/rust/issues/41079" title="Tracking issue for const_ptr_offset_from">unstable</a>)</span><a class="srclink" href="../src/core/ptr/mut_ptr.rs.html#555-557" title="goto source code">[src]</a></div><a href="#method.offset_from-1" class="anchor"></a><h4 class="code-header">pub unsafe fn <a href="#method.offset_from-1" class="fnname">offset_from</a>(self, origin: <a class="primitive" href="primitive.pointer.html">*const T</a>) -&gt; <a class="primitive" href="primitive.isize.html">isize</a></h4></div></summary><div class="docblock" xpath="/html[1]/body[1]/section[1]/details[3]/div[1]/details[12]/div[1]" istranslationnode="true" main_mp="Y25yZD4/dHFyOzpscXFbdWRjKis+eGFhMEUqK3tzcmZFVX9HVkpJ"><p class="translate-text">计算两个指针之间的距离。 返回值以 T 为单位：以字节为单位的距离除以 mem::size_of::<t>()。</t></p><p>Calculates the distance between two pointers. The returned value is in
units of T: the distance in bytes is divided by <code>mem::size_of::&lt;T&gt;()</code>.</p>
<p class="translate-text">该函数是偏移量的倒数。</p><p>This function is the inverse of <a href="#method.offset-1"><code>offset</code></a>.</p>
<h1 id="safety-15" class="section-header"><a href="#safety-15">Safety</a></h1>
<p class="translate-text">如果违反以下任何条件，则结果为未定义行为：</p><p>If any of the following conditions are violated, the result is Undefined
Behavior:</p>
<ul>
<li class="translate-text">起始指针和其他指针都必须在边界内或超过同一分配对象的末尾一个字节。</li><li>
<p>Both the starting and other pointer must be either in bounds or one
byte past the end of the same <a href="ptr/index.html#allocated-object">allocated object</a>.</p>
</li>
<li class="translate-text">两个指针都必须从指向同一个对象的指针派生。 （请参见下面的示例。）</li><li>
<p>Both pointers must be <em>derived from</em> a pointer to the same object.
(See below for an example.)</p>
</li>
<li class="translate-text">指针之间的距离（以字节为单位）必须是 T 大小的精确倍数。</li><li>
<p>The distance between the pointers, in bytes, must be an exact multiple
of the size of <code>T</code>.</p>
</li>
<li class="translate-text">指针之间的距离（以字节为单位）不能溢出 isize。</li><li>
<p>The distance between the pointers, <strong>in bytes</strong>, cannot overflow an <code>isize</code>.</p>
</li>
<li class="translate-text">范围内的距离不能依赖于“环绕”地址空间。</li><li>
<p>The distance being in bounds cannot rely on “wrapping around” the address space.</p>
</li>
</ul>
<p class="translate-text">Rust 类型永远不会大于 isize::MAX 并且 Rust 分配永远不会环绕地址空间，因此任何 Rust 类型 T 的某个值内的两个指针将始终满足最后两个条件。 标准库通常还确保分配永远不会达到需要考虑偏移量的大小。 例如， Vec 和 Box 确保它们分配的字节数永远不会超过 isize::MAX 字节，因此 ptr_into_vec.offset_from(vec.as_ptr()) 总是满足最后两个条件。</p><p>Rust types are never larger than <code>isize::MAX</code> and Rust allocations never wrap around the
address space, so two pointers within some value of any Rust type <code>T</code> will always satisfy
the last two conditions. The standard library also generally ensures that allocations
never reach a size where an offset is a concern. For instance, <code>Vec</code> and <code>Box</code> ensure they
never allocate more than <code>isize::MAX</code> bytes, so <code>ptr_into_vec.offset_from(vec.as_ptr())</code>
always satisfies the last two conditions.</p>
<p class="translate-text">大多数平台根本无法构建如此大的分配。 例如，由于页表限制或地址空间分割，没有已知的 64 位平台可以为 263 字节的请求提供服务。 但是，一些 32 位和 16 位平台可能会成功地为超过 isize::MAX 字节的请求提供物理地址扩展等内容。 因此，直接从分配器或内存映射文件获取的内存可能太大而无法使用此函数处理。 （请注意，offset 和 add 也有类似的限制，因此也不能用于如此大的分配。）</p><p>Most platforms fundamentally can’t even construct such a large allocation.
For instance, no known 64-bit platform can ever serve a request
for 2<sup>63</sup> bytes due to page-table limitations or splitting the address space.
However, some 32-bit and 16-bit platforms may successfully serve a request for
more than <code>isize::MAX</code> bytes with things like Physical Address
Extension. As such, memory acquired directly from allocators or memory
mapped files <em>may</em> be too large to handle with this function.
(Note that <a href="#method.offset-1"><code>offset</code></a> and <a href="#method.add"><code>add</code></a> also have a similar limitation and hence cannot be used on
such large allocations either.)</p>
<h1 id="panics-2" class="section-header"><a href="#panics-2">Panics</a></h1>
<p class="translate-text">如果 T 是零大小类型（“ZST”），则此函数会出现panic。</p><p>This function panics if <code>T</code> is a Zero-Sized Type (“ZST”).</p>
<h1 id="examples-18" class="section-header"><a href="#examples-18">Examples</a></h1>
<p class="translate-text">基本用法：</p><p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">a</span> <span class="op">=</span> [<span class="number">0</span>; <span class="number">5</span>];
<span class="kw">let</span> <span class="ident">ptr1</span>: <span class="kw-2">*</span><span class="kw-2">mut</span> <span class="ident">i32</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">a</span>[<span class="number">1</span>];
<span class="kw">let</span> <span class="ident">ptr2</span>: <span class="kw-2">*</span><span class="kw-2">mut</span> <span class="ident">i32</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">a</span>[<span class="number">3</span>];
<span class="kw">unsafe</span> {
    <span class="macro">assert_eq!</span>(<span class="ident">ptr2</span>.<span class="ident">offset_from</span>(<span class="ident">ptr1</span>), <span class="number">2</span>);
    <span class="macro">assert_eq!</span>(<span class="ident">ptr1</span>.<span class="ident">offset_from</span>(<span class="ident">ptr2</span>), <span class="op">-</span><span class="number">2</span>);
    <span class="macro">assert_eq!</span>(<span class="ident">ptr1</span>.<span class="ident">offset</span>(<span class="number">2</span>), <span class="ident">ptr2</span>);
    <span class="macro">assert_eq!</span>(<span class="ident">ptr2</span>.<span class="ident">offset</span>(<span class="op">-</span><span class="number">2</span>), <span class="ident">ptr1</span>);
}</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20mut%20a%20%3D%20%5B0%3B%205%5D%3B%0Alet%20ptr1%3A%20*mut%20i32%20%3D%20%26mut%20a%5B1%5D%3B%0Alet%20ptr2%3A%20*mut%20i32%20%3D%20%26mut%20a%5B3%5D%3B%0Aunsafe%20%7B%0A%20%20%20%20assert_eq!(ptr2.offset_from(ptr1)%2C%202)%3B%0A%20%20%20%20assert_eq!(ptr1.offset_from(ptr2)%2C%20-2)%3B%0A%20%20%20%20assert_eq!(ptr1.offset(2)%2C%20ptr2)%3B%0A%20%20%20%20assert_eq!(ptr2.offset(-2)%2C%20ptr1)%3B%0A%7D%0A%7D&amp;edition=2018">Run</a></div>
<p class="translate-text">错误用法：</p><p><em>Incorrect</em> usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">ptr1</span> <span class="op">=</span> <span class="ident">Box::into_raw</span>(<span class="ident">Box::new</span>(<span class="number">0u8</span>));
<span class="kw">let</span> <span class="ident">ptr2</span> <span class="op">=</span> <span class="ident">Box::into_raw</span>(<span class="ident">Box::new</span>(<span class="number">1u8</span>));
<span class="kw">let</span> <span class="ident">diff</span> <span class="op">=</span> (<span class="ident">ptr2</span> <span class="kw">as</span> <span class="ident">isize</span>).<span class="ident">wrapping_sub</span>(<span class="ident">ptr1</span> <span class="kw">as</span> <span class="ident">isize</span>);
<span class="comment">// Make ptr2_other an &quot;alias&quot; of ptr2, but derived from ptr1.</span>
<span class="kw">let</span> <span class="ident">ptr2_other</span> <span class="op">=</span> (<span class="ident">ptr1</span> <span class="kw">as</span> <span class="kw-2">*</span><span class="kw-2">mut</span> <span class="ident">u8</span>).<span class="ident">wrapping_offset</span>(<span class="ident">diff</span>);
<span class="macro">assert_eq!</span>(<span class="ident">ptr2</span> <span class="kw">as</span> <span class="ident">usize</span>, <span class="ident">ptr2_other</span> <span class="kw">as</span> <span class="ident">usize</span>);
<span class="comment">// Since ptr2_other and ptr2 are derived from pointers to different objects,</span>
<span class="comment">// computing their offset is undefined behavior, even though</span>
<span class="comment">// they point to the same address!</span>
<span class="kw">unsafe</span> {
    <span class="kw">let</span> <span class="ident">zero</span> <span class="op">=</span> <span class="ident">ptr2_other</span>.<span class="ident">offset_from</span>(<span class="ident">ptr2</span>); <span class="comment">// Undefined Behavior</span>
}</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20ptr1%20%3D%20Box%3A%3Ainto_raw(Box%3A%3Anew(0u8))%3B%0Alet%20ptr2%20%3D%20Box%3A%3Ainto_raw(Box%3A%3Anew(1u8))%3B%0Alet%20diff%20%3D%20(ptr2%20as%20isize).wrapping_sub(ptr1%20as%20isize)%3B%0A%2F%2F%20Make%20ptr2_other%20an%20%22alias%22%20of%20ptr2%2C%20but%20derived%20from%20ptr1.%0Alet%20ptr2_other%20%3D%20(ptr1%20as%20*mut%20u8).wrapping_offset(diff)%3B%0Aassert_eq!(ptr2%20as%20usize%2C%20ptr2_other%20as%20usize)%3B%0A%2F%2F%20Since%20ptr2_other%20and%20ptr2%20are%20derived%20from%20pointers%20to%20different%20objects%2C%0A%2F%2F%20computing%20their%20offset%20is%20undefined%20behavior%2C%20even%20though%0A%2F%2F%20they%20point%20to%20the%20same%20address!%0Aunsafe%20%7B%0A%20%20%20%20let%20zero%20%3D%20ptr2_other.offset_from(ptr2)%3B%20%2F%2F%20Undefined%20Behavior%0A%7D%0A%7D&amp;edition=2018">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.add-1" class="method has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.26.0, const unstable">1.26.0 (const: <a href="https://github.com/rust-lang/rust/issues/71499" title="Tracking issue for const_ptr_offset">unstable</a>)</span><a class="srclink" href="../src/core/ptr/mut_ptr.rs.html#618-620" title="goto source code">[src]</a></div><a href="#method.add-1" class="anchor"></a><h4 class="code-header">pub unsafe fn <a href="#method.add-1" class="fnname">add</a>(self, count: <a class="primitive" href="primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="primitive.pointer.html">*mut T</a></h4></div></summary><div class="docblock" xpath="/html[1]/body[1]/section[1]/details[3]/div[1]/details[13]/div[1]" istranslationnode="true" main_mp="Y25yZD4/dHFyOzpscXFbdWRjKis+eGFhMEUqK3VxcA=="><p class="translate-text">计算指针的偏移量（.offset(count as isize) 的便利）。</p><p>Calculates the offset from a pointer (convenience for <code>.offset(count as isize)</code>).</p>
<p class="translate-text">计数以 T 为单位； 例如，计数 3 表示 3 * size_of::<t>() 字节的指针偏移量。</t></p><p><code>count</code> is in units of T; e.g., a <code>count</code> of 3 represents a pointer
offset of <code>3 * size_of::&lt;T&gt;()</code> bytes.</p>
<h1 id="safety-16" class="section-header"><a href="#safety-16">Safety</a></h1>
<p class="translate-text">如果违反以下任何条件，则结果为未定义行为：</p><p>If any of the following conditions are violated, the result is Undefined
Behavior:</p>
<ul>
<li class="translate-text">起始指针和结果指针都必须在边界内或超过同一分配对象的末尾一个字节。</li><li>
<p>Both the starting and resulting pointer must be either in bounds or one
byte past the end of the same <a href="ptr/index.html#allocated-object">allocated object</a>.</p>
</li>
<li class="translate-text">计算的偏移量（以字节为单位）不能溢出 isize。</li><li>
<p>The computed offset, <strong>in bytes</strong>, cannot overflow an <code>isize</code>.</p>
</li>
<li class="translate-text">范围内的偏移量不能依赖于“环绕”地址空间。 也就是说，无限精度和必须适合使用大小。</li><li>
<p>The offset being in bounds cannot rely on “wrapping around” the address
space. That is, the infinite-precision sum must fit in a <code>usize</code>.</p>
</li>
</ul>
<p class="translate-text">编译器和标准库通常会尝试确保分配永远不会达到需要考虑偏移量的大小。 例如， Vec 和 Box 确保它们分配的字节数永远不会超过 isize::MAX 字节，因此 vec.as_ptr().add(vec.len()) 总是安全的。</p><p>The compiler and standard library generally tries to ensure allocations
never reach a size where an offset is a concern. For instance, <code>Vec</code>
and <code>Box</code> ensure they never allocate more than <code>isize::MAX</code> bytes, so
<code>vec.as_ptr().add(vec.len())</code> is always safe.</p>
<p class="translate-text">大多数平台根本无法构建这样的分配。 例如，由于页表限制或地址空间分割，没有已知的 64 位平台可以为 263 字节的请求提供服务。 但是，一些 32 位和 16 位平台可能会成功地为超过 isize::MAX 字节的请求提供物理地址扩展等内容。 因此，直接从分配器或内存映射文件获取的内存可能太大而无法使用此函数处理。</p><p>Most platforms fundamentally can’t even construct such an allocation.
For instance, no known 64-bit platform can ever serve a request
for 2<sup>63</sup> bytes due to page-table limitations or splitting the address space.
However, some 32-bit and 16-bit platforms may successfully serve a request for
more than <code>isize::MAX</code> bytes with things like Physical Address
Extension. As such, memory acquired directly from allocators or memory
mapped files <em>may</em> be too large to handle with this function.</p>
<p class="translate-text">如果这些约束难以满足，请考虑使用 wrapping_add。 这种方法的唯一优点是它可以实现更积极的编译器优化。</p><p>Consider using <a href="#method.wrapping_add"><code>wrapping_add</code></a> instead if these constraints are
difficult to satisfy. The only advantage of this method is that it
enables more aggressive compiler optimizations.</p>
<h1 id="examples-19" class="section-header"><a href="#examples-19">Examples</a></h1>
<p class="translate-text">基本用法：</p><p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">s</span>: <span class="kw-2">&amp;</span><span class="ident">str</span> <span class="op">=</span> <span class="string">&quot;123&quot;</span>;
<span class="kw">let</span> <span class="ident">ptr</span>: <span class="kw-2">*</span><span class="kw">const</span> <span class="ident">u8</span> <span class="op">=</span> <span class="ident">s</span>.<span class="ident">as_ptr</span>();

<span class="kw">unsafe</span> {
    <span class="macro">println!</span>(<span class="string">&quot;{}&quot;</span>, <span class="kw-2">*</span><span class="ident">ptr</span>.<span class="ident">add</span>(<span class="number">1</span>) <span class="kw">as</span> <span class="ident">char</span>);
    <span class="macro">println!</span>(<span class="string">&quot;{}&quot;</span>, <span class="kw-2">*</span><span class="ident">ptr</span>.<span class="ident">add</span>(<span class="number">2</span>) <span class="kw">as</span> <span class="ident">char</span>);
}</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20s%3A%20%26str%20%3D%20%22123%22%3B%0Alet%20ptr%3A%20*const%20u8%20%3D%20s.as_ptr()%3B%0A%0Aunsafe%20%7B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20*ptr.add(1)%20as%20char)%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20*ptr.add(2)%20as%20char)%3B%0A%7D%0A%7D&amp;edition=2018">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.sub-1" class="method has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.26.0, const unstable">1.26.0 (const: <a href="https://github.com/rust-lang/rust/issues/71499" title="Tracking issue for const_ptr_offset">unstable</a>)</span><a class="srclink" href="../src/core/ptr/mut_ptr.rs.html#682-684" title="goto source code">[src]</a></div><a href="#method.sub-1" class="anchor"></a><h4 class="code-header">pub unsafe fn <a href="#method.sub-1" class="fnname">sub</a>(self, count: <a class="primitive" href="primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="primitive.pointer.html">*mut T</a></h4></div></summary><div class="docblock" xpath="/html[1]/body[1]/section[1]/details[3]/div[1]/details[14]/div[1]" istranslationnode="true" main_mp="Y25yZD4/dHFyOzpscXFbdWRjKis+eGFhMEUqK2dgdg=="><p class="translate-text">计算指针的偏移量（方便 .offset((count as isize).wrapping_neg())）。</p><p>Calculates the offset from a pointer (convenience for
<code>.offset((count as isize).wrapping_neg())</code>).</p>
<p class="translate-text">计数以 T 为单位； 例如，计数 3 表示 3 * size_of::<t>() 字节的指针偏移量。</t></p><p><code>count</code> is in units of T; e.g., a <code>count</code> of 3 represents a pointer
offset of <code>3 * size_of::&lt;T&gt;()</code> bytes.</p>
<h1 id="safety-17" class="section-header"><a href="#safety-17">Safety</a></h1>
<p class="translate-text">如果违反以下任何条件，则结果为未定义行为：</p><p>If any of the following conditions are violated, the result is Undefined
Behavior:</p>
<ul>
<li class="translate-text">起始指针和结果指针都必须在边界内或超过同一分配对象的末尾一个字节。</li><li>
<p>Both the starting and resulting pointer must be either in bounds or one
byte past the end of the same <a href="ptr/index.html#allocated-object">allocated object</a>.</p>
</li>
<li class="translate-text">计算出的偏移量不能超过 isize::MAX 字节。</li><li>
<p>The computed offset cannot exceed <code>isize::MAX</code> <strong>bytes</strong>.</p>
</li>
<li class="translate-text">范围内的偏移量不能依赖于“环绕”地址空间。 也就是说，无限精度和必须适合使用大小。</li><li>
<p>The offset being in bounds cannot rely on “wrapping around” the address
space. That is, the infinite-precision sum must fit in a usize.</p>
</li>
</ul>
<p class="translate-text">编译器和标准库通常会尝试确保分配永远不会达到需要考虑偏移量的大小。 例如， Vec 和 Box 确保它们分配的字节数永远不会超过 isize::MAX 字节，因此 vec.as_ptr().add(vec.len()).sub(vec.len()) 总是安全的。</p><p>The compiler and standard library generally tries to ensure allocations
never reach a size where an offset is a concern. For instance, <code>Vec</code>
and <code>Box</code> ensure they never allocate more than <code>isize::MAX</code> bytes, so
<code>vec.as_ptr().add(vec.len()).sub(vec.len())</code> is always safe.</p>
<p class="translate-text">大多数平台根本无法构建这样的分配。 例如，由于页表限制或地址空间分割，没有已知的 64 位平台可以为 263 字节的请求提供服务。 但是，一些 32 位和 16 位平台可能会成功地为超过 isize::MAX 字节的请求提供物理地址扩展等内容。 因此，直接从分配器或内存映射文件获取的内存可能太大而无法使用此函数处理。</p><p>Most platforms fundamentally can’t even construct such an allocation.
For instance, no known 64-bit platform can ever serve a request
for 2<sup>63</sup> bytes due to page-table limitations or splitting the address space.
However, some 32-bit and 16-bit platforms may successfully serve a request for
more than <code>isize::MAX</code> bytes with things like Physical Address
Extension. As such, memory acquired directly from allocators or memory
mapped files <em>may</em> be too large to handle with this function.</p>
<p class="translate-text">如果这些约束难以满足，请考虑使用 wrapping_sub。 这种方法的唯一优点是它可以实现更积极的编译器优化。</p><p>Consider using <a href="#method.wrapping_sub"><code>wrapping_sub</code></a> instead if these constraints are
difficult to satisfy. The only advantage of this method is that it
enables more aggressive compiler optimizations.</p>
<h1 id="examples-20" class="section-header"><a href="#examples-20">Examples</a></h1>
<p class="translate-text">基本用法：</p><p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">s</span>: <span class="kw-2">&amp;</span><span class="ident">str</span> <span class="op">=</span> <span class="string">&quot;123&quot;</span>;

<span class="kw">unsafe</span> {
    <span class="kw">let</span> <span class="ident">end</span>: <span class="kw-2">*</span><span class="kw">const</span> <span class="ident">u8</span> <span class="op">=</span> <span class="ident">s</span>.<span class="ident">as_ptr</span>().<span class="ident">add</span>(<span class="number">3</span>);
    <span class="macro">println!</span>(<span class="string">&quot;{}&quot;</span>, <span class="kw-2">*</span><span class="ident">end</span>.<span class="ident">sub</span>(<span class="number">1</span>) <span class="kw">as</span> <span class="ident">char</span>);
    <span class="macro">println!</span>(<span class="string">&quot;{}&quot;</span>, <span class="kw-2">*</span><span class="ident">end</span>.<span class="ident">sub</span>(<span class="number">2</span>) <span class="kw">as</span> <span class="ident">char</span>);
}</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20s%3A%20%26str%20%3D%20%22123%22%3B%0A%0Aunsafe%20%7B%0A%20%20%20%20let%20end%3A%20*const%20u8%20%3D%20s.as_ptr().add(3)%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20*end.sub(1)%20as%20char)%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20*end.sub(2)%20as%20char)%3B%0A%7D%0A%7D&amp;edition=2018">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.wrapping_add-1" class="method has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.26.0, const unstable">1.26.0 (const: <a href="https://github.com/rust-lang/rust/issues/71499" title="Tracking issue for const_ptr_offset">unstable</a>)</span><a class="srclink" href="../src/core/ptr/mut_ptr.rs.html#745-747" title="goto source code">[src]</a></div><a href="#method.wrapping_add-1" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.wrapping_add-1" class="fnname">wrapping_add</a>(self, count: <a class="primitive" href="primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="primitive.pointer.html">*mut T</a></h4></div></summary><div class="docblock" xpath="/html[1]/body[1]/section[1]/details[3]/div[1]/details[15]/div[1]" istranslationnode="true" main_mp="Y25yZD4/dHFyOzpscXFbdWRjKis+eGFhMEUqK2NndWVQSE5Ge0RAQQ=="><p class="translate-text">使用环绕算法计算指针的偏移量。 （方便.wrapping_offset（计为isize））</p><p>Calculates the offset from a pointer using wrapping arithmetic.
(convenience for <code>.wrapping_offset(count as isize)</code>)</p>
<p class="translate-text">计数以 T 为单位； 例如，计数 3 表示 3 * size_of::<t>() 字节的指针偏移量。</t></p><p><code>count</code> is in units of T; e.g., a <code>count</code> of 3 represents a pointer
offset of <code>3 * size_of::&lt;T&gt;()</code> bytes.</p>
<h1 id="safety-18" class="section-header"><a href="#safety-18">Safety</a></h1>
<p class="translate-text">这个操作本身总是安全的，但使用结果指针却不是。</p><p>This operation itself is always safe, but using the resulting pointer is not.</p>
<p class="translate-text">结果指针“记住”了 self 指向的已分配对象； 它不能用于读取或写入其他分配的对象。</p><p>The resulting pointer “remembers” the <a href="ptr/index.html#allocated-object">allocated object</a> that <code>self</code> points to; it must not
be used to read or write other allocated objects.</p>
<p class="translate-text">换句话说，即使我们假设 T 的大小为 1 并且没有溢出， let z = x.wrapping_add((y as usize) - (x as usize)) 也不会使 z 与 y 相同：z 仍然附加到 对象 x 附加到，并且取消引用它是未定义的行为，除非 x 和 y 指向同一个分配的对象。</p><p>In other words, <code>let z = x.wrapping_add((y as usize) - (x as usize))</code> does <em>not</em> make <code>z</code>
the same as <code>y</code> even if we assume <code>T</code> has size <code>1</code> and there is no overflow: <code>z</code> is still
attached to the object <code>x</code> is attached to, and dereferencing it is Undefined Behavior unless
<code>x</code> and <code>y</code> point into the same allocated object.</p>
<p class="translate-text">与add相比，这种方法基本上延迟了停留在同一个分配对象内的要求：add是跨越对象边界时立即发生的Undefined Behavior； wrapping_add 会产生一个指针，但如果指针在其附加到的对象超出范围时被取消引用，它仍会导致未定义行为。 add 可以更好地优化，因此在性能敏感的代码中更可取。</p><p>Compared to <a href="#method.add"><code>add</code></a>, this method basically delays the requirement of staying within the
same allocated object: <a href="#method.add"><code>add</code></a> is immediate Undefined Behavior when crossing object
boundaries; <code>wrapping_add</code> produces a pointer but still leads to Undefined Behavior if a
pointer is dereferenced when it is out-of-bounds of the object it is attached to. <a href="#method.add"><code>add</code></a>
can be optimized better and is thus preferable in performance-sensitive code.</p>
<p class="translate-text">延迟检查仅考虑被取消引用的指针的值，而不考虑在计算最终结果期间使用的中间值。 例如，x.wrapping_add(o).wrapping_sub(o) 总是与 x 相同。 换句话说，允许离开分配的对象，然后再重新进入它。</p><p>The delayed check only considers the value of the pointer that was dereferenced, not the
intermediate values used during the computation of the final result. For example,
<code>x.wrapping_add(o).wrapping_sub(o)</code> is always the same as <code>x</code>. In other words, leaving the
allocated object and then re-entering it later is permitted.</p>
<h1 id="examples-21" class="section-header"><a href="#examples-21">Examples</a></h1>
<p class="translate-text">基本用法：</p><p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Iterate using a raw pointer in increments of two elements</span>
<span class="kw">let</span> <span class="ident">data</span> <span class="op">=</span> [<span class="number">1u8</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">ptr</span>: <span class="kw-2">*</span><span class="kw">const</span> <span class="ident">u8</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">as_ptr</span>();
<span class="kw">let</span> <span class="ident">step</span> <span class="op">=</span> <span class="number">2</span>;
<span class="kw">let</span> <span class="ident">end_rounded_up</span> <span class="op">=</span> <span class="ident">ptr</span>.<span class="ident">wrapping_add</span>(<span class="number">6</span>);

<span class="comment">// This loop prints &quot;1, 3, 5, &quot;</span>
<span class="kw">while</span> <span class="ident">ptr</span> <span class="op">!</span><span class="op">=</span> <span class="ident">end_rounded_up</span> {
    <span class="kw">unsafe</span> {
        <span class="macro">print!</span>(<span class="string">&quot;{}, &quot;</span>, <span class="kw-2">*</span><span class="ident">ptr</span>);
    }
    <span class="ident">ptr</span> <span class="op">=</span> <span class="ident">ptr</span>.<span class="ident">wrapping_add</span>(<span class="ident">step</span>);
}</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%2F%2F%20Iterate%20using%20a%20raw%20pointer%20in%20increments%20of%20two%20elements%0Afn%20main()%20%7B%0Alet%20data%20%3D%20%5B1u8%2C%202%2C%203%2C%204%2C%205%5D%3B%0Alet%20mut%20ptr%3A%20*const%20u8%20%3D%20data.as_ptr()%3B%0Alet%20step%20%3D%202%3B%0Alet%20end_rounded_up%20%3D%20ptr.wrapping_add(6)%3B%0A%0A%2F%2F%20This%20loop%20prints%20%221%2C%203%2C%205%2C%20%22%0Awhile%20ptr%20!%3D%20end_rounded_up%20%7B%0A%20%20%20%20unsafe%20%7B%0A%20%20%20%20%20%20%20%20print!(%22%7B%7D%2C%20%22%2C%20*ptr)%3B%0A%20%20%20%20%7D%0A%20%20%20%20ptr%20%3D%20ptr.wrapping_add(step)%3B%0A%7D%0A%7D&amp;edition=2018">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.wrapping_sub-1" class="method has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.26.0, const unstable">1.26.0 (const: <a href="https://github.com/rust-lang/rust/issues/71499" title="Tracking issue for const_ptr_offset">unstable</a>)</span><a class="srclink" href="../src/core/ptr/mut_ptr.rs.html#807-809" title="goto source code">[src]</a></div><a href="#method.wrapping_sub-1" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.wrapping_sub-1" class="fnname">wrapping_sub</a>(self, count: <a class="primitive" href="primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="primitive.pointer.html">*mut T</a></h4></div></summary><div class="docblock" xpath="/html[1]/body[1]/section[1]/details[3]/div[1]/details[16]/div[1]" istranslationnode="true" main_mp="Y25yZD4/dHFyOzpscXFbdWRjKis+eGFhMEUqK2NndWVQSE5Ge1ZRRw=="><p class="translate-text">使用环绕算法计算指针的偏移量。 （方便.wrapping_offset（（计为isize）.wrapping_neg（）））</p><p>Calculates the offset from a pointer using wrapping arithmetic.
(convenience for <code>.wrapping_offset((count as isize).wrapping_neg())</code>)</p>
<p class="translate-text">计数以 T 为单位； 例如，计数 3 表示 3 * size_of::<t>() 字节的指针偏移量。</t></p><p><code>count</code> is in units of T; e.g., a <code>count</code> of 3 represents a pointer
offset of <code>3 * size_of::&lt;T&gt;()</code> bytes.</p>
<h1 id="safety-19" class="section-header"><a href="#safety-19">Safety</a></h1>
<p class="translate-text">这个操作本身总是安全的，但使用结果指针却不是。</p><p>This operation itself is always safe, but using the resulting pointer is not.</p>
<p class="translate-text">结果指针“记住”了 self 指向的已分配对象； 它不能用于读取或写入其他分配的对象。</p><p>The resulting pointer “remembers” the <a href="ptr/index.html#allocated-object">allocated object</a> that <code>self</code> points to; it must not
be used to read or write other allocated objects.</p>
<p class="translate-text">换句话说，即使我们假设 T 的大小为 1 并且没有溢出， let z = x.wrapping_sub((x as usize) - (y as usize)) 也不会使 z 与 y 相同：z 仍然附加到 对象 x 附加到，并且取消引用它是未定义的行为，除非 x 和 y 指向同一个分配的对象。</p><p>In other words, <code>let z = x.wrapping_sub((x as usize) - (y as usize))</code> does <em>not</em> make <code>z</code>
the same as <code>y</code> even if we assume <code>T</code> has size <code>1</code> and there is no overflow: <code>z</code> is still
attached to the object <code>x</code> is attached to, and dereferencing it is Undefined Behavior unless
<code>x</code> and <code>y</code> point into the same allocated object.</p>
<p class="translate-text">与sub相比，这种方法基本上延迟了停留在同一个分配对象内的要求：sub是跨越对象边界时立即发生的Undefined Behavior； wrapping_sub 会产生一个指针，但如果指针在其附加到的对象超出范围时被取消引用，它仍会导致未定义行为。 sub 可以更好地优化，因此在性能敏感的代码中更可取。</p><p>Compared to <a href="#method.sub"><code>sub</code></a>, this method basically delays the requirement of staying within the
same allocated object: <a href="#method.sub"><code>sub</code></a> is immediate Undefined Behavior when crossing object
boundaries; <code>wrapping_sub</code> produces a pointer but still leads to Undefined Behavior if a
pointer is dereferenced when it is out-of-bounds of the object it is attached to. <a href="#method.sub"><code>sub</code></a>
can be optimized better and is thus preferable in performance-sensitive code.</p>
<p class="translate-text">延迟检查仅考虑被取消引用的指针的值，而不考虑在计算最终结果期间使用的中间值。 例如，x.wrapping_add(o).wrapping_sub(o) 总是与 x 相同。 换句话说，允许离开分配的对象，然后再重新进入它。</p><p>The delayed check only considers the value of the pointer that was dereferenced, not the
intermediate values used during the computation of the final result. For example,
<code>x.wrapping_add(o).wrapping_sub(o)</code> is always the same as <code>x</code>. In other words, leaving the
allocated object and then re-entering it later is permitted.</p>
<h1 id="examples-22" class="section-header"><a href="#examples-22">Examples</a></h1>
<p class="translate-text">基本用法：</p><p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Iterate using a raw pointer in increments of two elements (backwards)</span>
<span class="kw">let</span> <span class="ident">data</span> <span class="op">=</span> [<span class="number">1u8</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">ptr</span>: <span class="kw-2">*</span><span class="kw">const</span> <span class="ident">u8</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">as_ptr</span>();
<span class="kw">let</span> <span class="ident">start_rounded_down</span> <span class="op">=</span> <span class="ident">ptr</span>.<span class="ident">wrapping_sub</span>(<span class="number">2</span>);
<span class="ident">ptr</span> <span class="op">=</span> <span class="ident">ptr</span>.<span class="ident">wrapping_add</span>(<span class="number">4</span>);
<span class="kw">let</span> <span class="ident">step</span> <span class="op">=</span> <span class="number">2</span>;
<span class="comment">// This loop prints &quot;5, 3, 1, &quot;</span>
<span class="kw">while</span> <span class="ident">ptr</span> <span class="op">!</span><span class="op">=</span> <span class="ident">start_rounded_down</span> {
    <span class="kw">unsafe</span> {
        <span class="macro">print!</span>(<span class="string">&quot;{}, &quot;</span>, <span class="kw-2">*</span><span class="ident">ptr</span>);
    }
    <span class="ident">ptr</span> <span class="op">=</span> <span class="ident">ptr</span>.<span class="ident">wrapping_sub</span>(<span class="ident">step</span>);
}</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%2F%2F%20Iterate%20using%20a%20raw%20pointer%20in%20increments%20of%20two%20elements%20(backwards)%0Afn%20main()%20%7B%0Alet%20data%20%3D%20%5B1u8%2C%202%2C%203%2C%204%2C%205%5D%3B%0Alet%20mut%20ptr%3A%20*const%20u8%20%3D%20data.as_ptr()%3B%0Alet%20start_rounded_down%20%3D%20ptr.wrapping_sub(2)%3B%0Aptr%20%3D%20ptr.wrapping_add(4)%3B%0Alet%20step%20%3D%202%3B%0A%2F%2F%20This%20loop%20prints%20%225%2C%203%2C%201%2C%20%22%0Awhile%20ptr%20!%3D%20start_rounded_down%20%7B%0A%20%20%20%20unsafe%20%7B%0A%20%20%20%20%20%20%20%20print!(%22%7B%7D%2C%20%22%2C%20*ptr)%3B%0A%20%20%20%20%7D%0A%20%20%20%20ptr%20%3D%20ptr.wrapping_sub(step)%3B%0A%7D%0A%7D&amp;edition=2018">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.set_ptr_value-1" class="method has-srclink"><div class="rightside"><a class="srclink" href="../src/core/ptr/mut_ptr.rs.html#845" title="goto source code">[src]</a></div><a href="#method.set_ptr_value-1" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.set_ptr_value-1" class="fnname">set_ptr_value</a>(self, val: <a class="primitive" href="primitive.pointer.html">*mut </a><a class="primitive" href="primitive.u8.html">u8</a>) -&gt; <a class="primitive" href="primitive.pointer.html">*mut T</a></h4></div><div class="item-info"><div class="stab unstable"><span class="emoji">🔬</span> This is a nightly-only experimental API. (<code>set_ptr_value</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/75091">#75091</a>)</div></div></summary><div class="docblock" xpath="/html[1]/body[1]/section[1]/details[3]/div[1]/details[17]/div[1]" istranslationnode="true" main_mp="Y25yZD4/dHFyOzpscXFbdWRjKis+eGFhMEUqK2dwYEpQVVJ+UkRIUEU="><p class="translate-text">将指针值设置为 ptr。</p><p>Sets the pointer value to <code>ptr</code>.</p>
<p class="translate-text">如果 self 是指向未调整类型的（胖）指针，则此操作只会影响指针部分，而对于指向已调整类型的（瘦）指针，这与简单赋值具有相同的效果。</p><p>In case <code>self</code> is a (fat) pointer to an unsized type, this operation
will only affect the pointer part, whereas for (thin) pointers to
sized types, this has the same effect as a simple assignment.</p>
<p class="translate-text">结果指针将具有 val 的出处，即，对于胖指针，此操作在语义上与使用 val 的数据指针值但 self 的元数据创建一个新的胖指针相同。</p><p>The resulting pointer will have provenance of <code>val</code>, i.e., for a fat
pointer, this operation is semantically the same as creating a new
fat pointer with the data pointer value of <code>val</code> but the metadata of
<code>self</code>.</p>
<h1 id="examples-23" class="section-header"><a href="#examples-23">Examples</a></h1>
<p class="translate-text">此函数主要用于允许对潜在的胖指针进行字节指针运算：</p><p>This function is primarily useful for allowing byte-wise pointer
arithmetic on potentially fat pointers:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attribute">#![<span class="ident">feature</span>(<span class="ident">set_ptr_value</span>)]</span>
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">arr</span>: [<span class="ident">i32</span>; <span class="number">3</span>] <span class="op">=</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">ptr</span> <span class="op">=</span> <span class="ident">arr</span>.<span class="ident">as_mut_ptr</span>() <span class="kw">as</span> <span class="kw-2">*</span><span class="kw-2">mut</span> <span class="kw">dyn</span> <span class="ident">Debug</span>;
<span class="kw">let</span> <span class="ident">thin</span> <span class="op">=</span> <span class="ident">ptr</span> <span class="kw">as</span> <span class="kw-2">*</span><span class="kw-2">mut</span> <span class="ident">u8</span>;
<span class="kw">unsafe</span> {
    <span class="ident">ptr</span> <span class="op">=</span> <span class="ident">ptr</span>.<span class="ident">set_ptr_value</span>(<span class="ident">thin</span>.<span class="ident">add</span>(<span class="number">8</span>));
    <span class="macro">println!</span>(<span class="string">&quot;{:?}&quot;</span>, <span class="kw-2">&amp;</span><span class="kw-2">*</span><span class="ident">ptr</span>); <span class="comment">// will print &quot;3&quot;</span>
}</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(set_ptr_value)%5D%0Afn%20main()%20%7B%0Ause%20core%3A%3Afmt%3A%3ADebug%3B%0Alet%20mut%20arr%3A%20%5Bi32%3B%203%5D%20%3D%20%5B1%2C%202%2C%203%5D%3B%0Alet%20mut%20ptr%20%3D%20arr.as_mut_ptr()%20as%20*mut%20dyn%20Debug%3B%0Alet%20thin%20%3D%20ptr%20as%20*mut%20u8%3B%0Aunsafe%20%7B%0A%20%20%20%20ptr%20%3D%20ptr.set_ptr_value(thin.add(8))%3B%0Aassert_eq!(*(ptr%20as%20*mut%20i32)%2C%203)%3B%0A%20%20%20%20println!(%22%7B%3A%3F%7D%22%2C%20%26*ptr)%3B%20%2F%2F%20will%20print%20%223%22%0A%7D%0A%7D&amp;version=nightly&amp;edition=2018">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.read-1" class="method has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.26.0, const unstable">1.26.0 (const: <a href="https://github.com/rust-lang/rust/issues/80377" title="Tracking issue for const_ptr_read">unstable</a>)</span><a class="srclink" href="../src/core/ptr/mut_ptr.rs.html#864-866" title="goto source code">[src]</a></div><a href="#method.read-1" class="anchor"></a><h4 class="code-header">pub unsafe fn <a href="#method.read-1" class="fnname">read</a>(self) -&gt; T</h4></div></summary><div class="docblock" xpath="/html[1]/body[1]/section[1]/details[3]/div[1]/details[18]/div[1]" istranslationnode="true" main_mp="Y25yZD4/dHFyOzpscXFbdWRjKis+eGFhMEUqK2ZwdXE="><p class="translate-text">从 self 读取值而不移动它。 这使 self 中的内存保持不变。</p><p>Reads the value from <code>self</code> without moving it. This leaves the
memory in <code>self</code> unchanged.</p>
<p class="translate-text">有关安全问题和示例，请参见 ptr::read。</p><p>See <a href="ptr/fn.read.html"><code>ptr::read</code></a> for safety concerns and examples.</p>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.read_volatile-1" class="method has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.26.0">1.26.0</span><a class="srclink" href="../src/core/ptr/mut_ptr.rs.html#884-886" title="goto source code">[src]</a></div><a href="#method.read_volatile-1" class="anchor"></a><h4 class="code-header">pub unsafe fn <a href="#method.read_volatile-1" class="fnname">read_volatile</a>(self) -&gt; T</h4></div></summary><div class="docblock" xpath="/html[1]/body[1]/section[1]/details[3]/div[1]/details[19]/div[1]" istranslationnode="true" main_mp="Y25yZD4/dHFyOzpscXFbdWRjKis+eGFhMEUqK2ZwdXF/V09NRVFNSUU="><p class="translate-text">对 self 的值执行易失性读取而不移动它。 这使 self 中的内存保持不变。</p><p>Performs a volatile read of the value from <code>self</code> without moving it. This
leaves the memory in <code>self</code> unchanged.</p>
<p class="translate-text">易失性操作旨在作用于 I/O 内存，并保证编译器不会在其他易失性操作中忽略或重新排序。</p><p>Volatile operations are intended to act on I/O memory, and are guaranteed
to not be elided or reordered by the compiler across other volatile
operations.</p>
<p class="translate-text">有关安全问题和示例，请参见 ptr::read_volatile。</p><p>See <a href="ptr/fn.read_volatile.html"><code>ptr::read_volatile</code></a> for safety concerns and examples.</p>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.read_unaligned-1" class="method has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.26.0, const unstable">1.26.0 (const: <a href="https://github.com/rust-lang/rust/issues/80377" title="Tracking issue for const_ptr_read">unstable</a>)</span><a class="srclink" href="../src/core/ptr/mut_ptr.rs.html#903-905" title="goto source code">[src]</a></div><a href="#method.read_unaligned-1" class="anchor"></a><h4 class="code-header">pub unsafe fn <a href="#method.read_unaligned-1" class="fnname">read_unaligned</a>(self) -&gt; T</h4></div></summary><div class="docblock" xpath="/html[1]/body[1]/section[1]/details[3]/div[1]/details[20]/div[1]" istranslationnode="true" main_mp="Y25yZD4/dHFyOzpscXFbdWRjKis+eGFhMEUqK2ZwdXF/VE5ASExDS0VF"><p class="translate-text">从 self 读取值而不移动它。 这使 self 中的内存保持不变。</p><p>Reads the value from <code>self</code> without moving it. This leaves the
memory in <code>self</code> unchanged.</p>
<p class="translate-text">与读取不同，指针可能未对齐。</p><p>Unlike <code>read</code>, the pointer may be unaligned.</p>
<p class="translate-text">有关安全问题和示例，请参阅 ptr::read_unaligned。</p><p>See <a href="ptr/fn.read_unaligned.html"><code>ptr::read_unaligned</code></a> for safety concerns and examples.</p>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.copy_to-1" class="method has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.26.0, const unstable">1.26.0 (const: <a href="https://github.com/rust-lang/rust/issues/80697" title="Tracking issue for const_intrinsic_copy">unstable</a>)</span><a class="srclink" href="../src/core/ptr/mut_ptr.rs.html#922-924" title="goto source code">[src]</a></div><a href="#method.copy_to-1" class="anchor"></a><h4 class="code-header">pub unsafe fn <a href="#method.copy_to-1" class="fnname">copy_to</a>(self, dest: <a class="primitive" href="primitive.pointer.html">*mut T</a>, count: <a class="primitive" href="primitive.usize.html">usize</a>)</h4></div></summary><div class="docblock" xpath="/html[1]/body[1]/section[1]/details[3]/div[1]/details[21]/div[1]" istranslationnode="true" main_mp="Y25yZD4/dHFyOzpscXFbdWRjKis+eGFhMEUqK3d6ZGx/VU8="><p class="translate-text">将 count * size_of<t> 个字节从 self 复制到 dest。 源和目标可能重叠。</t></p><p>Copies <code>count * size_of&lt;T&gt;</code> bytes from <code>self</code> to <code>dest</code>. The source
and destination may overlap.</p>
<p class="translate-text">注意：这与 ptr::copy 具有相同的参数顺序。</p><p>NOTE: this has the <em>same</em> argument order as <a href="ptr/fn.copy.html"><code>ptr::copy</code></a>.</p>
<p class="translate-text">有关安全问题和示例，请参见 ptr::copy。</p><p>See <a href="ptr/fn.copy.html"><code>ptr::copy</code></a> for safety concerns and examples.</p>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.copy_to_nonoverlapping-1" class="method has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.26.0, const unstable">1.26.0 (const: <a href="https://github.com/rust-lang/rust/issues/80697" title="Tracking issue for const_intrinsic_copy">unstable</a>)</span><a class="srclink" href="../src/core/ptr/mut_ptr.rs.html#941-943" title="goto source code">[src]</a></div><a href="#method.copy_to_nonoverlapping-1" class="anchor"></a><h4 class="code-header">pub unsafe fn <a href="#method.copy_to_nonoverlapping-1" class="fnname">copy_to_nonoverlapping</a>(self, dest: <a class="primitive" href="primitive.pointer.html">*mut T</a>, count: <a class="primitive" href="primitive.usize.html">usize</a>)</h4></div></summary><div class="docblock" xpath="/html[1]/body[1]/section[1]/details[3]/div[1]/details[22]/div[1]" istranslationnode="true" main_mp="Y25yZD4/dHFyOzpscXFbdWRjKis+eGFhMEUqK3d6ZGx/VU9+SkpKSlZEUk1FVVRMXlY="><p class="translate-text">将 count * size_of<t> 个字节从 self 复制到 dest。 源和目标不能重叠。</t></p><p>Copies <code>count * size_of&lt;T&gt;</code> bytes from <code>self</code> to <code>dest</code>. The source
and destination may <em>not</em> overlap.</p>
<p class="translate-text">注意：这与 ptr::copy_nonoverlapping 具有相同的参数顺序。</p><p>NOTE: this has the <em>same</em> argument order as <a href="ptr/fn.copy_nonoverlapping.html"><code>ptr::copy_nonoverlapping</code></a>.</p>
<p class="translate-text">有关安全问题和示例，请参阅 ptr::copy_nonoverlapping。</p><p>See <a href="ptr/fn.copy_nonoverlapping.html"><code>ptr::copy_nonoverlapping</code></a> for safety concerns and examples.</p>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.copy_from" class="method has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.26.0, const unstable">1.26.0 (const: <a href="https://github.com/rust-lang/rust/issues/80697" title="Tracking issue for const_intrinsic_copy">unstable</a>)</span><a class="srclink" href="../src/core/ptr/mut_ptr.rs.html#960-962" title="goto source code">[src]</a></div><a href="#method.copy_from" class="anchor"></a><h4 class="code-header">pub unsafe fn <a href="#method.copy_from" class="fnname">copy_from</a>(self, src: <a class="primitive" href="primitive.pointer.html">*const T</a>, count: <a class="primitive" href="primitive.usize.html">usize</a>)</h4></div></summary><div class="docblock" xpath="/html[1]/body[1]/section[1]/details[3]/div[1]/details[23]/div[1]" istranslationnode="true" main_mp="Y25yZD4/dHFyOzpscXFbdWRjKis+eGFhMEUqK3d6ZGx/R1JOSQ=="><p class="translate-text">将 count * size_of<t> 个字节从 src 复制到自身。 源和目标可能重叠。</t></p><p>Copies <code>count * size_of&lt;T&gt;</code> bytes from <code>src</code> to <code>self</code>. The source
and destination may overlap.</p>
<p class="translate-text">注意：这与 ptr::copy 的参数顺序相反。</p><p>NOTE: this has the <em>opposite</em> argument order of <a href="ptr/fn.copy.html"><code>ptr::copy</code></a>.</p>
<p class="translate-text">有关安全问题和示例，请参见 ptr::copy。</p><p>See <a href="ptr/fn.copy.html"><code>ptr::copy</code></a> for safety concerns and examples.</p>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.copy_from_nonoverlapping" class="method has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.26.0, const unstable">1.26.0 (const: <a href="https://github.com/rust-lang/rust/issues/80697" title="Tracking issue for const_intrinsic_copy">unstable</a>)</span><a class="srclink" href="../src/core/ptr/mut_ptr.rs.html#979-981" title="goto source code">[src]</a></div><a href="#method.copy_from_nonoverlapping" class="anchor"></a><h4 class="code-header">pub unsafe fn <a href="#method.copy_from_nonoverlapping" class="fnname">copy_from_nonoverlapping</a>(self, src: <a class="primitive" href="primitive.pointer.html">*const T</a>, count: <a class="primitive" href="primitive.usize.html">usize</a>)</h4></div></summary><div class="docblock" xpath="/html[1]/body[1]/section[1]/details[3]/div[1]/details[24]/div[1]" istranslationnode="true" main_mp="Y25yZD4/dHFyOzpscXFbdWRjKis+eGFhMEUqK3d6ZGx/R1JOSXpKSk5OVkRWSUVVQFheVg=="><p class="translate-text">将 count * size_of<t> 个字节从 src 复制到自身。 源和目标不能重叠。</t></p><p>Copies <code>count * size_of&lt;T&gt;</code> bytes from <code>src</code> to <code>self</code>. The source
and destination may <em>not</em> overlap.</p>
<p class="translate-text">注意：这与 ptr::copy_nonoverlapping 的参数顺序相反。</p><p>NOTE: this has the <em>opposite</em> argument order of <a href="ptr/fn.copy_nonoverlapping.html"><code>ptr::copy_nonoverlapping</code></a>.</p>
<p class="translate-text">有关安全问题和示例，请参阅 ptr::copy_nonoverlapping。</p><p>See <a href="ptr/fn.copy_nonoverlapping.html"><code>ptr::copy_nonoverlapping</code></a> for safety concerns and examples.</p>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.drop_in_place" class="method has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.26.0">1.26.0</span><a class="srclink" href="../src/core/ptr/mut_ptr.rs.html#994" title="goto source code">[src]</a></div><a href="#method.drop_in_place" class="anchor"></a><h4 class="code-header">pub unsafe fn <a href="#method.drop_in_place" class="fnname">drop_in_place</a>(self)</h4></div></summary><div class="docblock" xpath="/html[1]/body[1]/section[1]/details[3]/div[1]/details[25]/div[1]" istranslationnode="true" main_mp="Y25yZD4/dHFyOzpscXFbdWRjKis+eGFhMEUqK3Bne2V/SE5+VElFRkU="><p class="translate-text">执行指向值的析构函数（如果有）。</p><p>Executes the destructor (if any) of the pointed-to value.</p>
<p class="translate-text">有关安全问题和示例，请参见 ptr::drop_in_place。</p><p>See <a href="ptr/fn.drop_in_place.html"><code>ptr::drop_in_place</code></a> for safety concerns and examples.</p>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.write" class="method has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.26.0, const unstable">1.26.0 (const: <a href="https://github.com/rust-lang/rust/issues/86302" title="Tracking issue for const_ptr_write">unstable</a>)</span><a class="srclink" href="../src/core/ptr/mut_ptr.rs.html#1008-1010" title="goto source code">[src]</a></div><a href="#method.write" class="anchor"></a><h4 class="code-header">pub unsafe fn <a href="#method.write" class="fnname">write</a>(self, val: T)</h4></div></summary><div class="docblock" xpath="/html[1]/body[1]/section[1]/details[3]/div[1]/details[26]/div[1]" istranslationnode="true" main_mp="Y25yZD4/dHFyOzpscXFbdWRjKis+eGFhMEUqK2NnfWFF"><p class="translate-text">用给定值覆盖内存位置，而不读取或删除旧值。</p><p>Overwrites a memory location with the given value without reading or
dropping the old value.</p>
<p class="translate-text">有关安全问题和示例，请参见 ptr::write。</p><p>See <a href="ptr/fn.write.html"><code>ptr::write</code></a> for safety concerns and examples.</p>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.write_bytes" class="method has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.26.0">1.26.0</span><a class="srclink" href="../src/core/ptr/mut_ptr.rs.html#1024-1026" title="goto source code">[src]</a></div><a href="#method.write_bytes" class="anchor"></a><h4 class="code-header">pub unsafe fn <a href="#method.write_bytes" class="fnname">write_bytes</a>(self, val: <a class="primitive" href="primitive.u8.html">u8</a>, count: <a class="primitive" href="primitive.usize.html">usize</a>)</h4></div></summary><div class="docblock" xpath="/html[1]/body[1]/section[1]/details[3]/div[1]/details[27]/div[1]" istranslationnode="true" main_mp="Y25yZD4/dHFyOzpscXFbdWRjKis+eGFhMEUqK2NnfWFFfkJYUEBX"><p class="translate-text">在指定指针上调用 memset，将从 self 开始的内存的 count * size_of::<t>() 字节设置为 val。</t></p><p>Invokes memset on the specified pointer, setting <code>count * size_of::&lt;T&gt;()</code>
bytes of memory starting at <code>self</code> to <code>val</code>.</p>
<p class="translate-text">有关安全问题和示例，请参见 ptr::write_bytes。</p><p>See <a href="ptr/fn.write_bytes.html"><code>ptr::write_bytes</code></a> for safety concerns and examples.</p>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.write_volatile" class="method has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.26.0">1.26.0</span><a class="srclink" href="../src/core/ptr/mut_ptr.rs.html#1044-1046" title="goto source code">[src]</a></div><a href="#method.write_volatile" class="anchor"></a><h4 class="code-header">pub unsafe fn <a href="#method.write_volatile" class="fnname">write_volatile</a>(self, val: T)</h4></div></summary><div class="docblock" xpath="/html[1]/body[1]/section[1]/details[3]/div[1]/details[28]/div[1]" istranslationnode="true" main_mp="Y25yZD4/dHFyOzpscXFbdWRjKis+eGFhMEUqK2NnfWFFflZOSERQTExE"><p class="translate-text">使用给定值执行内存位置的易失性写入，而不读取或删除旧值。</p><p>Performs a volatile write of a memory location with the given value without
reading or dropping the old value.</p>
<p class="translate-text">易失性操作旨在作用于 I/O 内存，并保证编译器不会在其他易失性操作中忽略或重新排序。</p><p>Volatile operations are intended to act on I/O memory, and are guaranteed
to not be elided or reordered by the compiler across other volatile
operations.</p>
<p class="translate-text">有关安全问题和示例，请参见 ptr::write_volatile。</p><p>See <a href="ptr/fn.write_volatile.html"><code>ptr::write_volatile</code></a> for safety concerns and examples.</p>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.write_unaligned" class="method has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.26.0, const unstable">1.26.0 (const: <a href="https://github.com/rust-lang/rust/issues/86302" title="Tracking issue for const_ptr_write">unstable</a>)</span><a class="srclink" href="../src/core/ptr/mut_ptr.rs.html#1063-1065" title="goto source code">[src]</a></div><a href="#method.write_unaligned" class="anchor"></a><h4 class="code-header">pub unsafe fn <a href="#method.write_unaligned" class="fnname">write_unaligned</a>(self, val: T)</h4></div></summary><div class="docblock" xpath="/html[1]/body[1]/section[1]/details[3]/div[1]/details[29]/div[1]" istranslationnode="true" main_mp="Y25yZD4/dHFyOzpscXFbdWRjKis+eGFhMEUqK2NnfWFFflVPRUlNQk5ERA=="><p class="translate-text">用给定值覆盖内存位置，而不读取或删除旧值。</p><p>Overwrites a memory location with the given value without reading or
dropping the old value.</p>
<p class="translate-text">与 write 不同，指针可能未对齐。</p><p>Unlike <code>write</code>, the pointer may be unaligned.</p>
<p class="translate-text">有关安全问题和示例，请参阅 ptr::write_unaligned。</p><p>See <a href="ptr/fn.write_unaligned.html"><code>ptr::write_unaligned</code></a> for safety concerns and examples.</p>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.replace" class="method has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.26.0">1.26.0</span><a class="srclink" href="../src/core/ptr/mut_ptr.rs.html#1079-1081" title="goto source code">[src]</a></div><a href="#method.replace" class="anchor"></a><h4 class="code-header">pub unsafe fn <a href="#method.replace" class="fnname">replace</a>(self, src: T) -&gt; T</h4></div></summary><div class="docblock" xpath="/html[1]/body[1]/section[1]/details[3]/div[1]/details[30]/div[1]" istranslationnode="true" main_mp="Y25yZD4/dHFyOzpscXFbdWRjKis+eGFhMEUqK2ZwZHlBQkU="><p class="translate-text">用 src 替换 self 的值，返回旧值，不丢弃任何一个。</p><p>Replaces the value at <code>self</code> with <code>src</code>, returning the old
value, without dropping either.</p>
<p class="translate-text">有关安全问题和示例，请参见 ptr::replace。</p><p>See <a href="ptr/fn.replace.html"><code>ptr::replace</code></a> for safety concerns and examples.</p>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.swap" class="method has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.26.0">1.26.0</span><a class="srclink" href="../src/core/ptr/mut_ptr.rs.html#1096-1098" title="goto source code">[src]</a></div><a href="#method.swap" class="anchor"></a><h4 class="code-header">pub unsafe fn <a href="#method.swap" class="fnname">swap</a>(self, with: <a class="primitive" href="primitive.pointer.html">*mut T</a>)</h4></div></summary><div class="docblock" xpath="/html[1]/body[1]/section[1]/details[3]/div[1]/details[31]/div[1]" istranslationnode="true" main_mp="Y25yZD4/dHFyOzpscXFbdWRjKis+eGFhMEUqK2didWU="><p class="translate-text">交换同一类型的两个可变位置的值，而不取消初始化任何一个。 它们可能重叠，不像 mem::swap 在其他方面是等效的。</p><p>Swaps the values at two mutable locations of the same type, without
deinitializing either. They may overlap, unlike <code>mem::swap</code> which is
otherwise equivalent.</p>
<p class="translate-text">有关安全问题和示例，请参阅 ptr::swap。</p><p>See <a href="ptr/fn.swap.html"><code>ptr::swap</code></a> for safety concerns and examples.</p>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.align_offset-1" class="method has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.36.0">1.36.0</span><a class="srclink" href="../src/core/ptr/mut_ptr.rs.html#1144-1146" title="goto source code">[src]</a></div><a href="#method.align_offset-1" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.align_offset-1" class="fnname">align_offset</a>(self, align: <a class="primitive" href="primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="primitive.usize.html">usize</a></h4></div></summary><div class="docblock" xpath="/html[1]/body[1]/section[1]/details[3]/div[1]/details[32]/div[1]" istranslationnode="true" main_mp="Y25yZD4/dHFyOzpscXFbdWRjKis+eGFhMEUqK3V5fXJOfk9HQlZBUQ=="><p class="translate-text">计算需要应用于指针以使其对齐对齐的偏移量。</p><p>Computes the offset that needs to be applied to the pointer in order to make it aligned to
<code>align</code>.</p>
<p class="translate-text">如果无法对齐指针，则实现返回 usize::MAX。 允许实现总是返回 usize::MAX。 只有你的算法的性能取决于在这里获得一个可用的偏移量，而不是它的正确性。</p><p>If it is not possible to align the pointer, the implementation returns
<code>usize::MAX</code>. It is permissible for the implementation to <em>always</em>
return <code>usize::MAX</code>. Only your algorithm’s performance can depend
on getting a usable offset here, not its correctness.</p>
<p class="translate-text">偏移量以 T 个元素的数量表示，而不是字节数。 返回的值可以与 wrapping_add 方法一起使用。</p><p>The offset is expressed in number of <code>T</code> elements, and not bytes. The value returned can be
used with the <code>wrapping_add</code> method.</p>
<p class="translate-text">无法保证偏移指针不会溢出或超出指针指向的分配。 由调用者确保返回的偏移量在除对齐之外的所有方面都是正确的。</p><p>There are no guarantees whatsoever that offsetting the pointer will not overflow or go
beyond the allocation that the pointer points into. It is up to the caller to ensure that
the returned offset is correct in all terms other than alignment.</p>
<h1 id="panics-3" class="section-header"><a href="#panics-3">Panics</a></h1>
<p class="translate-text">如果 align 不是 2 的幂，则函数会出现panic。</p><p>The function panics if <code>align</code> is not a power-of-two.</p>
<h1 id="examples-24" class="section-header"><a href="#examples-24">Examples</a></h1>
<p class="translate-text">以 u16 访问相邻的 u8</p><p>Accessing adjacent <code>u8</code> as <code>u16</code></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> [<span class="number">5u8</span>, <span class="number">6u8</span>, <span class="number">7u8</span>, <span class="number">8u8</span>, <span class="number">9u8</span>];
<span class="kw">let</span> <span class="ident">ptr</span> <span class="op">=</span> <span class="ident">x</span>.<span class="ident">as_ptr</span>().<span class="ident">add</span>(<span class="ident">n</span>) <span class="kw">as</span> <span class="kw-2">*</span><span class="kw">const</span> <span class="ident">u8</span>;
<span class="kw">let</span> <span class="ident">offset</span> <span class="op">=</span> <span class="ident">ptr</span>.<span class="ident">align_offset</span>(<span class="ident">align_of</span>::<span class="op">&lt;</span><span class="ident">u16</span><span class="op">&gt;</span>());
<span class="kw">if</span> <span class="ident">offset</span> <span class="op">&lt;</span> <span class="ident">x</span>.<span class="ident">len</span>() <span class="op">-</span> <span class="ident">n</span> <span class="op">-</span> <span class="number">1</span> {
    <span class="kw">let</span> <span class="ident">u16_ptr</span> <span class="op">=</span> <span class="ident">ptr</span>.<span class="ident">add</span>(<span class="ident">offset</span>) <span class="kw">as</span> <span class="kw-2">*</span><span class="kw">const</span> <span class="ident">u16</span>;
    <span class="macro">assert_ne!</span>(<span class="kw-2">*</span><span class="ident">u16_ptr</span>, <span class="number">500</span>);
} <span class="kw">else</span> {
    <span class="comment">// while the pointer can be aligned via `offset`, it would point</span>
    <span class="comment">// outside the allocation</span>
}</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Afn%20foo(n%3A%20usize)%20%7B%0Ause%20std%3A%3Amem%3A%3Aalign_of%3B%0Aunsafe%20%7B%0Alet%20x%20%3D%20%5B5u8%2C%206u8%2C%207u8%2C%208u8%2C%209u8%5D%3B%0Alet%20ptr%20%3D%20x.as_ptr().add(n)%20as%20*const%20u8%3B%0Alet%20offset%20%3D%20ptr.align_offset(align_of%3A%3A%3Cu16%3E())%3B%0Aif%20offset%20%3C%20x.len()%20-%20n%20-%201%20%7B%0A%20%20%20%20let%20u16_ptr%20%3D%20ptr.add(offset)%20as%20*const%20u16%3B%0A%20%20%20%20assert_ne!(*u16_ptr%2C%20500)%3B%0A%7D%20else%20%7B%0A%20%20%20%20%2F%2F%20while%20the%20pointer%20can%20be%20aligned%20via%20%60offset%60%2C%20it%20would%20point%0A%20%20%20%20%2F%2F%20outside%20the%20allocation%0A%7D%0A%7D%20%7D%0A%7D&amp;edition=2018">Run</a></div>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open=""><summary><div id="impl-2" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/ptr/const_ptr.rs.html#895-1016" title="goto source code">[src]</a></div><a href="#impl-2" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="primitive" href="primitive.pointer.html">*const </a><a class="primitive" href="primitive.slice.html">[</a>T<a class="primitive" href="primitive.slice.html">]</a></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.len" class="method has-srclink"><div class="rightside"><a class="srclink" href="../src/core/ptr/const_ptr.rs.html#916" title="goto source code">[src]</a></div><a href="#method.len" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.len" class="fnname">len</a>(self) -&gt; <a class="primitive" href="primitive.usize.html">usize</a></h4></div><div class="item-info"><div class="stab unstable"><span class="emoji">🔬</span> This is a nightly-only experimental API. (<code>slice_ptr_len</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/71146">#71146</a>)</div></div></summary><div class="docblock" xpath="/html[1]/body[1]/section[1]/details[4]/div[1]/details[1]/div[1]" istranslationnode="true" main_mp="Y25yZD4/dHFyOzpia2t3cU9hZGMuLz52f39jZTROQEgaG0xESg=="><p class="translate-text">返回原始切片的长度。</p><p>Returns the length of a raw slice.</p>
<p class="translate-text">返回值是元素的数量，而不是字节数。</p><p>The returned value is the number of <strong>elements</strong>, not the number of bytes.</p>
<p class="translate-text">此函数是安全的，即使由于指针为空或未对齐而无法将原始切片转换为切片引用。</p><p>This function is safe, even when the raw slice cannot be cast to a slice
reference because the pointer is null or unaligned.</p>
<h1 id="examples-25" class="section-header"><a href="#examples-25">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attribute">#![<span class="ident">feature</span>(<span class="ident">slice_ptr_len</span>)]</span>

<span class="kw">use</span> <span class="ident">std::ptr</span>;

<span class="kw">let</span> <span class="ident">slice</span>: <span class="kw-2">*</span><span class="kw">const</span> [<span class="ident">i8</span>] <span class="op">=</span> <span class="ident">ptr::slice_from_raw_parts</span>(<span class="ident">ptr::null</span>(), <span class="number">3</span>);
<span class="macro">assert_eq!</span>(<span class="ident">slice</span>.<span class="ident">len</span>(), <span class="number">3</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(slice_ptr_len)%5D%0A%0Afn%20main()%20%7B%0Ause%20std%3A%3Aptr%3B%0A%0Alet%20slice%3A%20*const%20%5Bi8%5D%20%3D%20ptr%3A%3Aslice_from_raw_parts(ptr%3A%3Anull()%2C%203)%3B%0Aassert_eq!(slice.len()%2C%203)%3B%0A%7D&amp;version=nightly&amp;edition=2018">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.as_ptr" class="method has-srclink"><div class="rightside"><a class="srclink" href="../src/core/ptr/const_ptr.rs.html#936" title="goto source code">[src]</a></div><a href="#method.as_ptr" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.as_ptr" class="fnname">as_ptr</a>(self) -&gt; <a class="primitive" href="primitive.pointer.html">*const T</a></h4></div><div class="item-info"><div class="stab unstable"><span class="emoji">🔬</span> This is a nightly-only experimental API. (<code>slice_ptr_get</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/74265">#74265</a>)</div></div></summary><div class="docblock" xpath="/html[1]/body[1]/section[1]/details[4]/div[1]/details[2]/div[1]" istranslationnode="true" main_mp="Y25yZD4/dHFyOzpia2t3cU9hZGMuLz52f39jZTROQEgaG0FSe1VQVw=="><p class="translate-text">返回指向切片缓冲区的原始指针。</p><p>Returns a raw pointer to the slice’s buffer.</p>
<p class="translate-text">这相当于将 self 强制转换为 *const T，但更安全。</p><p>This is equivalent to casting <code>self</code> to <code>*const T</code>, but more type-safe.</p>
<h1 id="examples-26" class="section-header"><a href="#examples-26">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attribute">#![<span class="ident">feature</span>(<span class="ident">slice_ptr_get</span>)]</span>
<span class="kw">use</span> <span class="ident">std::ptr</span>;

<span class="kw">let</span> <span class="ident">slice</span>: <span class="kw-2">*</span><span class="kw">const</span> [<span class="ident">i8</span>] <span class="op">=</span> <span class="ident">ptr::slice_from_raw_parts</span>(<span class="ident">ptr::null</span>(), <span class="number">3</span>);
<span class="macro">assert_eq!</span>(<span class="ident">slice</span>.<span class="ident">as_ptr</span>(), <span class="number">0</span> <span class="kw">as</span> <span class="kw-2">*</span><span class="kw">const</span> <span class="ident">i8</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(slice_ptr_get)%5D%0Afn%20main()%20%7B%0Ause%20std%3A%3Aptr%3B%0A%0Alet%20slice%3A%20*const%20%5Bi8%5D%20%3D%20ptr%3A%3Aslice_from_raw_parts(ptr%3A%3Anull()%2C%203)%3B%0Aassert_eq!(slice.as_ptr()%2C%200%20as%20*const%20i8)%3B%0A%7D&amp;version=nightly&amp;edition=2018">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.get_unchecked" class="method has-srclink"><div class="rightside"><a class="srclink" href="../src/core/ptr/const_ptr.rs.html#961-963" title="goto source code">[src]</a></div><a href="#method.get_unchecked" class="anchor"></a><h4 class="code-header">pub unsafe fn <a href="#method.get_unchecked" class="fnname">get_unchecked</a>&lt;I&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;index: I<br>) -&gt; <a class="primitive" href="primitive.pointer.html">*const </a>&lt;I as <a class="trait" href="slice/trait.SliceIndex.html" title="trait std::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.slice.html">[</a>T<a class="primitive" href="primitive.slice.html">]</a>&gt;&gt;::<a class="type" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type std::slice::SliceIndex::Output">Output</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;I: <a class="trait" href="slice/trait.SliceIndex.html" title="trait std::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.slice.html">[</a>T<a class="primitive" href="primitive.slice.html">]</a>&gt;,&nbsp;</span></h4></div><div class="item-info"><div class="stab unstable"><span class="emoji">🔬</span> This is a nightly-only experimental API. (<code>slice_ptr_get</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/74265">#74265</a>)</div></div></summary><div class="docblock" xpath="/html[1]/body[1]/section[1]/details[4]/div[1]/details[3]/div[1]" istranslationnode="true" main_mp="Y25yZD4/dHFyOzpia2t3cU9hZGMuLz52f39jZTROQEgaG0dEUHpRS0NJRUJPQEA="><p class="translate-text">返回指向元素或子切片的原始指针，而不进行边界检查。</p><p>Returns a raw pointer to an element or subslice, without doing bounds
checking.</p>
<p class="translate-text">即使未使用结果指针，使用越界索引或当 self 不可取消引用时调用此方法也是未定义的行为。</p><p>Calling this method with an out-of-bounds index or when <code>self</code> is not dereferencable
is <em><a href="https://doc.rust-lang.org/reference/behavior-considered-undefined.html">undefined behavior</a></em> even if the resulting pointer is not used.</p>
<h1 id="examples-27" class="section-header"><a href="#examples-27">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attribute">#![<span class="ident">feature</span>(<span class="ident">slice_ptr_get</span>)]</span>

<span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="kw-2">&amp;</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>] <span class="kw">as</span> <span class="kw-2">*</span><span class="kw">const</span> [<span class="ident">i32</span>];

<span class="kw">unsafe</span> {
    <span class="macro">assert_eq!</span>(<span class="ident">x</span>.<span class="ident">get_unchecked</span>(<span class="number">1</span>), <span class="ident">x</span>.<span class="ident">as_ptr</span>().<span class="ident">add</span>(<span class="number">1</span>));
}</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(slice_ptr_get)%5D%0A%0Afn%20main()%20%7B%0Alet%20x%20%3D%20%26%5B1%2C%202%2C%204%5D%20as%20*const%20%5Bi32%5D%3B%0A%0Aunsafe%20%7B%0A%20%20%20%20assert_eq!(x.get_unchecked(1)%2C%20x.as_ptr().add(1))%3B%0A%7D%0A%7D&amp;version=nightly&amp;edition=2018">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.as_uninit_slice" class="method has-srclink"><div class="rightside"><a class="srclink" href="../src/core/ptr/const_ptr.rs.html#1008" title="goto source code">[src]</a></div><a href="#method.as_uninit_slice" class="anchor"></a><h4 class="code-header">pub unsafe fn <a href="#method.as_uninit_slice" class="fnname">as_uninit_slice</a>&lt;'a&gt;(self) -&gt; <a class="enum" href="option/enum.Option.html" title="enum std::option::Option">Option</a>&lt;<a class="primitive" href="primitive.slice.html">&amp;'a [</a><a class="union" href="mem/union.MaybeUninit.html" title="union std::mem::MaybeUninit">MaybeUninit</a>&lt;T&gt;<a class="primitive" href="primitive.slice.html">]</a>&gt;</h4></div><div class="item-info"><div class="stab unstable"><span class="emoji">🔬</span> This is a nightly-only experimental API. (<code>ptr_as_uninit</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/75402">#75402</a>)</div></div></summary><div class="docblock" xpath="/html[1]/body[1]/section[1]/details[4]/div[1]/details[4]/div[1]" istranslationnode="true" main_mp="Y25yZD4/dHFyOzpia2t3cU9hZGMuLz52f39jZTROQEgaG0FSe1BKTE5IVH5XSU1GVQ=="><p class="translate-text">如果指针为 null，则返回 None，否则将共享切片返回到 Some 中包装的值。 与 as_ref 相比，这不需要初始化值。</p><p>Returns <code>None</code> if the pointer is null, or else returns a shared slice to
the value wrapped in <code>Some</code>. In contrast to <a href="#method.as_ref"><code>as_ref</code></a>, this does not require
that the value has to be initialized.</p>
<h1 id="safety-20" class="section-header"><a href="#safety-20">Safety</a></h1>
<p class="translate-text">调用此方法时，您必须确保指针为空或以下所有条件都为真：</p><p>When calling this method, you have to ensure that <em>either</em> the pointer is null <em>or</em>
all of the following is true:</p>
<ul>
<li class="translate-text">该指针必须对 ptr.len() * mem::size_of::<t>() 多个字节的读取有效，并且必须正确对齐。 这尤其意味着：</t></li><li>
<p>The pointer must be <a href="ptr/index.html#safety">valid</a> for reads for <code>ptr.len() * mem::size_of::&lt;T&gt;()</code> many bytes,
and it must be properly aligned. This means in particular:</p>
<ul>
<li class="translate-text">该切片的整个内存范围必须包含在单个分配的对象中！ 切片永远不能跨越多个分配的对象。</li><li>
<p>The entire memory range of this slice must be contained within a single <a href="ptr/index.html#allocated-object">allocated object</a>!
Slices can never span across multiple allocated objects.</p>
</li>
<li class="translate-text">即使对于零长度切片，指针也必须对齐。 这样做的一个原因是枚举布局优化可能依赖于对齐的引用（包括任何长度的切片）和非空值，以将它们与其他数据区分开来。 您可以使用 NonNull::dangling() 获得可用作零长度切片数据的指针。</li><li>
<p>The pointer must be aligned even for zero-length slices. One
reason for this is that enum layout optimizations may rely on references
(including slices of any length) being aligned and non-null to distinguish
them from other data. You can obtain a pointer that is usable as <code>data</code>
for zero-length slices using <a href="ptr/struct.NonNull.html#method.dangling" title="NonNull::dangling()"><code>NonNull::dangling()</code></a>.</p>
</li>
</ul>
</li>
<li class="translate-text">切片的总大小 ptr.len() * mem::size_of::<t>() 必须不大于 isize::MAX。 请参阅pointer::offset 的安全文档。</t></li><li>
<p>The total size <code>ptr.len() * mem::size_of::&lt;T&gt;()</code> of the slice must be no larger than <code>isize::MAX</code>.
See the safety documentation of <a href="primitive.pointer.html#method.offset" title="pointer::offset"><code>pointer::offset</code></a>.</p>
</li>
<li class="translate-text">您必须强制执行 Rust 的别名规则，因为返回的生命周期 'a 是任意选择的，不一定反映数据的实际生命周期。 特别是，在此生命周期内，指针指向的内存不得发生可变（UnsafeCell 内除外）。</li><li>
<p>You must enforce Rust’s aliasing rules, since the returned lifetime <code>'a</code> is
arbitrarily chosen and does not necessarily reflect the actual lifetime of the data.
In particular, for the duration of this lifetime, the memory the pointer points to must
not get mutated (except inside <code>UnsafeCell</code>).</p>
</li>
</ul>
<p class="translate-text">即使此方法的结果未使用，这也适用！</p><p>This applies even if the result of this method is unused!</p>
<p class="translate-text">另请参阅 slice::from_raw_parts。</p><p>See also <a href="slice/fn.from_raw_parts.html" title="slice::from_raw_parts"><code>slice::from_raw_parts</code></a>.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open=""><summary><div id="impl-3" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/ptr/mut_ptr.rs.html#1157-1331" title="goto source code">[src]</a></div><a href="#impl-3" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="primitive" href="primitive.pointer.html">*mut </a><a class="primitive" href="primitive.slice.html">[</a>T<a class="primitive" href="primitive.slice.html">]</a></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.len-1" class="method has-srclink"><div class="rightside"><a class="srclink" href="../src/core/ptr/mut_ptr.rs.html#1177" title="goto source code">[src]</a></div><a href="#method.len-1" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.len-1" class="fnname">len</a>(self) -&gt; <a class="primitive" href="primitive.usize.html">usize</a></h4></div><div class="item-info"><div class="stab unstable"><span class="emoji">🔬</span> This is a nightly-only experimental API. (<code>slice_ptr_len</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/71146">#71146</a>)</div></div></summary><div class="docblock" xpath="/html[1]/body[1]/section[1]/details[5]/div[1]/details[1]/div[1]" istranslationnode="true" main_mp="Y25yZD4/dHFyOzpscXFbdWRjKis+eGFhMEpETC4veHBO"><p class="translate-text">返回原始切片的长度。</p><p>Returns the length of a raw slice.</p>
<p class="translate-text">返回值是元素的数量，而不是字节数。</p><p>The returned value is the number of <strong>elements</strong>, not the number of bytes.</p>
<p class="translate-text">此函数是安全的，即使由于指针为空或未对齐而无法将原始切片转换为切片引用。</p><p>This function is safe, even when the raw slice cannot be cast to a slice
reference because the pointer is null or unaligned.</p>
<h1 id="examples-28" class="section-header"><a href="#examples-28">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attribute">#![<span class="ident">feature</span>(<span class="ident">slice_ptr_len</span>)]</span>
<span class="kw">use</span> <span class="ident">std::ptr</span>;

<span class="kw">let</span> <span class="ident">slice</span>: <span class="kw-2">*</span><span class="kw-2">mut</span> [<span class="ident">i8</span>] <span class="op">=</span> <span class="ident">ptr::slice_from_raw_parts_mut</span>(<span class="ident">ptr::null_mut</span>(), <span class="number">3</span>);
<span class="macro">assert_eq!</span>(<span class="ident">slice</span>.<span class="ident">len</span>(), <span class="number">3</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(slice_ptr_len)%5D%0Afn%20main()%20%7B%0Ause%20std%3A%3Aptr%3B%0A%0Alet%20slice%3A%20*mut%20%5Bi8%5D%20%3D%20ptr%3A%3Aslice_from_raw_parts_mut(ptr%3A%3Anull_mut()%2C%203)%3B%0Aassert_eq!(slice.len()%2C%203)%3B%0A%7D&amp;version=nightly&amp;edition=2018">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.as_mut_ptr" class="method has-srclink"><div class="rightside"><a class="srclink" href="../src/core/ptr/mut_ptr.rs.html#1197" title="goto source code">[src]</a></div><a href="#method.as_mut_ptr" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.as_mut_ptr" class="fnname">as_mut_ptr</a>(self) -&gt; <a class="primitive" href="primitive.pointer.html">*mut T</a></h4></div><div class="item-info"><div class="stab unstable"><span class="emoji">🔬</span> This is a nightly-only experimental API. (<code>slice_ptr_get</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/74265">#74265</a>)</div></div></summary><div class="docblock" xpath="/html[1]/body[1]/section[1]/details[5]/div[1]/details[2]/div[1]" istranslationnode="true" main_mp="Y25yZD4/dHFyOzpscXFbdWRjKis+eGFhMEpETC4vdWZ/TFVVe1VQVw=="><p class="translate-text">返回指向切片缓冲区的原始指针。</p><p>Returns a raw pointer to the slice’s buffer.</p>
<p class="translate-text">这相当于将 self 转换为 *mut T，但更安全。</p><p>This is equivalent to casting <code>self</code> to <code>*mut T</code>, but more type-safe.</p>
<h1 id="examples-29" class="section-header"><a href="#examples-29">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attribute">#![<span class="ident">feature</span>(<span class="ident">slice_ptr_get</span>)]</span>
<span class="kw">use</span> <span class="ident">std::ptr</span>;

<span class="kw">let</span> <span class="ident">slice</span>: <span class="kw-2">*</span><span class="kw-2">mut</span> [<span class="ident">i8</span>] <span class="op">=</span> <span class="ident">ptr::slice_from_raw_parts_mut</span>(<span class="ident">ptr::null_mut</span>(), <span class="number">3</span>);
<span class="macro">assert_eq!</span>(<span class="ident">slice</span>.<span class="ident">as_mut_ptr</span>(), <span class="number">0</span> <span class="kw">as</span> <span class="kw-2">*</span><span class="kw-2">mut</span> <span class="ident">i8</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(slice_ptr_get)%5D%0Afn%20main()%20%7B%0Ause%20std%3A%3Aptr%3B%0A%0Alet%20slice%3A%20*mut%20%5Bi8%5D%20%3D%20ptr%3A%3Aslice_from_raw_parts_mut(ptr%3A%3Anull_mut()%2C%203)%3B%0Aassert_eq!(slice.as_mut_ptr()%2C%200%20as%20*mut%20i8)%3B%0A%7D&amp;version=nightly&amp;edition=2018">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.get_unchecked_mut" class="method has-srclink"><div class="rightside"><a class="srclink" href="../src/core/ptr/mut_ptr.rs.html#1222-1224" title="goto source code">[src]</a></div><a href="#method.get_unchecked_mut" class="anchor"></a><h4 class="code-header">pub unsafe fn <a href="#method.get_unchecked_mut" class="fnname">get_unchecked_mut</a>&lt;I&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;index: I<br>) -&gt; <a class="primitive" href="primitive.pointer.html">*mut </a>&lt;I as <a class="trait" href="slice/trait.SliceIndex.html" title="trait std::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.slice.html">[</a>T<a class="primitive" href="primitive.slice.html">]</a>&gt;&gt;::<a class="type" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type std::slice::SliceIndex::Output">Output</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;I: <a class="trait" href="slice/trait.SliceIndex.html" title="trait std::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.slice.html">[</a>T<a class="primitive" href="primitive.slice.html">]</a>&gt;,&nbsp;</span></h4></div><div class="item-info"><div class="stab unstable"><span class="emoji">🔬</span> This is a nightly-only experimental API. (<code>slice_ptr_get</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/74265">#74265</a>)</div></div></summary><div class="docblock" xpath="/html[1]/body[1]/section[1]/details[5]/div[1]/details[3]/div[1]" istranslationnode="true" main_mp="Y25yZD4/dHFyOzpscXFbdWRjKis+eGFhMEpETC4vc3BUflVPR01BRktERH5JUFA="><p class="translate-text">返回指向元素或子切片的原始指针，而不进行边界检查。</p><p>Returns a raw pointer to an element or subslice, without doing bounds
checking.</p>
<p class="translate-text">即使未使用结果指针，使用越界索引或当 self 不可取消引用时调用此方法也是未定义的行为。</p><p>Calling this method with an out-of-bounds index or when <code>self</code> is not dereferencable
is <em><a href="https://doc.rust-lang.org/reference/behavior-considered-undefined.html">undefined behavior</a></em> even if the resulting pointer is not used.</p>
<h1 id="examples-30" class="section-header"><a href="#examples-30">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attribute">#![<span class="ident">feature</span>(<span class="ident">slice_ptr_get</span>)]</span>

<span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="kw-2">mut</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>] <span class="kw">as</span> <span class="kw-2">*</span><span class="kw-2">mut</span> [<span class="ident">i32</span>];

<span class="kw">unsafe</span> {
    <span class="macro">assert_eq!</span>(<span class="ident">x</span>.<span class="ident">get_unchecked_mut</span>(<span class="number">1</span>), <span class="ident">x</span>.<span class="ident">as_mut_ptr</span>().<span class="ident">add</span>(<span class="number">1</span>));
}</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(slice_ptr_get)%5D%0A%0Afn%20main()%20%7B%0Alet%20x%20%3D%20%26mut%20%5B1%2C%202%2C%204%5D%20as%20*mut%20%5Bi32%5D%3B%0A%0Aunsafe%20%7B%0A%20%20%20%20assert_eq!(x.get_unchecked_mut(1)%2C%20x.as_mut_ptr().add(1))%3B%0A%7D%0A%7D&amp;version=nightly&amp;edition=2018">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.as_uninit_slice-1" class="method has-srclink"><div class="rightside"><a class="srclink" href="../src/core/ptr/mut_ptr.rs.html#1272" title="goto source code">[src]</a></div><a href="#method.as_uninit_slice-1" class="anchor"></a><h4 class="code-header">pub unsafe fn <a href="#method.as_uninit_slice-1" class="fnname">as_uninit_slice</a>&lt;'a&gt;(self) -&gt; <a class="enum" href="option/enum.Option.html" title="enum std::option::Option">Option</a>&lt;<a class="primitive" href="primitive.slice.html">&amp;'a [</a><a class="union" href="mem/union.MaybeUninit.html" title="union std::mem::MaybeUninit">MaybeUninit</a>&lt;T&gt;<a class="primitive" href="primitive.slice.html">]</a>&gt;</h4></div><div class="item-info"><div class="stab unstable"><span class="emoji">🔬</span> This is a nightly-only experimental API. (<code>ptr_as_uninit</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/75402">#75402</a>)</div></div></summary><div class="docblock" xpath="/html[1]/body[1]/section[1]/details[5]/div[1]/details[4]/div[1]" istranslationnode="true" main_mp="Y25yZD4/dHFyOzpscXFbdWRjKis+eGFhMEpETC4vdWZ/VE5ISkxQelNNSUJB"><p class="translate-text">如果指针为 null，则返回 None，否则将共享切片返回到 Some 中包装的值。 与 as_ref 相比，这不需要初始化值。</p><p>Returns <code>None</code> if the pointer is null, or else returns a shared slice to
the value wrapped in <code>Some</code>. In contrast to <a href="#method.as_ref-1"><code>as_ref</code></a>, this does not require
that the value has to be initialized.</p>
<p class="translate-text">对于可变对应物，请参见 as_uninit_slice_mut。</p><p>For the mutable counterpart see <a href="#method.as_uninit_slice_mut"><code>as_uninit_slice_mut</code></a>.</p>
<h1 id="safety-21" class="section-header"><a href="#safety-21">Safety</a></h1>
<p class="translate-text">调用此方法时，您必须确保指针为空或以下所有条件都为真：</p><p>When calling this method, you have to ensure that <em>either</em> the pointer is null <em>or</em>
all of the following is true:</p>
<ul>
<li class="translate-text">该指针必须对 ptr.len() * mem::size_of::<t>() 多个字节的读取有效，并且必须正确对齐。 这尤其意味着：</t></li><li>
<p>The pointer must be <a href="ptr/index.html#safety">valid</a> for reads for <code>ptr.len() * mem::size_of::&lt;T&gt;()</code> many bytes,
and it must be properly aligned. This means in particular:</p>
<ul>
<li class="translate-text">该切片的整个内存范围必须包含在单个分配的对象中！ 切片永远不能跨越多个分配的对象。</li><li>
<p>The entire memory range of this slice must be contained within a single <a href="ptr/index.html#allocated-object">allocated object</a>!
Slices can never span across multiple allocated objects.</p>
</li>
<li class="translate-text">即使对于零长度切片，指针也必须对齐。 这样做的一个原因是枚举布局优化可能依赖于对齐的引用（包括任何长度的切片）和非空值，以将它们与其他数据区分开来。 您可以使用 NonNull::dangling() 获得可用作零长度切片数据的指针。</li><li>
<p>The pointer must be aligned even for zero-length slices. One
reason for this is that enum layout optimizations may rely on references
(including slices of any length) being aligned and non-null to distinguish
them from other data. You can obtain a pointer that is usable as <code>data</code>
for zero-length slices using <a href="ptr/struct.NonNull.html#method.dangling" title="NonNull::dangling()"><code>NonNull::dangling()</code></a>.</p>
</li>
</ul>
</li>
<li class="translate-text">切片的总大小 ptr.len() * mem::size_of::<t>() 必须不大于 isize::MAX。 请参阅pointer::offset 的安全文档。</t></li><li>
<p>The total size <code>ptr.len() * mem::size_of::&lt;T&gt;()</code> of the slice must be no larger than <code>isize::MAX</code>.
See the safety documentation of <a href="primitive.pointer.html#method.offset" title="pointer::offset"><code>pointer::offset</code></a>.</p>
</li>
<li class="translate-text">您必须强制执行 Rust 的别名规则，因为返回的生命周期 'a 是任意选择的，不一定反映数据的实际生命周期。 特别是，在此生命周期内，指针指向的内存不得发生可变（UnsafeCell 内除外）。</li><li>
<p>You must enforce Rust’s aliasing rules, since the returned lifetime <code>'a</code> is
arbitrarily chosen and does not necessarily reflect the actual lifetime of the data.
In particular, for the duration of this lifetime, the memory the pointer points to must
not get mutated (except inside <code>UnsafeCell</code>).</p>
</li>
</ul>
<p class="translate-text">即使此方法的结果未使用，这也适用！</p><p>This applies even if the result of this method is unused!</p>
<p class="translate-text">另请参阅 slice::from_raw_parts。</p><p>See also <a href="slice/fn.from_raw_parts.html" title="slice::from_raw_parts"><code>slice::from_raw_parts</code></a>.</p>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.as_uninit_slice_mut" class="method has-srclink"><div class="rightside"><a class="srclink" href="../src/core/ptr/mut_ptr.rs.html#1323" title="goto source code">[src]</a></div><a href="#method.as_uninit_slice_mut" class="anchor"></a><h4 class="code-header">pub unsafe fn <a href="#method.as_uninit_slice_mut" class="fnname">as_uninit_slice_mut</a>&lt;'a&gt;(self) -&gt; <a class="enum" href="option/enum.Option.html" title="enum std::option::Option">Option</a>&lt;<a class="primitive" href="primitive.slice.html">&amp;'a mut [</a><a class="union" href="mem/union.MaybeUninit.html" title="union std::mem::MaybeUninit">MaybeUninit</a>&lt;T&gt;<a class="primitive" href="primitive.slice.html">]</a>&gt;</h4></div><div class="item-info"><div class="stab unstable"><span class="emoji">🔬</span> This is a nightly-only experimental API. (<code>ptr_as_uninit</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/75402">#75402</a>)</div></div></summary><div class="docblock" xpath="/html[1]/body[1]/section[1]/details[5]/div[1]/details[5]/div[1]" istranslationnode="true" main_mp="Y25yZD4/dHFyOzpscXFbdWRjKis+eGFhMEpETC4vdWZ/VE5ISkxQelNNSUJBeklQRA=="><p class="translate-text">如果指针为 null，则返回 None，否则返回一个唯一切片到 Some 中包装的值。 与 as_mut 不同，这不需要初始化值。</p><p>Returns <code>None</code> if the pointer is null, or else returns a unique slice to
the value wrapped in <code>Some</code>. In contrast to <a href="#method.as_mut"><code>as_mut</code></a>, this does not require
that the value has to be initialized.</p>
<p class="translate-text">对于共享副本，请参见 as_uninit_slice。</p><p>For the shared counterpart see <a href="#method.as_uninit_slice-1"><code>as_uninit_slice</code></a>.</p>
<h1 id="safety-22" class="section-header"><a href="#safety-22">Safety</a></h1>
<p class="translate-text">调用此方法时，您必须确保指针为空或以下所有条件都为真：</p><p>When calling this method, you have to ensure that <em>either</em> the pointer is null <em>or</em>
all of the following is true:</p>
<ul>
<li class="translate-text">指针必须对 ptr.len() * mem::size_of::<t>() 多个字节的读取和写入有效，并且必须正确对齐。 这尤其意味着：</t></li><li>
<p>The pointer must be <a href="ptr/index.html#safety">valid</a> for reads and writes for <code>ptr.len() * mem::size_of::&lt;T&gt;()</code>
many bytes, and it must be properly aligned. This means in particular:</p>
<ul>
<li class="translate-text">该切片的整个内存范围必须包含在单个分配的对象中！ 切片永远不能跨越多个分配的对象。</li><li>
<p>The entire memory range of this slice must be contained within a single <a href="ptr/index.html#allocated-object">allocated object</a>!
Slices can never span across multiple allocated objects.</p>
</li>
<li class="translate-text">即使对于零长度切片，指针也必须对齐。 这样做的一个原因是枚举布局优化可能依赖于对齐的引用（包括任何长度的切片）和非空值，以将它们与其他数据区分开来。 您可以使用 NonNull::dangling() 获得可用作零长度切片数据的指针。</li><li>
<p>The pointer must be aligned even for zero-length slices. One
reason for this is that enum layout optimizations may rely on references
(including slices of any length) being aligned and non-null to distinguish
them from other data. You can obtain a pointer that is usable as <code>data</code>
for zero-length slices using <a href="ptr/struct.NonNull.html#method.dangling" title="NonNull::dangling()"><code>NonNull::dangling()</code></a>.</p>
</li>
</ul>
</li>
<li class="translate-text">切片的总大小 ptr.len() * mem::size_of::<t>() 必须不大于 isize::MAX。 请参阅pointer::offset 的安全文档。</t></li><li>
<p>The total size <code>ptr.len() * mem::size_of::&lt;T&gt;()</code> of the slice must be no larger than <code>isize::MAX</code>.
See the safety documentation of <a href="primitive.pointer.html#method.offset" title="pointer::offset"><code>pointer::offset</code></a>.</p>
</li>
<li class="translate-text">您必须强制执行 Rust 的别名规则，因为返回的生命周期 'a 是任意选择的，不一定反映数据的实际生命周期。 特别是，在此生命周期内，指针指向的内存不得通过任何其他指针访问（读取或写入）。</li><li>
<p>You must enforce Rust’s aliasing rules, since the returned lifetime <code>'a</code> is
arbitrarily chosen and does not necessarily reflect the actual lifetime of the data.
In particular, for the duration of this lifetime, the memory the pointer points to must
not get accessed (read or written) through any other pointer.</p>
</li>
</ul>
<p class="translate-text">即使此方法的结果未使用，这也适用！</p><p>This applies even if the result of this method is unused!</p>
<p class="translate-text">另见 slice::from_raw_parts mut。</p><p>See also <a href="slice/fn.from_raw_parts_mut.html" title="slice::from_raw_parts_mut"><code>slice::from_raw_parts_mut</code></a>.</p>
</div></details></div></details><h2 id="trait-implementations" class="small-section-header">Trait Implementations<a href="#trait-implementations" class="anchor"></a></h2><div id="trait-implementations-list"><details class="rustdoc-toggle implementors-toggle" open=""><summary><div id="impl-Clone" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/clone.rs.html#207-212" title="goto source code">[src]</a></div><a href="#impl-Clone" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="clone/trait.Clone.html" title="trait std::clone::Clone">Clone</a> for <a class="primitive" href="primitive.pointer.html">*const T</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,&nbsp;</span></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.clone" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/clone.rs.html#209" title="goto source code">[src]</a></div><a href="#method.clone" class="anchor"></a><h4 class="code-header">pub fn <a href="clone/trait.Clone.html#tymethod.clone" class="fnname">clone</a>(&amp;self) -&gt; <a class="primitive" href="primitive.pointer.html">*const T</a></h4></div></summary><div class='docblock'><p>Returns a copy of the value. <a href="clone/trait.Clone.html#tymethod.clone">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.clone_from" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/clone.rs.html#130" title="goto source code">[src]</a></div><a href="#method.clone_from" class="anchor"></a><h4 class="code-header">fn <a href="clone/trait.Clone.html#method.clone_from" class="fnname">clone_from</a>(&amp;mut self, source: <a class="primitive" href="primitive.reference.html">&amp;</a>Self)</h4></div></summary><div class='docblock'><p>Performs copy-assignment from <code>source</code>. <a href="clone/trait.Clone.html#method.clone_from">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open=""><summary><div id="impl-Clone-1" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/clone.rs.html#215-220" title="goto source code">[src]</a></div><a href="#impl-Clone-1" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="clone/trait.Clone.html" title="trait std::clone::Clone">Clone</a> for <a class="primitive" href="primitive.pointer.html">*mut T</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,&nbsp;</span></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.clone-1" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/clone.rs.html#217" title="goto source code">[src]</a></div><a href="#method.clone-1" class="anchor"></a><h4 class="code-header">pub fn <a href="clone/trait.Clone.html#tymethod.clone" class="fnname">clone</a>(&amp;self) -&gt; <a class="primitive" href="primitive.pointer.html">*mut T</a></h4></div></summary><div class='docblock'><p>Returns a copy of the value. <a href="clone/trait.Clone.html#tymethod.clone">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.clone_from-1" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/clone.rs.html#130" title="goto source code">[src]</a></div><a href="#method.clone_from-1" class="anchor"></a><h4 class="code-header">fn <a href="clone/trait.Clone.html#method.clone_from" class="fnname">clone_from</a>(&amp;mut self, source: <a class="primitive" href="primitive.reference.html">&amp;</a>Self)</h4></div></summary><div class='docblock'><p>Performs copy-assignment from <code>source</code>. <a href="clone/trait.Clone.html#method.clone_from">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open=""><summary><div id="impl-Debug" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/fmt/mod.rs.html#2236-2240" title="goto source code">[src]</a></div><a href="#impl-Debug" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="fmt/trait.Debug.html" title="trait std::fmt::Debug">Debug</a> for <a class="primitive" href="primitive.pointer.html">*mut T</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,&nbsp;</span></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.fmt-2" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/fmt/mod.rs.html#2237" title="goto source code">[src]</a></div><a href="#method.fmt-2" class="anchor"></a><h4 class="code-header">pub fn <a href="fmt/trait.Debug.html#tymethod.fmt" class="fnname">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="fmt/struct.Formatter.html" title="struct std::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="enum" href="result/enum.Result.html" title="enum std::result::Result">Result</a>&lt;<a class="primitive" href="primitive.unit.html">()</a>, <a class="struct" href="fmt/struct.Error.html" title="struct std::fmt::Error">Error</a>&gt;</h4></div></summary><div class='docblock'><p>Formats the value using the given formatter. <a href="fmt/trait.Debug.html#tymethod.fmt">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open=""><summary><div id="impl-Debug-1" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/fmt/mod.rs.html#2230-2234" title="goto source code">[src]</a></div><a href="#impl-Debug-1" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="fmt/trait.Debug.html" title="trait std::fmt::Debug">Debug</a> for <a class="primitive" href="primitive.pointer.html">*const T</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,&nbsp;</span></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.fmt-3" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/fmt/mod.rs.html#2231" title="goto source code">[src]</a></div><a href="#method.fmt-3" class="anchor"></a><h4 class="code-header">pub fn <a href="fmt/trait.Debug.html#tymethod.fmt" class="fnname">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="fmt/struct.Formatter.html" title="struct std::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="enum" href="result/enum.Result.html" title="enum std::result::Result">Result</a>&lt;<a class="primitive" href="primitive.unit.html">()</a>, <a class="struct" href="fmt/struct.Error.html" title="struct std::fmt::Error">Error</a>&gt;</h4></div></summary><div class='docblock'><p>Formats the value using the given formatter. <a href="fmt/trait.Debug.html#tymethod.fmt">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open=""><summary><div id="impl-Hash" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/hash/mod.rs.html#776-783" title="goto source code">[src]</a></div><a href="#impl-Hash" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="hash/trait.Hash.html" title="trait std::hash::Hash">Hash</a> for <a class="primitive" href="primitive.pointer.html">*mut T</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,&nbsp;</span></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.hash" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/hash/mod.rs.html#778" title="goto source code">[src]</a></div><a href="#method.hash" class="anchor"></a><h4 class="code-header">pub fn <a href="hash/trait.Hash.html#tymethod.hash" class="fnname">hash</a>&lt;H&gt;(&amp;self, state: <a class="primitive" href="primitive.reference.html">&amp;mut </a>H) <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;H: <a class="trait" href="hash/trait.Hasher.html" title="trait std::hash::Hasher">Hasher</a>,&nbsp;</span></h4></div></summary><div class='docblock'><p>Feeds this value into the given <a href="hash/trait.Hasher.html" title="Hasher"><code>Hasher</code></a>. <a href="hash/trait.Hash.html#tymethod.hash">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.hash_slice" class="method trait-impl has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.3.0">1.3.0</span><a class="srclink" href="../src/core/hash/mod.rs.html#211-213" title="goto source code">[src]</a></div><a href="#method.hash_slice" class="anchor"></a><h4 class="code-header">fn <a href="hash/trait.Hash.html#method.hash_slice" class="fnname">hash_slice</a>&lt;H&gt;(data: <a class="primitive" href="primitive.slice.html">&amp;[Self]</a>, state: <a class="primitive" href="primitive.reference.html">&amp;mut </a>H) <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;H: <a class="trait" href="hash/trait.Hasher.html" title="trait std::hash::Hasher">Hasher</a>,&nbsp;</span></h4></div></summary><div class='docblock'><p>Feeds a slice of this type into the given <a href="hash/trait.Hasher.html" title="Hasher"><code>Hasher</code></a>. <a href="hash/trait.Hash.html#method.hash_slice">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open=""><summary><div id="impl-Hash-1" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/hash/mod.rs.html#766-773" title="goto source code">[src]</a></div><a href="#impl-Hash-1" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="hash/trait.Hash.html" title="trait std::hash::Hash">Hash</a> for <a class="primitive" href="primitive.pointer.html">*const T</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,&nbsp;</span></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.hash-1" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/hash/mod.rs.html#768" title="goto source code">[src]</a></div><a href="#method.hash-1" class="anchor"></a><h4 class="code-header">pub fn <a href="hash/trait.Hash.html#tymethod.hash" class="fnname">hash</a>&lt;H&gt;(&amp;self, state: <a class="primitive" href="primitive.reference.html">&amp;mut </a>H) <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;H: <a class="trait" href="hash/trait.Hasher.html" title="trait std::hash::Hasher">Hasher</a>,&nbsp;</span></h4></div></summary><div class='docblock'><p>Feeds this value into the given <a href="hash/trait.Hasher.html" title="Hasher"><code>Hasher</code></a>. <a href="hash/trait.Hash.html#tymethod.hash">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.hash_slice-1" class="method trait-impl has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.3.0">1.3.0</span><a class="srclink" href="../src/core/hash/mod.rs.html#211-213" title="goto source code">[src]</a></div><a href="#method.hash_slice-1" class="anchor"></a><h4 class="code-header">fn <a href="hash/trait.Hash.html#method.hash_slice" class="fnname">hash_slice</a>&lt;H&gt;(data: <a class="primitive" href="primitive.slice.html">&amp;[Self]</a>, state: <a class="primitive" href="primitive.reference.html">&amp;mut </a>H) <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;H: <a class="trait" href="hash/trait.Hasher.html" title="trait std::hash::Hasher">Hasher</a>,&nbsp;</span></h4></div></summary><div class='docblock'><p>Feeds a slice of this type into the given <a href="hash/trait.Hasher.html" title="Hasher"><code>Hasher</code></a>. <a href="hash/trait.Hash.html#method.hash_slice">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open=""><summary><div id="impl-Ord" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/ptr/mut_ptr.rs.html#1346-1357" title="goto source code">[src]</a></div><a href="#impl-Ord" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="cmp/trait.Ord.html" title="trait std::cmp::Ord">Ord</a> for <a class="primitive" href="primitive.pointer.html">*mut T</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,&nbsp;</span></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.cmp" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/ptr/mut_ptr.rs.html#1348" title="goto source code">[src]</a></div><a href="#method.cmp" class="anchor"></a><h4 class="code-header">pub fn <a href="cmp/trait.Ord.html#tymethod.cmp" class="fnname">cmp</a>(&amp;self, other: &amp;<a class="primitive" href="primitive.pointer.html">*mut T</a>) -&gt; <a class="enum" href="cmp/enum.Ordering.html" title="enum std::cmp::Ordering">Ordering</a></h4></div></summary><div class='docblock'><p>This method returns an <a href="cmp/enum.Ordering.html" title="Ordering"><code>Ordering</code></a> between <code>self</code> and <code>other</code>. <a href="cmp/trait.Ord.html#tymethod.cmp">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.max" class="method trait-impl has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.21.0">1.21.0</span><a class="srclink" href="../src/core/cmp.rs.html#763-765" title="goto source code">[src]</a></div><a href="#method.max" class="anchor"></a><h4 class="code-header">fn <a href="cmp/trait.Ord.html#method.max" class="fnname">max</a>(self, other: Self) -&gt; Self</h4></div></summary><div class='docblock'><p>Compares and returns the maximum of two values. <a href="cmp/trait.Ord.html#method.max">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.min" class="method trait-impl has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.21.0">1.21.0</span><a class="srclink" href="../src/core/cmp.rs.html#783-785" title="goto source code">[src]</a></div><a href="#method.min" class="anchor"></a><h4 class="code-header">fn <a href="cmp/trait.Ord.html#method.min" class="fnname">min</a>(self, other: Self) -&gt; Self</h4></div></summary><div class='docblock'><p>Compares and returns the minimum of two values. <a href="cmp/trait.Ord.html#method.min">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.clamp" class="method trait-impl has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.50.0">1.50.0</span><a class="srclink" href="../src/core/cmp.rs.html#808-810" title="goto source code">[src]</a></div><a href="#method.clamp" class="anchor"></a><h4 class="code-header">fn <a href="cmp/trait.Ord.html#method.clamp" class="fnname">clamp</a>(self, min: Self, max: Self) -&gt; Self</h4></div></summary><div class='docblock'><p>Restrict a value to a certain interval. <a href="cmp/trait.Ord.html#method.clamp">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open=""><summary><div id="impl-Ord-1" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/ptr/const_ptr.rs.html#1032-1043" title="goto source code">[src]</a></div><a href="#impl-Ord-1" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="cmp/trait.Ord.html" title="trait std::cmp::Ord">Ord</a> for <a class="primitive" href="primitive.pointer.html">*const T</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,&nbsp;</span></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.cmp-1" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/ptr/const_ptr.rs.html#1034" title="goto source code">[src]</a></div><a href="#method.cmp-1" class="anchor"></a><h4 class="code-header">pub fn <a href="cmp/trait.Ord.html#tymethod.cmp" class="fnname">cmp</a>(&amp;self, other: &amp;<a class="primitive" href="primitive.pointer.html">*const T</a>) -&gt; <a class="enum" href="cmp/enum.Ordering.html" title="enum std::cmp::Ordering">Ordering</a></h4></div></summary><div class='docblock'><p>This method returns an <a href="cmp/enum.Ordering.html" title="Ordering"><code>Ordering</code></a> between <code>self</code> and <code>other</code>. <a href="cmp/trait.Ord.html#tymethod.cmp">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.max-1" class="method trait-impl has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.21.0">1.21.0</span><a class="srclink" href="../src/core/cmp.rs.html#763-765" title="goto source code">[src]</a></div><a href="#method.max-1" class="anchor"></a><h4 class="code-header">fn <a href="cmp/trait.Ord.html#method.max" class="fnname">max</a>(self, other: Self) -&gt; Self</h4></div></summary><div class='docblock'><p>Compares and returns the maximum of two values. <a href="cmp/trait.Ord.html#method.max">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.min-1" class="method trait-impl has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.21.0">1.21.0</span><a class="srclink" href="../src/core/cmp.rs.html#783-785" title="goto source code">[src]</a></div><a href="#method.min-1" class="anchor"></a><h4 class="code-header">fn <a href="cmp/trait.Ord.html#method.min" class="fnname">min</a>(self, other: Self) -&gt; Self</h4></div></summary><div class='docblock'><p>Compares and returns the minimum of two values. <a href="cmp/trait.Ord.html#method.min">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.clamp-1" class="method trait-impl has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.50.0">1.50.0</span><a class="srclink" href="../src/core/cmp.rs.html#808-810" title="goto source code">[src]</a></div><a href="#method.clamp-1" class="anchor"></a><h4 class="code-header">fn <a href="cmp/trait.Ord.html#method.clamp" class="fnname">clamp</a>(self, min: Self, max: Self) -&gt; Self</h4></div></summary><div class='docblock'><p>Restrict a value to a certain interval. <a href="cmp/trait.Ord.html#method.clamp">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open=""><summary><div id="impl-PartialEq%3C*const%20T%3E" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/ptr/const_ptr.rs.html#1020-1025" title="goto source code">[src]</a></div><a href="#impl-PartialEq%3C*const%20T%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="cmp/trait.PartialEq.html" title="trait std::cmp::PartialEq">PartialEq</a>&lt;<a class="primitive" href="primitive.pointer.html">*const T</a>&gt; for <a class="primitive" href="primitive.pointer.html">*const T</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,&nbsp;</span></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.eq" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/ptr/const_ptr.rs.html#1022" title="goto source code">[src]</a></div><a href="#method.eq" class="anchor"></a><h4 class="code-header">pub fn <a href="cmp/trait.PartialEq.html#tymethod.eq" class="fnname">eq</a>(&amp;self, other: &amp;<a class="primitive" href="primitive.pointer.html">*const T</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></div></summary><div class='docblock'><p>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used
by <code>==</code>. <a href="cmp/trait.PartialEq.html#tymethod.eq">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.ne" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/cmp.rs.html#217" title="goto source code">[src]</a></div><a href="#method.ne" class="anchor"></a><h4 class="code-header">fn <a href="cmp/trait.PartialEq.html#method.ne" class="fnname">ne</a>(&amp;self, other: <a class="primitive" href="primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></div></summary><div class='docblock'><p>This method tests for <code>!=</code>.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open=""><summary><div id="impl-PartialEq%3C*mut%20T%3E" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/ptr/mut_ptr.rs.html#1335-1340" title="goto source code">[src]</a></div><a href="#impl-PartialEq%3C*mut%20T%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="cmp/trait.PartialEq.html" title="trait std::cmp::PartialEq">PartialEq</a>&lt;<a class="primitive" href="primitive.pointer.html">*mut T</a>&gt; for <a class="primitive" href="primitive.pointer.html">*mut T</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,&nbsp;</span></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.eq-1" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/ptr/mut_ptr.rs.html#1337" title="goto source code">[src]</a></div><a href="#method.eq-1" class="anchor"></a><h4 class="code-header">pub fn <a href="cmp/trait.PartialEq.html#tymethod.eq" class="fnname">eq</a>(&amp;self, other: &amp;<a class="primitive" href="primitive.pointer.html">*mut T</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></div></summary><div class='docblock'><p>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used
by <code>==</code>. <a href="cmp/trait.PartialEq.html#tymethod.eq">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.ne-1" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/cmp.rs.html#217" title="goto source code">[src]</a></div><a href="#method.ne-1" class="anchor"></a><h4 class="code-header">fn <a href="cmp/trait.PartialEq.html#method.ne" class="fnname">ne</a>(&amp;self, other: <a class="primitive" href="primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></div></summary><div class='docblock'><p>This method tests for <code>!=</code>.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open=""><summary><div id="impl-PartialOrd%3C*const%20T%3E" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/ptr/const_ptr.rs.html#1046-1071" title="goto source code">[src]</a></div><a href="#impl-PartialOrd%3C*const%20T%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="cmp/trait.PartialOrd.html" title="trait std::cmp::PartialOrd">PartialOrd</a>&lt;<a class="primitive" href="primitive.pointer.html">*const T</a>&gt; for <a class="primitive" href="primitive.pointer.html">*const T</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,&nbsp;</span></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.partial_cmp" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/ptr/const_ptr.rs.html#1048" title="goto source code">[src]</a></div><a href="#method.partial_cmp" class="anchor"></a><h4 class="code-header">pub fn <a href="cmp/trait.PartialOrd.html#tymethod.partial_cmp" class="fnname">partial_cmp</a>(&amp;self, other: &amp;<a class="primitive" href="primitive.pointer.html">*const T</a>) -&gt; <a class="enum" href="option/enum.Option.html" title="enum std::option::Option">Option</a>&lt;<a class="enum" href="cmp/enum.Ordering.html" title="enum std::cmp::Ordering">Ordering</a>&gt;</h4></div></summary><div class='docblock'><p>This method returns an ordering between <code>self</code> and <code>other</code> values if one exists. <a href="cmp/trait.PartialOrd.html#tymethod.partial_cmp">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.lt" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/ptr/const_ptr.rs.html#1053" title="goto source code">[src]</a></div><a href="#method.lt" class="anchor"></a><h4 class="code-header">pub fn <a href="cmp/trait.PartialOrd.html#method.lt" class="fnname">lt</a>(&amp;self, other: &amp;<a class="primitive" href="primitive.pointer.html">*const T</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></div></summary><div class='docblock'><p>This method tests less than (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;</code> operator. <a href="cmp/trait.PartialOrd.html#method.lt">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.le" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/ptr/const_ptr.rs.html#1058" title="goto source code">[src]</a></div><a href="#method.le" class="anchor"></a><h4 class="code-header">pub fn <a href="cmp/trait.PartialOrd.html#method.le" class="fnname">le</a>(&amp;self, other: &amp;<a class="primitive" href="primitive.pointer.html">*const T</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></div></summary><div class='docblock'><p>This method tests less than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;=</code>
operator. <a href="cmp/trait.PartialOrd.html#method.le">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.gt" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/ptr/const_ptr.rs.html#1063" title="goto source code">[src]</a></div><a href="#method.gt" class="anchor"></a><h4 class="code-header">pub fn <a href="cmp/trait.PartialOrd.html#method.gt" class="fnname">gt</a>(&amp;self, other: &amp;<a class="primitive" href="primitive.pointer.html">*const T</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></div></summary><div class='docblock'><p>This method tests greater than (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;</code> operator. <a href="cmp/trait.PartialOrd.html#method.gt">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.ge" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/ptr/const_ptr.rs.html#1068" title="goto source code">[src]</a></div><a href="#method.ge" class="anchor"></a><h4 class="code-header">pub fn <a href="cmp/trait.PartialOrd.html#method.ge" class="fnname">ge</a>(&amp;self, other: &amp;<a class="primitive" href="primitive.pointer.html">*const T</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></div></summary><div class='docblock'><p>This method tests greater than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;=</code>
operator. <a href="cmp/trait.PartialOrd.html#method.ge">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open=""><summary><div id="impl-PartialOrd%3C*mut%20T%3E" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/ptr/mut_ptr.rs.html#1360-1385" title="goto source code">[src]</a></div><a href="#impl-PartialOrd%3C*mut%20T%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="cmp/trait.PartialOrd.html" title="trait std::cmp::PartialOrd">PartialOrd</a>&lt;<a class="primitive" href="primitive.pointer.html">*mut T</a>&gt; for <a class="primitive" href="primitive.pointer.html">*mut T</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,&nbsp;</span></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.partial_cmp-1" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/ptr/mut_ptr.rs.html#1362" title="goto source code">[src]</a></div><a href="#method.partial_cmp-1" class="anchor"></a><h4 class="code-header">pub fn <a href="cmp/trait.PartialOrd.html#tymethod.partial_cmp" class="fnname">partial_cmp</a>(&amp;self, other: &amp;<a class="primitive" href="primitive.pointer.html">*mut T</a>) -&gt; <a class="enum" href="option/enum.Option.html" title="enum std::option::Option">Option</a>&lt;<a class="enum" href="cmp/enum.Ordering.html" title="enum std::cmp::Ordering">Ordering</a>&gt;</h4></div></summary><div class='docblock'><p>This method returns an ordering between <code>self</code> and <code>other</code> values if one exists. <a href="cmp/trait.PartialOrd.html#tymethod.partial_cmp">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.lt-1" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/ptr/mut_ptr.rs.html#1367" title="goto source code">[src]</a></div><a href="#method.lt-1" class="anchor"></a><h4 class="code-header">pub fn <a href="cmp/trait.PartialOrd.html#method.lt" class="fnname">lt</a>(&amp;self, other: &amp;<a class="primitive" href="primitive.pointer.html">*mut T</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></div></summary><div class='docblock'><p>This method tests less than (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;</code> operator. <a href="cmp/trait.PartialOrd.html#method.lt">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.le-1" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/ptr/mut_ptr.rs.html#1372" title="goto source code">[src]</a></div><a href="#method.le-1" class="anchor"></a><h4 class="code-header">pub fn <a href="cmp/trait.PartialOrd.html#method.le" class="fnname">le</a>(&amp;self, other: &amp;<a class="primitive" href="primitive.pointer.html">*mut T</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></div></summary><div class='docblock'><p>This method tests less than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;=</code>
operator. <a href="cmp/trait.PartialOrd.html#method.le">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.gt-1" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/ptr/mut_ptr.rs.html#1377" title="goto source code">[src]</a></div><a href="#method.gt-1" class="anchor"></a><h4 class="code-header">pub fn <a href="cmp/trait.PartialOrd.html#method.gt" class="fnname">gt</a>(&amp;self, other: &amp;<a class="primitive" href="primitive.pointer.html">*mut T</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></div></summary><div class='docblock'><p>This method tests greater than (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;</code> operator. <a href="cmp/trait.PartialOrd.html#method.gt">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.ge-1" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/ptr/mut_ptr.rs.html#1382" title="goto source code">[src]</a></div><a href="#method.ge-1" class="anchor"></a><h4 class="code-header">pub fn <a href="cmp/trait.PartialOrd.html#method.ge" class="fnname">ge</a>(&amp;self, other: &amp;<a class="primitive" href="primitive.pointer.html">*mut T</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></div></summary><div class='docblock'><p>This method tests greater than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;=</code>
operator. <a href="cmp/trait.PartialOrd.html#method.ge">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open=""><summary><div id="impl-Pointer" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/fmt/mod.rs.html#2207-2211" title="goto source code">[src]</a></div><a href="#impl-Pointer" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="fmt/trait.Pointer.html" title="trait std::fmt::Pointer">Pointer</a> for <a class="primitive" href="primitive.pointer.html">*mut T</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,&nbsp;</span></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.fmt" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/fmt/mod.rs.html#2208" title="goto source code">[src]</a></div><a href="#method.fmt" class="anchor"></a><h4 class="code-header">pub fn <a href="fmt/trait.Pointer.html#tymethod.fmt" class="fnname">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="fmt/struct.Formatter.html" title="struct std::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="enum" href="result/enum.Result.html" title="enum std::result::Result">Result</a>&lt;<a class="primitive" href="primitive.unit.html">()</a>, <a class="struct" href="fmt/struct.Error.html" title="struct std::fmt::Error">Error</a>&gt;</h4></div></summary><div class='docblock'><p>Formats the value using the given formatter.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open=""><summary><div id="impl-Pointer-1" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/fmt/mod.rs.html#2179-2204" title="goto source code">[src]</a></div><a href="#impl-Pointer-1" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="fmt/trait.Pointer.html" title="trait std::fmt::Pointer">Pointer</a> for <a class="primitive" href="primitive.pointer.html">*const T</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,&nbsp;</span></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.fmt-1" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/fmt/mod.rs.html#2180" title="goto source code">[src]</a></div><a href="#method.fmt-1" class="anchor"></a><h4 class="code-header">pub fn <a href="fmt/trait.Pointer.html#tymethod.fmt" class="fnname">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="fmt/struct.Formatter.html" title="struct std::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="enum" href="result/enum.Result.html" title="enum std::result::Result">Result</a>&lt;<a class="primitive" href="primitive.unit.html">()</a>, <a class="struct" href="fmt/struct.Error.html" title="struct std::fmt::Error">Error</a>&gt;</h4></div></summary><div class='docblock'><p>Formats the value using the given formatter.</p>
</div></details></div></details><div id="impl-CoerceUnsized%3C*const%20U%3E" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/ops/unsize.rs.html#65" title="goto source code">[src]</a></div><a href="#impl-CoerceUnsized%3C*const%20U%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, U&gt; <a class="trait" href="ops/trait.CoerceUnsized.html" title="trait std::ops::CoerceUnsized">CoerceUnsized</a>&lt;<a class="primitive" href="primitive.pointer.html">*const U</a>&gt; for <a class="primitive" href="primitive.pointer.html">*mut T</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="marker/trait.Unsize.html" title="trait std::marker::Unsize">Unsize</a>&lt;U&gt; + ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;U: ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,&nbsp;</span></h3></div><div id="impl-CoerceUnsized%3C*const%20U%3E-1" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/ops/unsize.rs.html#69" title="goto source code">[src]</a></div><a href="#impl-CoerceUnsized%3C*const%20U%3E-1" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, U&gt; <a class="trait" href="ops/trait.CoerceUnsized.html" title="trait std::ops::CoerceUnsized">CoerceUnsized</a>&lt;<a class="primitive" href="primitive.pointer.html">*const U</a>&gt; for <a class="primitive" href="primitive.pointer.html">*const T</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="marker/trait.Unsize.html" title="trait std::marker::Unsize">Unsize</a>&lt;U&gt; + ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;U: ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,&nbsp;</span></h3></div><div id="impl-CoerceUnsized%3C*mut%20U%3E" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/ops/unsize.rs.html#62" title="goto source code">[src]</a></div><a href="#impl-CoerceUnsized%3C*mut%20U%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, U&gt; <a class="trait" href="ops/trait.CoerceUnsized.html" title="trait std::ops::CoerceUnsized">CoerceUnsized</a>&lt;<a class="primitive" href="primitive.pointer.html">*mut U</a>&gt; for <a class="primitive" href="primitive.pointer.html">*mut T</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="marker/trait.Unsize.html" title="trait std::marker::Unsize">Unsize</a>&lt;U&gt; + ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;U: ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,&nbsp;</span></h3></div><div id="impl-Copy" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/marker.rs.html#829" title="goto source code">[src]</a></div><a href="#impl-Copy" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="marker/trait.Copy.html" title="trait std::marker::Copy">Copy</a> for <a class="primitive" href="primitive.pointer.html">*mut T</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,&nbsp;</span></h3></div><div id="impl-Copy-1" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/marker.rs.html#826" title="goto source code">[src]</a></div><a href="#impl-Copy-1" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="marker/trait.Copy.html" title="trait std::marker::Copy">Copy</a> for <a class="primitive" href="primitive.pointer.html">*const T</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,&nbsp;</span></h3></div><div id="impl-DispatchFromDyn%3C*const%20U%3E" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/ops/unsize.rs.html#98" title="goto source code">[src]</a></div><a href="#impl-DispatchFromDyn%3C*const%20U%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, U&gt; <a class="trait" href="ops/trait.DispatchFromDyn.html" title="trait std::ops::DispatchFromDyn">DispatchFromDyn</a>&lt;<a class="primitive" href="primitive.pointer.html">*const U</a>&gt; for <a class="primitive" href="primitive.pointer.html">*const T</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="marker/trait.Unsize.html" title="trait std::marker::Unsize">Unsize</a>&lt;U&gt; + ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;U: ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,&nbsp;</span></h3></div><div id="impl-DispatchFromDyn%3C*mut%20U%3E" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/ops/unsize.rs.html#101" title="goto source code">[src]</a></div><a href="#impl-DispatchFromDyn%3C*mut%20U%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, U&gt; <a class="trait" href="ops/trait.DispatchFromDyn.html" title="trait std::ops::DispatchFromDyn">DispatchFromDyn</a>&lt;<a class="primitive" href="primitive.pointer.html">*mut U</a>&gt; for <a class="primitive" href="primitive.pointer.html">*mut T</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="marker/trait.Unsize.html" title="trait std::marker::Unsize">Unsize</a>&lt;U&gt; + ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;U: ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,&nbsp;</span></h3></div><div id="impl-Eq" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/ptr/mut_ptr.rs.html#1343" title="goto source code">[src]</a></div><a href="#impl-Eq" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="cmp/trait.Eq.html" title="trait std::cmp::Eq">Eq</a> for <a class="primitive" href="primitive.pointer.html">*mut T</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,&nbsp;</span></h3></div><div id="impl-Eq-1" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/ptr/const_ptr.rs.html#1028" title="goto source code">[src]</a></div><a href="#impl-Eq-1" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="cmp/trait.Eq.html" title="trait std::cmp::Eq">Eq</a> for <a class="primitive" href="primitive.pointer.html">*const T</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,&nbsp;</span></h3></div><div id="impl-Send" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/marker.rs.html#45" title="goto source code">[src]</a></div><a href="#impl-Send" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; !<a class="trait" href="marker/trait.Send.html" title="trait std::marker::Send">Send</a> for <a class="primitive" href="primitive.pointer.html">*mut T</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,&nbsp;</span></h3></div><div id="impl-Send-1" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/marker.rs.html#43" title="goto source code">[src]</a></div><a href="#impl-Send-1" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; !<a class="trait" href="marker/trait.Send.html" title="trait std::marker::Send">Send</a> for <a class="primitive" href="primitive.pointer.html">*const T</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,&nbsp;</span></h3></div><div id="impl-Sync" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/marker.rs.html#484" title="goto source code">[src]</a></div><a href="#impl-Sync" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; !<a class="trait" href="marker/trait.Sync.html" title="trait std::marker::Sync">Sync</a> for <a class="primitive" href="primitive.pointer.html">*const T</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,&nbsp;</span></h3></div><div id="impl-Sync-1" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/marker.rs.html#486" title="goto source code">[src]</a></div><a href="#impl-Sync-1" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; !<a class="trait" href="marker/trait.Sync.html" title="trait std::marker::Sync">Sync</a> for <a class="primitive" href="primitive.pointer.html">*mut T</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,&nbsp;</span></h3></div><div id="impl-Unpin" class="impl has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.38.0">1.38.0</span><a class="srclink" href="../src/core/marker.rs.html#795" title="goto source code">[src]</a></div><a href="#impl-Unpin" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="marker/trait.Unpin.html" title="trait std::marker::Unpin">Unpin</a> for <a class="primitive" href="primitive.pointer.html">*mut T</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,&nbsp;</span></h3></div><div id="impl-Unpin-1" class="impl has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.38.0">1.38.0</span><a class="srclink" href="../src/core/marker.rs.html#792" title="goto source code">[src]</a></div><a href="#impl-Unpin-1" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="marker/trait.Unpin.html" title="trait std::marker::Unpin">Unpin</a> for <a class="primitive" href="primitive.pointer.html">*const T</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,&nbsp;</span></h3></div><div id="impl-UnwindSafe" class="impl has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.9.0">1.9.0</span><a class="srclink" href="../src/core/panic/unwind_safe.rs.html#185" title="goto source code">[src]</a></div><a href="#impl-UnwindSafe" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="panic/trait.UnwindSafe.html" title="trait std::panic::UnwindSafe">UnwindSafe</a> for <a class="primitive" href="primitive.pointer.html">*const T</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="panic/trait.RefUnwindSafe.html" title="trait std::panic::RefUnwindSafe">RefUnwindSafe</a> + ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,&nbsp;</span></h3></div><div id="impl-UnwindSafe-1" class="impl has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.9.0">1.9.0</span><a class="srclink" href="../src/core/panic/unwind_safe.rs.html#187" title="goto source code">[src]</a></div><a href="#impl-UnwindSafe-1" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="panic/trait.UnwindSafe.html" title="trait std::panic::UnwindSafe">UnwindSafe</a> for <a class="primitive" href="primitive.pointer.html">*mut T</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="panic/trait.RefUnwindSafe.html" title="trait std::panic::RefUnwindSafe">RefUnwindSafe</a> + ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,&nbsp;</span></h3></div></div><h2 id="synthetic-implementations" class="small-section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor"></a></h2><div id="synthetic-implementations-list"><div id="impl-RefUnwindSafe" class="impl has-srclink"><div class="rightside"></div><a href="#impl-RefUnwindSafe" class="anchor"></a><h3 class="code-header in-band">impl&lt;T:&nbsp;?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>&gt; <a class="trait" href="panic/trait.RefUnwindSafe.html" title="trait std::panic::RefUnwindSafe">RefUnwindSafe</a> for <a class="primitive" href="primitive.pointer.html">*const T</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="panic/trait.RefUnwindSafe.html" title="trait std::panic::RefUnwindSafe">RefUnwindSafe</a>,&nbsp;</span></h3></div><div id="impl-RefUnwindSafe-1" class="impl has-srclink"><div class="rightside"></div><a href="#impl-RefUnwindSafe-1" class="anchor"></a><h3 class="code-header in-band">impl&lt;T:&nbsp;?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>&gt; <a class="trait" href="panic/trait.RefUnwindSafe.html" title="trait std::panic::RefUnwindSafe">RefUnwindSafe</a> for <a class="primitive" href="primitive.pointer.html">*mut T</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="panic/trait.RefUnwindSafe.html" title="trait std::panic::RefUnwindSafe">RefUnwindSafe</a>,&nbsp;</span></h3></div><div id="impl-RefUnwindSafe-2" class="impl has-srclink"><div class="rightside"></div><a href="#impl-RefUnwindSafe-2" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="panic/trait.RefUnwindSafe.html" title="trait std::panic::RefUnwindSafe">RefUnwindSafe</a> for <a class="primitive" href="primitive.pointer.html">*const </a><a class="primitive" href="primitive.slice.html">[</a>T<a class="primitive" href="primitive.slice.html">]</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="panic/trait.RefUnwindSafe.html" title="trait std::panic::RefUnwindSafe">RefUnwindSafe</a>,&nbsp;</span></h3></div><div id="impl-RefUnwindSafe-3" class="impl has-srclink"><div class="rightside"></div><a href="#impl-RefUnwindSafe-3" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="panic/trait.RefUnwindSafe.html" title="trait std::panic::RefUnwindSafe">RefUnwindSafe</a> for <a class="primitive" href="primitive.pointer.html">*mut </a><a class="primitive" href="primitive.slice.html">[</a>T<a class="primitive" href="primitive.slice.html">]</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="panic/trait.RefUnwindSafe.html" title="trait std::panic::RefUnwindSafe">RefUnwindSafe</a>,&nbsp;</span></h3></div></div><h2 id="blanket-implementations" class="small-section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor"></a></h2><div id="blanket-implementations-list"><details class="rustdoc-toggle implementors-toggle" open=""><summary><div id="impl-Any" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/any.rs.html#132-136" title="goto source code">[src]</a></div><a href="#impl-Any" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="any/trait.Any.html" title="trait std::any::Any">Any</a> for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'static + ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,&nbsp;</span></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.type_id" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/any.rs.html#133" title="goto source code">[src]</a></div><a href="#method.type_id" class="anchor"></a><h4 class="code-header">pub fn <a href="any/trait.Any.html#tymethod.type_id" class="fnname">type_id</a>(&amp;self) -&gt; <a class="struct" href="any/struct.TypeId.html" title="struct std::any::TypeId">TypeId</a></h4></div></summary><div class='docblock'><p>Gets the <code>TypeId</code> of <code>self</code>. <a href="any/trait.Any.html#tymethod.type_id">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open=""><summary><div id="impl-Any-1" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/any.rs.html#132-136" title="goto source code">[src]</a></div><a href="#impl-Any-1" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="any/trait.Any.html" title="trait std::any::Any">Any</a> for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'static + ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,&nbsp;</span></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.type_id-1" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/any.rs.html#133" title="goto source code">[src]</a></div><a href="#method.type_id-1" class="anchor"></a><h4 class="code-header">pub fn <a href="any/trait.Any.html#tymethod.type_id" class="fnname">type_id</a>(&amp;self) -&gt; <a class="struct" href="any/struct.TypeId.html" title="struct std::any::TypeId">TypeId</a></h4></div></summary><div class='docblock'><p>Gets the <code>TypeId</code> of <code>self</code>. <a href="any/trait.Any.html#tymethod.type_id">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open=""><summary><div id="impl-Any-2" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/any.rs.html#132-136" title="goto source code">[src]</a></div><a href="#impl-Any-2" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="any/trait.Any.html" title="trait std::any::Any">Any</a> for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'static + ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,&nbsp;</span></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.type_id-2" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/any.rs.html#133" title="goto source code">[src]</a></div><a href="#method.type_id-2" class="anchor"></a><h4 class="code-header">pub fn <a href="any/trait.Any.html#tymethod.type_id" class="fnname">type_id</a>(&amp;self) -&gt; <a class="struct" href="any/struct.TypeId.html" title="struct std::any::TypeId">TypeId</a></h4></div></summary><div class='docblock'><p>Gets the <code>TypeId</code> of <code>self</code>. <a href="any/trait.Any.html#tymethod.type_id">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open=""><summary><div id="impl-Any-3" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/any.rs.html#132-136" title="goto source code">[src]</a></div><a href="#impl-Any-3" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="any/trait.Any.html" title="trait std::any::Any">Any</a> for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'static + ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,&nbsp;</span></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.type_id-3" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/any.rs.html#133" title="goto source code">[src]</a></div><a href="#method.type_id-3" class="anchor"></a><h4 class="code-header">pub fn <a href="any/trait.Any.html#tymethod.type_id" class="fnname">type_id</a>(&amp;self) -&gt; <a class="struct" href="any/struct.TypeId.html" title="struct std::any::TypeId">TypeId</a></h4></div></summary><div class='docblock'><p>Gets the <code>TypeId</code> of <code>self</code>. <a href="any/trait.Any.html#tymethod.type_id">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open=""><summary><div id="impl-Borrow%3CT%3E" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/borrow.rs.html#208-213" title="goto source code">[src]</a></div><a href="#impl-Borrow%3CT%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="borrow/trait.Borrow.html" title="trait std::borrow::Borrow">Borrow</a>&lt;T&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,&nbsp;</span></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.borrow" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/borrow.rs.html#210" title="goto source code">[src]</a></div><a href="#method.borrow" class="anchor"></a><h4 class="code-header">pub fn <a href="borrow/trait.Borrow.html#tymethod.borrow" class="fnname">borrow</a>(&amp;self) -&gt; <a class="primitive" href="primitive.reference.html">&amp;</a>T</h4></div></summary><div class='docblock'><p>Immutably borrows from an owned value. <a href="borrow/trait.Borrow.html#tymethod.borrow">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open=""><summary><div id="impl-Borrow%3CT%3E-1" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/borrow.rs.html#208-213" title="goto source code">[src]</a></div><a href="#impl-Borrow%3CT%3E-1" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="borrow/trait.Borrow.html" title="trait std::borrow::Borrow">Borrow</a>&lt;T&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,&nbsp;</span></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.borrow-1" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/borrow.rs.html#210" title="goto source code">[src]</a></div><a href="#method.borrow-1" class="anchor"></a><h4 class="code-header">pub fn <a href="borrow/trait.Borrow.html#tymethod.borrow" class="fnname">borrow</a>(&amp;self) -&gt; <a class="primitive" href="primitive.reference.html">&amp;</a>T</h4></div></summary><div class='docblock'><p>Immutably borrows from an owned value. <a href="borrow/trait.Borrow.html#tymethod.borrow">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open=""><summary><div id="impl-Borrow%3CT%3E-2" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/borrow.rs.html#208-213" title="goto source code">[src]</a></div><a href="#impl-Borrow%3CT%3E-2" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="borrow/trait.Borrow.html" title="trait std::borrow::Borrow">Borrow</a>&lt;T&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,&nbsp;</span></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.borrow-2" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/borrow.rs.html#210" title="goto source code">[src]</a></div><a href="#method.borrow-2" class="anchor"></a><h4 class="code-header">pub fn <a href="borrow/trait.Borrow.html#tymethod.borrow" class="fnname">borrow</a>(&amp;self) -&gt; <a class="primitive" href="primitive.reference.html">&amp;</a>T</h4></div></summary><div class='docblock'><p>Immutably borrows from an owned value. <a href="borrow/trait.Borrow.html#tymethod.borrow">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open=""><summary><div id="impl-Borrow%3CT%3E-3" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/borrow.rs.html#208-213" title="goto source code">[src]</a></div><a href="#impl-Borrow%3CT%3E-3" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="borrow/trait.Borrow.html" title="trait std::borrow::Borrow">Borrow</a>&lt;T&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,&nbsp;</span></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.borrow-3" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/borrow.rs.html#210" title="goto source code">[src]</a></div><a href="#method.borrow-3" class="anchor"></a><h4 class="code-header">pub fn <a href="borrow/trait.Borrow.html#tymethod.borrow" class="fnname">borrow</a>(&amp;self) -&gt; <a class="primitive" href="primitive.reference.html">&amp;</a>T</h4></div></summary><div class='docblock'><p>Immutably borrows from an owned value. <a href="borrow/trait.Borrow.html#tymethod.borrow">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open=""><summary><div id="impl-BorrowMut%3CT%3E" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/borrow.rs.html#216-220" title="goto source code">[src]</a></div><a href="#impl-BorrowMut%3CT%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="borrow/trait.BorrowMut.html" title="trait std::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,&nbsp;</span></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.borrow_mut" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/borrow.rs.html#217" title="goto source code">[src]</a></div><a href="#method.borrow_mut" class="anchor"></a><h4 class="code-header">pub fn <a href="borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fnname">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="primitive.reference.html">&amp;mut </a>T</h4></div></summary><div class='docblock'><p>Mutably borrows from an owned value. <a href="borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open=""><summary><div id="impl-BorrowMut%3CT%3E-1" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/borrow.rs.html#216-220" title="goto source code">[src]</a></div><a href="#impl-BorrowMut%3CT%3E-1" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="borrow/trait.BorrowMut.html" title="trait std::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,&nbsp;</span></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.borrow_mut-1" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/borrow.rs.html#217" title="goto source code">[src]</a></div><a href="#method.borrow_mut-1" class="anchor"></a><h4 class="code-header">pub fn <a href="borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fnname">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="primitive.reference.html">&amp;mut </a>T</h4></div></summary><div class='docblock'><p>Mutably borrows from an owned value. <a href="borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open=""><summary><div id="impl-BorrowMut%3CT%3E-2" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/borrow.rs.html#216-220" title="goto source code">[src]</a></div><a href="#impl-BorrowMut%3CT%3E-2" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="borrow/trait.BorrowMut.html" title="trait std::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,&nbsp;</span></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.borrow_mut-2" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/borrow.rs.html#217" title="goto source code">[src]</a></div><a href="#method.borrow_mut-2" class="anchor"></a><h4 class="code-header">pub fn <a href="borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fnname">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="primitive.reference.html">&amp;mut </a>T</h4></div></summary><div class='docblock'><p>Mutably borrows from an owned value. <a href="borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open=""><summary><div id="impl-BorrowMut%3CT%3E-3" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/borrow.rs.html#216-220" title="goto source code">[src]</a></div><a href="#impl-BorrowMut%3CT%3E-3" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="borrow/trait.BorrowMut.html" title="trait std::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,&nbsp;</span></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.borrow_mut-3" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/borrow.rs.html#217" title="goto source code">[src]</a></div><a href="#method.borrow_mut-3" class="anchor"></a><h4 class="code-header">pub fn <a href="borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fnname">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="primitive.reference.html">&amp;mut </a>T</h4></div></summary><div class='docblock'><p>Mutably borrows from an owned value. <a href="borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open=""><summary><div id="impl-From%3CT%3E" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/convert/mod.rs.html#546-550" title="goto source code">[src]</a></div><a href="#impl-From%3CT%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="convert/trait.From.html" title="trait std::convert::From">From</a>&lt;T&gt; for T</h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.from" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/convert/mod.rs.html#547" title="goto source code">[src]</a></div><a href="#method.from" class="anchor"></a><h4 class="code-header">pub fn <a href="convert/trait.From.html#tymethod.from" class="fnname">from</a>(t: T) -&gt; T</h4></div></summary><div class='docblock'><p>Performs the conversion.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open=""><summary><div id="impl-From%3CT%3E-1" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/convert/mod.rs.html#546-550" title="goto source code">[src]</a></div><a href="#impl-From%3CT%3E-1" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="convert/trait.From.html" title="trait std::convert::From">From</a>&lt;T&gt; for T</h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.from-1" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/convert/mod.rs.html#547" title="goto source code">[src]</a></div><a href="#method.from-1" class="anchor"></a><h4 class="code-header">pub fn <a href="convert/trait.From.html#tymethod.from" class="fnname">from</a>(t: T) -&gt; T</h4></div></summary><div class='docblock'><p>Performs the conversion.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open=""><summary><div id="impl-From%3CT%3E-2" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/convert/mod.rs.html#546-550" title="goto source code">[src]</a></div><a href="#impl-From%3CT%3E-2" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="convert/trait.From.html" title="trait std::convert::From">From</a>&lt;T&gt; for T</h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.from-2" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/convert/mod.rs.html#547" title="goto source code">[src]</a></div><a href="#method.from-2" class="anchor"></a><h4 class="code-header">pub fn <a href="convert/trait.From.html#tymethod.from" class="fnname">from</a>(t: T) -&gt; T</h4></div></summary><div class='docblock'><p>Performs the conversion.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open=""><summary><div id="impl-From%3CT%3E-3" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/convert/mod.rs.html#546-550" title="goto source code">[src]</a></div><a href="#impl-From%3CT%3E-3" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="convert/trait.From.html" title="trait std::convert::From">From</a>&lt;T&gt; for T</h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.from-3" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/convert/mod.rs.html#547" title="goto source code">[src]</a></div><a href="#method.from-3" class="anchor"></a><h4 class="code-header">pub fn <a href="convert/trait.From.html#tymethod.from" class="fnname">from</a>(t: T) -&gt; T</h4></div></summary><div class='docblock'><p>Performs the conversion.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open=""><summary><div id="impl-Into%3CU%3E" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/convert/mod.rs.html#535-542" title="goto source code">[src]</a></div><a href="#impl-Into%3CU%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, U&gt; <a class="trait" href="convert/trait.Into.html" title="trait std::convert::Into">Into</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="convert/trait.From.html" title="trait std::convert::From">From</a>&lt;T&gt;,&nbsp;</span></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.into" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/convert/mod.rs.html#539" title="goto source code">[src]</a></div><a href="#method.into" class="anchor"></a><h4 class="code-header">pub fn <a href="convert/trait.Into.html#tymethod.into" class="fnname">into</a>(self) -&gt; U</h4></div></summary><div class='docblock'><p>Performs the conversion.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open=""><summary><div id="impl-Into%3CU%3E-1" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/convert/mod.rs.html#535-542" title="goto source code">[src]</a></div><a href="#impl-Into%3CU%3E-1" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, U&gt; <a class="trait" href="convert/trait.Into.html" title="trait std::convert::Into">Into</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="convert/trait.From.html" title="trait std::convert::From">From</a>&lt;T&gt;,&nbsp;</span></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.into-1" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/convert/mod.rs.html#539" title="goto source code">[src]</a></div><a href="#method.into-1" class="anchor"></a><h4 class="code-header">pub fn <a href="convert/trait.Into.html#tymethod.into" class="fnname">into</a>(self) -&gt; U</h4></div></summary><div class='docblock'><p>Performs the conversion.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open=""><summary><div id="impl-Into%3CU%3E-2" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/convert/mod.rs.html#535-542" title="goto source code">[src]</a></div><a href="#impl-Into%3CU%3E-2" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, U&gt; <a class="trait" href="convert/trait.Into.html" title="trait std::convert::Into">Into</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="convert/trait.From.html" title="trait std::convert::From">From</a>&lt;T&gt;,&nbsp;</span></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.into-2" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/convert/mod.rs.html#539" title="goto source code">[src]</a></div><a href="#method.into-2" class="anchor"></a><h4 class="code-header">pub fn <a href="convert/trait.Into.html#tymethod.into" class="fnname">into</a>(self) -&gt; U</h4></div></summary><div class='docblock'><p>Performs the conversion.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open=""><summary><div id="impl-Into%3CU%3E-3" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/convert/mod.rs.html#535-542" title="goto source code">[src]</a></div><a href="#impl-Into%3CU%3E-3" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, U&gt; <a class="trait" href="convert/trait.Into.html" title="trait std::convert::Into">Into</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="convert/trait.From.html" title="trait std::convert::From">From</a>&lt;T&gt;,&nbsp;</span></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.into-3" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/convert/mod.rs.html#539" title="goto source code">[src]</a></div><a href="#method.into-3" class="anchor"></a><h4 class="code-header">pub fn <a href="convert/trait.Into.html#tymethod.into" class="fnname">into</a>(self) -&gt; U</h4></div></summary><div class='docblock'><p>Performs the conversion.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open=""><summary><div id="impl-ToOwned" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../src/alloc/borrow.rs.html#84-96" title="goto source code">[src]</a></div><a href="#impl-ToOwned" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="borrow/trait.ToOwned.html" title="trait std::borrow::ToOwned">ToOwned</a> for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="clone/trait.Clone.html" title="trait std::clone::Clone">Clone</a>,&nbsp;</span></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle" open=""><summary><div id="associatedtype.Owned" class="type trait-impl has-srclink"><a href="#associatedtype.Owned" class="anchor"></a><h4 class="code-header">type <a href="borrow/trait.ToOwned.html#associatedtype.Owned" class="type">Owned</a> = T</h4></div></summary><div class='docblock'><p>The resulting type after obtaining ownership.</p>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.to_owned" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/alloc/borrow.rs.html#89" title="goto source code">[src]</a></div><a href="#method.to_owned" class="anchor"></a><h4 class="code-header">pub fn <a href="borrow/trait.ToOwned.html#tymethod.to_owned" class="fnname">to_owned</a>(&amp;self) -&gt; T</h4></div></summary><div class='docblock'><p>Creates owned data from borrowed data, usually by cloning. <a href="borrow/trait.ToOwned.html#tymethod.to_owned">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.clone_into" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/alloc/borrow.rs.html#93" title="goto source code">[src]</a></div><a href="#method.clone_into" class="anchor"></a><h4 class="code-header">pub fn <a href="borrow/trait.ToOwned.html#method.clone_into" class="fnname">clone_into</a>(&amp;self, target: <a class="primitive" href="primitive.reference.html">&amp;mut </a>T)</h4></div></summary><div class="item-info"><div class="stab unstable"><details><summary><span class="emoji">🔬</span> This is a nightly-only experimental API. (<code>toowned_clone_into</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/41263">#41263</a>)</summary><p>recently added</p>
</details></div></div><div class='docblock'><p>Uses borrowed data to replace owned data, usually by cloning. <a href="borrow/trait.ToOwned.html#method.clone_into">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open=""><summary><div id="impl-ToOwned-1" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../src/alloc/borrow.rs.html#84-96" title="goto source code">[src]</a></div><a href="#impl-ToOwned-1" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="borrow/trait.ToOwned.html" title="trait std::borrow::ToOwned">ToOwned</a> for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="clone/trait.Clone.html" title="trait std::clone::Clone">Clone</a>,&nbsp;</span></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle" open=""><summary><div id="associatedtype.Owned-1" class="type trait-impl has-srclink"><a href="#associatedtype.Owned-1" class="anchor"></a><h4 class="code-header">type <a href="borrow/trait.ToOwned.html#associatedtype.Owned" class="type">Owned</a> = T</h4></div></summary><div class='docblock'><p>The resulting type after obtaining ownership.</p>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.to_owned-1" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/alloc/borrow.rs.html#89" title="goto source code">[src]</a></div><a href="#method.to_owned-1" class="anchor"></a><h4 class="code-header">pub fn <a href="borrow/trait.ToOwned.html#tymethod.to_owned" class="fnname">to_owned</a>(&amp;self) -&gt; T</h4></div></summary><div class='docblock'><p>Creates owned data from borrowed data, usually by cloning. <a href="borrow/trait.ToOwned.html#tymethod.to_owned">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.clone_into-1" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/alloc/borrow.rs.html#93" title="goto source code">[src]</a></div><a href="#method.clone_into-1" class="anchor"></a><h4 class="code-header">pub fn <a href="borrow/trait.ToOwned.html#method.clone_into" class="fnname">clone_into</a>(&amp;self, target: <a class="primitive" href="primitive.reference.html">&amp;mut </a>T)</h4></div></summary><div class="item-info"><div class="stab unstable"><details><summary><span class="emoji">🔬</span> This is a nightly-only experimental API. (<code>toowned_clone_into</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/41263">#41263</a>)</summary><p>recently added</p>
</details></div></div><div class='docblock'><p>Uses borrowed data to replace owned data, usually by cloning. <a href="borrow/trait.ToOwned.html#method.clone_into">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open=""><summary><div id="impl-ToOwned-2" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../src/alloc/borrow.rs.html#84-96" title="goto source code">[src]</a></div><a href="#impl-ToOwned-2" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="borrow/trait.ToOwned.html" title="trait std::borrow::ToOwned">ToOwned</a> for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="clone/trait.Clone.html" title="trait std::clone::Clone">Clone</a>,&nbsp;</span></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle" open=""><summary><div id="associatedtype.Owned-2" class="type trait-impl has-srclink"><a href="#associatedtype.Owned-2" class="anchor"></a><h4 class="code-header">type <a href="borrow/trait.ToOwned.html#associatedtype.Owned" class="type">Owned</a> = T</h4></div></summary><div class='docblock'><p>The resulting type after obtaining ownership.</p>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.to_owned-2" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/alloc/borrow.rs.html#89" title="goto source code">[src]</a></div><a href="#method.to_owned-2" class="anchor"></a><h4 class="code-header">pub fn <a href="borrow/trait.ToOwned.html#tymethod.to_owned" class="fnname">to_owned</a>(&amp;self) -&gt; T</h4></div></summary><div class='docblock'><p>Creates owned data from borrowed data, usually by cloning. <a href="borrow/trait.ToOwned.html#tymethod.to_owned">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.clone_into-2" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/alloc/borrow.rs.html#93" title="goto source code">[src]</a></div><a href="#method.clone_into-2" class="anchor"></a><h4 class="code-header">pub fn <a href="borrow/trait.ToOwned.html#method.clone_into" class="fnname">clone_into</a>(&amp;self, target: <a class="primitive" href="primitive.reference.html">&amp;mut </a>T)</h4></div></summary><div class="item-info"><div class="stab unstable"><details><summary><span class="emoji">🔬</span> This is a nightly-only experimental API. (<code>toowned_clone_into</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/41263">#41263</a>)</summary><p>recently added</p>
</details></div></div><div class='docblock'><p>Uses borrowed data to replace owned data, usually by cloning. <a href="borrow/trait.ToOwned.html#method.clone_into">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open=""><summary><div id="impl-ToOwned-3" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../src/alloc/borrow.rs.html#84-96" title="goto source code">[src]</a></div><a href="#impl-ToOwned-3" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="borrow/trait.ToOwned.html" title="trait std::borrow::ToOwned">ToOwned</a> for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="clone/trait.Clone.html" title="trait std::clone::Clone">Clone</a>,&nbsp;</span></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle" open=""><summary><div id="associatedtype.Owned-3" class="type trait-impl has-srclink"><a href="#associatedtype.Owned-3" class="anchor"></a><h4 class="code-header">type <a href="borrow/trait.ToOwned.html#associatedtype.Owned" class="type">Owned</a> = T</h4></div></summary><div class='docblock'><p>The resulting type after obtaining ownership.</p>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.to_owned-3" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/alloc/borrow.rs.html#89" title="goto source code">[src]</a></div><a href="#method.to_owned-3" class="anchor"></a><h4 class="code-header">pub fn <a href="borrow/trait.ToOwned.html#tymethod.to_owned" class="fnname">to_owned</a>(&amp;self) -&gt; T</h4></div></summary><div class='docblock'><p>Creates owned data from borrowed data, usually by cloning. <a href="borrow/trait.ToOwned.html#tymethod.to_owned">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.clone_into-3" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/alloc/borrow.rs.html#93" title="goto source code">[src]</a></div><a href="#method.clone_into-3" class="anchor"></a><h4 class="code-header">pub fn <a href="borrow/trait.ToOwned.html#method.clone_into" class="fnname">clone_into</a>(&amp;self, target: <a class="primitive" href="primitive.reference.html">&amp;mut </a>T)</h4></div></summary><div class="item-info"><div class="stab unstable"><details><summary><span class="emoji">🔬</span> This is a nightly-only experimental API. (<code>toowned_clone_into</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/41263">#41263</a>)</summary><p>recently added</p>
</details></div></div><div class='docblock'><p>Uses borrowed data to replace owned data, usually by cloning. <a href="borrow/trait.ToOwned.html#method.clone_into">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open=""><summary><div id="impl-TryFrom%3CU%3E" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/convert/mod.rs.html#583-592" title="goto source code">[src]</a></div><a href="#impl-TryFrom%3CU%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, U&gt; <a class="trait" href="convert/trait.TryFrom.html" title="trait std::convert::TryFrom">TryFrom</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="convert/trait.Into.html" title="trait std::convert::Into">Into</a>&lt;T&gt;,&nbsp;</span></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle" open=""><summary><div id="associatedtype.Error" class="type trait-impl has-srclink"><a href="#associatedtype.Error" class="anchor"></a><h4 class="code-header">type <a href="convert/trait.TryFrom.html#associatedtype.Error" class="type">Error</a> = <a class="enum" href="convert/enum.Infallible.html" title="enum std::convert::Infallible">Infallible</a></h4></div></summary><div class='docblock'><p>The type returned in the event of a conversion error.</p>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.try_from" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/convert/mod.rs.html#589" title="goto source code">[src]</a></div><a href="#method.try_from" class="anchor"></a><h4 class="code-header">pub fn <a href="convert/trait.TryFrom.html#tymethod.try_from" class="fnname">try_from</a>(value: U) -&gt; <a class="enum" href="result/enum.Result.html" title="enum std::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="convert/trait.TryFrom.html" title="trait std::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="type" href="convert/trait.TryFrom.html#associatedtype.Error" title="type std::convert::TryFrom::Error">Error</a>&gt;</h4></div></summary><div class='docblock'><p>Performs the conversion.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open=""><summary><div id="impl-TryFrom%3CU%3E-1" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/convert/mod.rs.html#583-592" title="goto source code">[src]</a></div><a href="#impl-TryFrom%3CU%3E-1" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, U&gt; <a class="trait" href="convert/trait.TryFrom.html" title="trait std::convert::TryFrom">TryFrom</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="convert/trait.Into.html" title="trait std::convert::Into">Into</a>&lt;T&gt;,&nbsp;</span></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle" open=""><summary><div id="associatedtype.Error-2" class="type trait-impl has-srclink"><a href="#associatedtype.Error-2" class="anchor"></a><h4 class="code-header">type <a href="convert/trait.TryFrom.html#associatedtype.Error" class="type">Error</a> = <a class="enum" href="convert/enum.Infallible.html" title="enum std::convert::Infallible">Infallible</a></h4></div></summary><div class='docblock'><p>The type returned in the event of a conversion error.</p>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.try_from-1" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/convert/mod.rs.html#589" title="goto source code">[src]</a></div><a href="#method.try_from-1" class="anchor"></a><h4 class="code-header">pub fn <a href="convert/trait.TryFrom.html#tymethod.try_from" class="fnname">try_from</a>(value: U) -&gt; <a class="enum" href="result/enum.Result.html" title="enum std::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="convert/trait.TryFrom.html" title="trait std::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="type" href="convert/trait.TryFrom.html#associatedtype.Error" title="type std::convert::TryFrom::Error">Error</a>&gt;</h4></div></summary><div class='docblock'><p>Performs the conversion.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open=""><summary><div id="impl-TryFrom%3CU%3E-2" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/convert/mod.rs.html#583-592" title="goto source code">[src]</a></div><a href="#impl-TryFrom%3CU%3E-2" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, U&gt; <a class="trait" href="convert/trait.TryFrom.html" title="trait std::convert::TryFrom">TryFrom</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="convert/trait.Into.html" title="trait std::convert::Into">Into</a>&lt;T&gt;,&nbsp;</span></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle" open=""><summary><div id="associatedtype.Error-4" class="type trait-impl has-srclink"><a href="#associatedtype.Error-4" class="anchor"></a><h4 class="code-header">type <a href="convert/trait.TryFrom.html#associatedtype.Error" class="type">Error</a> = <a class="enum" href="convert/enum.Infallible.html" title="enum std::convert::Infallible">Infallible</a></h4></div></summary><div class='docblock'><p>The type returned in the event of a conversion error.</p>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.try_from-2" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/convert/mod.rs.html#589" title="goto source code">[src]</a></div><a href="#method.try_from-2" class="anchor"></a><h4 class="code-header">pub fn <a href="convert/trait.TryFrom.html#tymethod.try_from" class="fnname">try_from</a>(value: U) -&gt; <a class="enum" href="result/enum.Result.html" title="enum std::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="convert/trait.TryFrom.html" title="trait std::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="type" href="convert/trait.TryFrom.html#associatedtype.Error" title="type std::convert::TryFrom::Error">Error</a>&gt;</h4></div></summary><div class='docblock'><p>Performs the conversion.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open=""><summary><div id="impl-TryFrom%3CU%3E-3" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/convert/mod.rs.html#583-592" title="goto source code">[src]</a></div><a href="#impl-TryFrom%3CU%3E-3" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, U&gt; <a class="trait" href="convert/trait.TryFrom.html" title="trait std::convert::TryFrom">TryFrom</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="convert/trait.Into.html" title="trait std::convert::Into">Into</a>&lt;T&gt;,&nbsp;</span></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle" open=""><summary><div id="associatedtype.Error-6" class="type trait-impl has-srclink"><a href="#associatedtype.Error-6" class="anchor"></a><h4 class="code-header">type <a href="convert/trait.TryFrom.html#associatedtype.Error" class="type">Error</a> = <a class="enum" href="convert/enum.Infallible.html" title="enum std::convert::Infallible">Infallible</a></h4></div></summary><div class='docblock'><p>The type returned in the event of a conversion error.</p>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.try_from-3" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/convert/mod.rs.html#589" title="goto source code">[src]</a></div><a href="#method.try_from-3" class="anchor"></a><h4 class="code-header">pub fn <a href="convert/trait.TryFrom.html#tymethod.try_from" class="fnname">try_from</a>(value: U) -&gt; <a class="enum" href="result/enum.Result.html" title="enum std::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="convert/trait.TryFrom.html" title="trait std::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="type" href="convert/trait.TryFrom.html#associatedtype.Error" title="type std::convert::TryFrom::Error">Error</a>&gt;</h4></div></summary><div class='docblock'><p>Performs the conversion.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open=""><summary><div id="impl-TryInto%3CU%3E" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/convert/mod.rs.html#569-578" title="goto source code">[src]</a></div><a href="#impl-TryInto%3CU%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, U&gt; <a class="trait" href="convert/trait.TryInto.html" title="trait std::convert::TryInto">TryInto</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="convert/trait.TryFrom.html" title="trait std::convert::TryFrom">TryFrom</a>&lt;T&gt;,&nbsp;</span></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle" open=""><summary><div id="associatedtype.Error-1" class="type trait-impl has-srclink"><a href="#associatedtype.Error-1" class="anchor"></a><h4 class="code-header">type <a href="convert/trait.TryInto.html#associatedtype.Error" class="type">Error</a> = &lt;U as <a class="trait" href="convert/trait.TryFrom.html" title="trait std::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="type" href="convert/trait.TryFrom.html#associatedtype.Error" title="type std::convert::TryFrom::Error">Error</a></h4></div></summary><div class='docblock'><p>The type returned in the event of a conversion error.</p>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.try_into" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/convert/mod.rs.html#575" title="goto source code">[src]</a></div><a href="#method.try_into" class="anchor"></a><h4 class="code-header">pub fn <a href="convert/trait.TryInto.html#tymethod.try_into" class="fnname">try_into</a>(self) -&gt; <a class="enum" href="result/enum.Result.html" title="enum std::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="convert/trait.TryFrom.html" title="trait std::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="type" href="convert/trait.TryFrom.html#associatedtype.Error" title="type std::convert::TryFrom::Error">Error</a>&gt;</h4></div></summary><div class='docblock'><p>Performs the conversion.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open=""><summary><div id="impl-TryInto%3CU%3E-1" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/convert/mod.rs.html#569-578" title="goto source code">[src]</a></div><a href="#impl-TryInto%3CU%3E-1" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, U&gt; <a class="trait" href="convert/trait.TryInto.html" title="trait std::convert::TryInto">TryInto</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="convert/trait.TryFrom.html" title="trait std::convert::TryFrom">TryFrom</a>&lt;T&gt;,&nbsp;</span></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle" open=""><summary><div id="associatedtype.Error-3" class="type trait-impl has-srclink"><a href="#associatedtype.Error-3" class="anchor"></a><h4 class="code-header">type <a href="convert/trait.TryInto.html#associatedtype.Error" class="type">Error</a> = &lt;U as <a class="trait" href="convert/trait.TryFrom.html" title="trait std::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="type" href="convert/trait.TryFrom.html#associatedtype.Error" title="type std::convert::TryFrom::Error">Error</a></h4></div></summary><div class='docblock'><p>The type returned in the event of a conversion error.</p>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.try_into-1" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/convert/mod.rs.html#575" title="goto source code">[src]</a></div><a href="#method.try_into-1" class="anchor"></a><h4 class="code-header">pub fn <a href="convert/trait.TryInto.html#tymethod.try_into" class="fnname">try_into</a>(self) -&gt; <a class="enum" href="result/enum.Result.html" title="enum std::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="convert/trait.TryFrom.html" title="trait std::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="type" href="convert/trait.TryFrom.html#associatedtype.Error" title="type std::convert::TryFrom::Error">Error</a>&gt;</h4></div></summary><div class='docblock'><p>Performs the conversion.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open=""><summary><div id="impl-TryInto%3CU%3E-2" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/convert/mod.rs.html#569-578" title="goto source code">[src]</a></div><a href="#impl-TryInto%3CU%3E-2" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, U&gt; <a class="trait" href="convert/trait.TryInto.html" title="trait std::convert::TryInto">TryInto</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="convert/trait.TryFrom.html" title="trait std::convert::TryFrom">TryFrom</a>&lt;T&gt;,&nbsp;</span></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle" open=""><summary><div id="associatedtype.Error-5" class="type trait-impl has-srclink"><a href="#associatedtype.Error-5" class="anchor"></a><h4 class="code-header">type <a href="convert/trait.TryInto.html#associatedtype.Error" class="type">Error</a> = &lt;U as <a class="trait" href="convert/trait.TryFrom.html" title="trait std::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="type" href="convert/trait.TryFrom.html#associatedtype.Error" title="type std::convert::TryFrom::Error">Error</a></h4></div></summary><div class='docblock'><p>The type returned in the event of a conversion error.</p>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.try_into-2" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/convert/mod.rs.html#575" title="goto source code">[src]</a></div><a href="#method.try_into-2" class="anchor"></a><h4 class="code-header">pub fn <a href="convert/trait.TryInto.html#tymethod.try_into" class="fnname">try_into</a>(self) -&gt; <a class="enum" href="result/enum.Result.html" title="enum std::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="convert/trait.TryFrom.html" title="trait std::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="type" href="convert/trait.TryFrom.html#associatedtype.Error" title="type std::convert::TryFrom::Error">Error</a>&gt;</h4></div></summary><div class='docblock'><p>Performs the conversion.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open=""><summary><div id="impl-TryInto%3CU%3E-3" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/convert/mod.rs.html#569-578" title="goto source code">[src]</a></div><a href="#impl-TryInto%3CU%3E-3" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, U&gt; <a class="trait" href="convert/trait.TryInto.html" title="trait std::convert::TryInto">TryInto</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="convert/trait.TryFrom.html" title="trait std::convert::TryFrom">TryFrom</a>&lt;T&gt;,&nbsp;</span></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle" open=""><summary><div id="associatedtype.Error-7" class="type trait-impl has-srclink"><a href="#associatedtype.Error-7" class="anchor"></a><h4 class="code-header">type <a href="convert/trait.TryInto.html#associatedtype.Error" class="type">Error</a> = &lt;U as <a class="trait" href="convert/trait.TryFrom.html" title="trait std::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="type" href="convert/trait.TryFrom.html#associatedtype.Error" title="type std::convert::TryFrom::Error">Error</a></h4></div></summary><div class='docblock'><p>The type returned in the event of a conversion error.</p>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.try_into-3" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/convert/mod.rs.html#575" title="goto source code">[src]</a></div><a href="#method.try_into-3" class="anchor"></a><h4 class="code-header">pub fn <a href="convert/trait.TryInto.html#tymethod.try_into" class="fnname">try_into</a>(self) -&gt; <a class="enum" href="result/enum.Result.html" title="enum std::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="convert/trait.TryFrom.html" title="trait std::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="type" href="convert/trait.TryFrom.html#associatedtype.Error" title="type std::convert::TryFrom::Error">Error</a>&gt;</h4></div></summary><div class='docblock'><p>Performs the conversion.</p>
</div></details></div></details></div></section><section id="search" class="content hidden"></section><div id="rustdoc-vars" data-root-path="../" data-current-crate="std" data-search-index-js="../search-index1.56.1.js" data-search-js="../search1.56.1.js"></div>
    <script src="../main1.56.1.js"></script>
</body></html>