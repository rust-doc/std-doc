<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="A raw pointer type which can be safely shared between threads."><meta name="keywords" content="rust, rustlang, rust-lang, AtomicPtr"><title>AtomicPtr in std::sync::atomic - Rust</title><link rel="stylesheet" type="text/css" href="../../../normalize1.58.0.css"><link rel="stylesheet" type="text/css" href="../../../rustdoc1.58.0.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../../light1.58.0.css" id="themeStyle"><link rel="stylesheet" type="text/css" href="../../../dark1.58.0.css" disabled=""><link rel="stylesheet" type="text/css" href="../../../ayu1.58.0.css" disabled=""><script id="default-settings"></script><script src="../../../storage1.58.0.js"></script><script src="../../../crates1.58.0.js"></script><script defer="" src="../../../main1.58.0.js"></script>
    <noscript><link rel="stylesheet" href="../../../noscript1.58.0.css"></noscript><link rel="alternate icon" type="image/png" href="../../../favicon-16x161.58.0.png"><link rel="alternate icon" type="image/png" href="../../../favicon-32x321.58.0.png"><link rel="icon" type="image/svg+xml" href="../../../favicon1.58.0.svg"><style type="text/css">#crate-search{background-image:url("../../../down-arrow1.58.0.svg");}</style></head><body class="rustdoc struct"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu" role="button">&#9776;</div><a href='../../../std/index.html'><div class='logo-container rust-logo'><img src='../../../rust-logo1.58.0.png' alt='logo'></div></a><h2 class="location">Struct AtomicPtr</h2><div class="sidebar-elems"><div class="block items"><h3 class="sidebar-title"><a href="#implementations">Methods</a></h3><div class="sidebar-links"><a href="#method.compare_and_swap">compare_and_swap</a><a href="#method.compare_exchange">compare_exchange</a><a href="#method.compare_exchange_weak">compare_exchange_weak</a><a href="#method.fetch_update">fetch_update</a><a href="#method.from_mut">from_mut</a><a href="#method.get_mut">get_mut</a><a href="#method.into_inner">into_inner</a><a href="#method.load">load</a><a href="#method.new">new</a><a href="#method.store">store</a><a href="#method.swap">swap</a></div><h3 class="sidebar-title"><a href="#trait-implementations">Trait Implementations</a></h3><div class="sidebar-links"><a href="#impl-Debug">Debug</a><a href="#impl-Default">Default</a><a href="#impl-From%3C*mut%20T%3E">From&lt;*mut T&gt;</a><a href="#impl-Pointer">Pointer</a><a href="#impl-RefUnwindSafe">RefUnwindSafe</a><a href="#impl-Send">Send</a><a href="#impl-Sync">Sync</a></div><h3 class="sidebar-title"><a href="#synthetic-implementations">Auto Trait Implementations</a></h3><div class="sidebar-links"><a href="#impl-Unpin">Unpin</a><a href="#impl-UnwindSafe">UnwindSafe</a></div><h3 class="sidebar-title"><a href="#blanket-implementations">Blanket Implementations</a></h3><div class="sidebar-links"><a href="#impl-Any">Any</a><a href="#impl-Borrow%3CT%3E">Borrow&lt;T&gt;</a><a href="#impl-BorrowMut%3CT%3E">BorrowMut&lt;T&gt;</a><a href="#impl-From%3CT%3E">From&lt;T&gt;</a><a href="#impl-Into%3CU%3E">Into&lt;U&gt;</a><a href="#impl-TryFrom%3CU%3E">TryFrom&lt;U&gt;</a><a href="#impl-TryInto%3CU%3E">TryInto&lt;U&gt;</a></div></div><h2 class="location">Other items in<br><a href="../../index.html">std</a>::<wbr><a href="../index.html">sync</a>::<wbr><a href="index.html">atomic</a></h2><div id="sidebar-vars" data-name="AtomicPtr" data-ty="struct" data-relpath=""></div><script defer="" src="sidebar-items.js"></script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu" title="themes"><img width="18" height="18" alt="Pick another theme!" src="../../../brush1.58.0.svg"></button><div id="theme-choices" role="menu"></div></div><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><button type="button" id="help-button" title="help">?</button><a id="settings-menu" href="../../../settings.html" title="settings"><img width="18" height="18" alt="Change settings" src="../../../wheel1.58.0.svg"></a></div></form></nav><section id="main" class="content"><h1 class="fqn"><span class="in-band">Struct <a href="../../index.html">std</a>::<wbr><a href="../index.html">sync</a>::<wbr><a href="index.html">atomic</a>::<wbr><a class="struct" href="#">AtomicPtr</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../../../clipboard1.58.0.svg" width="19" height="18" alt="Copy item path"></button></span><span class="out-of-band"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><span id="render-detail"><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span><a class="srclink" href="../../../src/core/sync/atomic.rs.html#166-168" title="goto source code">[src]</a></span></h1><div class="docblock item-decl"><pre class="rust struct"><code><div class="code-attribute">#[repr(C, align(8))]</div>pub struct AtomicPtr&lt;T&gt; { /* fields omitted */ }</code></pre></div><details class="rustdoc-toggle top-doc" open=""><summary class="hideme"><span>Expand description</span></summary><div class="docblock" xpath="/html[1]/body[1]/section[1]/details[1]/div[1]" istranslationnode="true" main_mp="Y25yZD4/d3xuYjo7ZXFraHlyKitVYXt4eXJAZWY=" sub_mp="[&quot;c3VkOz52fWtjOzpgcGppbHMrKlBgenl8c0FkYw==&quot;]"><p class="translate-text">可以在线程之间安全共享的原始指针类型。</p><p>A raw pointer type which can be safely shared between threads.</p>
<p class="translate-text">此类型与 `*mut T` 具有相同的内存表示。</p><p>This type has the same in-memory representation as a <code>*mut T</code>.</p>
<p class="translate-text">注意：此类型仅在支持原子加载和指针存储的平台上可用。 它的大小取决于目标指针的大小。</p><p><strong>Note</strong>: This type is only available on platforms that support atomic
loads and stores of pointers. Its size depends on the target pointer’s size.</p>
</div></details><h2 id="implementations" class="small-section-header">Implementations<a href="#implementations" class="anchor"></a></h2><details class="rustdoc-toggle implementors-toggle" open=""><summary><div id="impl" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../../../src/core/sync/atomic.rs.html#879-1272" title="goto source code">[src]</a></div><a href="#impl" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="struct" href="struct.AtomicPtr.html" title="struct std::sync::atomic::AtomicPtr">AtomicPtr</a>&lt;T&gt;</h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.new" class="method has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.0.0, const since 1.24.0">1.0.0 (const: 1.24.0)</span><a class="srclink" href="../../../src/core/sync/atomic.rs.html#893" title="goto source code">[src]</a></div><a href="#method.new" class="anchor"></a><h4 class="code-header">pub const fn <a href="#method.new" class="fnname">new</a>(p: <a class="primitive" href="../../primitive.pointer.html">*mut T</a>) -&gt; <a class="struct" href="struct.AtomicPtr.html" title="struct std::sync::atomic::AtomicPtr">AtomicPtr</a>&lt;T&gt;</h4></div></summary><div class="docblock" xpath="/html[1]/body[1]/section[1]/details[2]/div[1]/details[1]/div[1]" istranslationnode="true" main_mp="Y25yZD4/d3xuYjo7ZXFraHlyKitVYXt4eXJAZWYpQCsaG05EUw==" sub_mp="[&quot;c3VkOz52fWtjOzpgcGppbHMrKlBgenl8c0FkYyhBKi8aT0VW&quot;]"><p class="translate-text">创建一个新的 `AtomicPtr`。</p><p>Creates a new <code>AtomicPtr</code>.</p>
<h5 id="examples" class="section-header"><a href="#examples">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">std::sync::atomic::AtomicPtr</span>;

<span class="kw">let</span> <span class="ident">ptr</span> <span class="op">=</span> <span class="kw-2">&amp;mut</span> <span class="number">5</span>;
<span class="kw">let</span> <span class="ident">atomic_ptr</span>  <span class="op">=</span> <span class="ident">AtomicPtr::new</span>(<span class="ident">ptr</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Ause%20std%3A%3Async%3A%3Aatomic%3A%3AAtomicPtr%3B%0A%0Alet%20ptr%20%3D%20%26mut%205%3B%0Alet%20atomic_ptr%20%20%3D%20AtomicPtr%3A%3Anew(ptr)%3B%0A%7D&amp;edition=2018">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.get_mut" class="method has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.15.0">1.15.0</span><a class="srclink" href="../../../src/core/sync/atomic.rs.html#915" title="goto source code">[src]</a></div><a href="#method.get_mut" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.get_mut" class="fnname">get_mut</a>(&amp;mut self) -&gt; &amp;mut <a class="primitive" href="../../primitive.pointer.html">*mut T</a></h4></div></summary><div class="docblock" xpath="/html[1]/body[1]/section[1]/details[2]/div[1]/details[2]/div[1]" istranslationnode="true" main_mp="Y25yZD4/d3xuYjo7ZXFraHlyKitVYXt4eXJAZWYpQCsaG0dEUHpJUFQ=" sub_mp="[&quot;c3VkOz52fWtjOzpgcGppbHMrKlBgenl8c0FkYyhBKi8aRkVVe0hRUQ==&quot;]"><p class="translate-text">返回对基础指针的可变引用。</p><p>Returns a mutable reference to the underlying pointer.</p>
<p class="translate-text">这是安全的，因为可变引用保证没有其他线程同时访问原子数据。</p><p>This is safe because the mutable reference guarantees that no other threads are
concurrently accessing the atomic data.</p>
<h5 id="examples-1" class="section-header"><a href="#examples-1">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">std::sync::atomic</span>::{<span class="ident">AtomicPtr</span>, <span class="ident">Ordering</span>};

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">data</span> <span class="op">=</span> <span class="number">10</span>;
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">atomic_ptr</span> <span class="op">=</span> <span class="ident">AtomicPtr::new</span>(<span class="kw-2">&amp;mut</span> <span class="ident">data</span>);
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">other_data</span> <span class="op">=</span> <span class="number">5</span>;
<span class="kw-2">*</span><span class="ident">atomic_ptr</span>.<span class="ident">get_mut</span>() <span class="op">=</span> <span class="kw-2">&amp;mut</span> <span class="ident">other_data</span>;
<span class="macro">assert_eq!</span>(<span class="kw">unsafe</span> { <span class="kw-2">*</span><span class="ident">atomic_ptr</span>.<span class="ident">load</span>(<span class="ident">Ordering::SeqCst</span>) }, <span class="number">5</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Ause%20std%3A%3Async%3A%3Aatomic%3A%3A%7BAtomicPtr%2C%20Ordering%7D%3B%0A%0Alet%20mut%20data%20%3D%2010%3B%0Alet%20mut%20atomic_ptr%20%3D%20AtomicPtr%3A%3Anew(%26mut%20data)%3B%0Alet%20mut%20other_data%20%3D%205%3B%0A*atomic_ptr.get_mut()%20%3D%20%26mut%20other_data%3B%0Aassert_eq!(unsafe%20%7B%20*atomic_ptr.load(Ordering%3A%3ASeqCst)%20%7D%2C%205)%3B%0A%7D&amp;edition=2018">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.from_mut" class="method has-srclink"><div class="rightside"><a class="srclink" href="../../../src/core/sync/atomic.rs.html#937" title="goto source code">[src]</a></div><a href="#method.from_mut" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.from_mut" class="fnname">from_mut</a>(v: &amp;mut <a class="primitive" href="../../primitive.pointer.html">*mut T</a>) -&gt; &amp;<a class="struct" href="struct.AtomicPtr.html" title="struct std::sync::atomic::AtomicPtr">AtomicPtr</a>&lt;T&gt;</h4></div><div class="item-info"><div class="stab unstable"><span class="emoji">🔬</span> This is a nightly-only experimental API. (<code>atomic_from_mut</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/76314">#76314</a>)</div></div></summary><div class="docblock" xpath="/html[1]/body[1]/section[1]/details[2]/div[1]/details[3]/div[1]" istranslationnode="true" main_mp="Y25yZD4/d3xuYjo7ZXFraHlyKitVYXt4eXJAZWYpQCsaG0ZTS0h7SFVV" sub_mp="[&quot;c3VkOz52fWtjOzpgcGppbHMrKlBgenl8c0FkYyhBKi8aR1JOSXpJUFQ=&quot;]"><p class="translate-text">获得对指针的原子访问。</p><p>Get atomic access to a pointer.</p>
<h5 id="examples-2" class="section-header"><a href="#examples-2">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attribute">#![<span class="ident">feature</span>(<span class="ident">atomic_from_mut</span>)]</span>
<span class="kw">use</span> <span class="ident">std::sync::atomic</span>::{<span class="ident">AtomicPtr</span>, <span class="ident">Ordering</span>};

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">data</span> <span class="op">=</span> <span class="number">123</span>;
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">some_ptr</span> <span class="op">=</span> <span class="kw-2">&amp;mut</span> <span class="ident">data</span> <span class="kw">as</span> <span class="kw-2">*mut</span> <span class="ident">i32</span>;
<span class="kw">let</span> <span class="ident">a</span> <span class="op">=</span> <span class="ident">AtomicPtr::from_mut</span>(<span class="kw-2">&amp;mut</span> <span class="ident">some_ptr</span>);
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">other_data</span> <span class="op">=</span> <span class="number">456</span>;
<span class="ident">a</span>.<span class="ident">store</span>(<span class="kw-2">&amp;mut</span> <span class="ident">other_data</span>, <span class="ident">Ordering::Relaxed</span>);
<span class="macro">assert_eq!</span>(<span class="kw">unsafe</span> { <span class="kw-2">*</span><span class="ident">some_ptr</span> }, <span class="number">456</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(atomic_from_mut)%5D%0Afn%20main()%20%7B%0Ause%20std%3A%3Async%3A%3Aatomic%3A%3A%7BAtomicPtr%2C%20Ordering%7D%3B%0A%0Alet%20mut%20data%20%3D%20123%3B%0Alet%20mut%20some_ptr%20%3D%20%26mut%20data%20as%20*mut%20i32%3B%0Alet%20a%20%3D%20AtomicPtr%3A%3Afrom_mut(%26mut%20some_ptr)%3B%0Alet%20mut%20other_data%20%3D%20456%3B%0Aa.store(%26mut%20other_data%2C%20Ordering%3A%3ARelaxed)%3B%0Aassert_eq!(unsafe%20%7B%20*some_ptr%20%7D%2C%20456)%3B%0A%7D&amp;version=nightly&amp;edition=2018">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.into_inner" class="method has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.15.0, const unstable">1.15.0 (const: <a href="https://github.com/rust-lang/rust/issues/78729" title="Tracking issue for const_cell_into_inner">unstable</a>)</span><a class="srclink" href="../../../src/core/sync/atomic.rs.html#964" title="goto source code">[src]</a></div><a href="#method.into_inner" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.into_inner" class="fnname">into_inner</a>(self) -&gt; <a class="primitive" href="../../primitive.pointer.html">*mut T</a></h4></div></summary><div class="docblock" xpath="/html[1]/body[1]/section[1]/details[2]/div[1]/details[4]/div[1]" istranslationnode="true" main_mp="Y25yZD4/d3xuYjo7ZXFraHlyKitVYXt4eXJAZWYpQCsaG0lPUEp7TE5PRVM=" sub_mp="[&quot;c3VkOz52fWtjOzpgcGppbHMrKlBgenl8c0FkYyhBKi8aSE5VS3pNS05EUg==&quot;]"><p class="translate-text">使用原子并返回包含的值。</p><p>Consumes the atomic and returns the contained value.</p>
<p class="translate-text">这是安全的，因为通过值传递 `self` 可以保证没有其他线程同时访问原子数据。</p><p>This is safe because passing <code>self</code> by value guarantees that no other threads are
concurrently accessing the atomic data.</p>
<h5 id="examples-3" class="section-header"><a href="#examples-3">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">std::sync::atomic::AtomicPtr</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">data</span> <span class="op">=</span> <span class="number">5</span>;
<span class="kw">let</span> <span class="ident">atomic_ptr</span> <span class="op">=</span> <span class="ident">AtomicPtr::new</span>(<span class="kw-2">&amp;mut</span> <span class="ident">data</span>);
<span class="macro">assert_eq!</span>(<span class="kw">unsafe</span> { <span class="kw-2">*</span><span class="ident">atomic_ptr</span>.<span class="ident">into_inner</span>() }, <span class="number">5</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Ause%20std%3A%3Async%3A%3Aatomic%3A%3AAtomicPtr%3B%0A%0Alet%20mut%20data%20%3D%205%3B%0Alet%20atomic_ptr%20%3D%20AtomicPtr%3A%3Anew(%26mut%20data)%3B%0Aassert_eq!(unsafe%20%7B%20*atomic_ptr.into_inner()%20%7D%2C%205)%3B%0A%7D&amp;edition=2018">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.load" class="method has-srclink"><div class="rightside"><a class="srclink" href="../../../src/core/sync/atomic.rs.html#989" title="goto source code">[src]</a></div><a href="#method.load" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.load" class="fnname">load</a>(&amp;self, order: <a class="enum" href="enum.Ordering.html" title="enum std::sync::atomic::Ordering">Ordering</a>) -&gt; <a class="primitive" href="../../primitive.pointer.html">*mut T</a></h4></div></summary><div class="docblock" xpath="/html[1]/body[1]/section[1]/details[2]/div[1]/details[5]/div[1]" istranslationnode="true" main_mp="Y25yZD4/d3xuYjo7ZXFraHlyKitVYXt4eXJAZWYpQCsaG0xORUE=" sub_mp="[&quot;c3VkOz52fWtjOzpgcGppbHMrKlBgenl8c0FkYyhBKi8aTU9AQA==&quot;]"><p class="translate-text">从指针加载一个值。</p><p>Loads a value from the pointer.</p>
<p class="translate-text">`load` 接受一个“Ordering”参数，它描述了这个操作的内存顺序。 可能的值为“SeqCst”、“Acquire”和“Relaxed”。</p><p><code>load</code> takes an <a href="enum.Ordering.html" title="Ordering"><code>Ordering</code></a> argument which describes the memory ordering
of this operation. Possible values are <a href="enum.Ordering.html#variant.SeqCst" title="SeqCst"><code>SeqCst</code></a>, <a href="enum.Ordering.html#variant.Acquire" title="Acquire"><code>Acquire</code></a> and <a href="enum.Ordering.html#variant.Relaxed" title="Relaxed"><code>Relaxed</code></a>.</p>
<h5 id="panics" class="section-header"><a href="#panics">Panics</a></h5>
<p class="translate-text">如果 `order` 是“Release”或“AcqRel”，则发生panic。</p><p>Panics if <code>order</code> is <a href="enum.Ordering.html#variant.Release" title="Release"><code>Release</code></a> or <a href="enum.Ordering.html#variant.AcqRel" title="AcqRel"><code>AcqRel</code></a>.</p>
<h5 id="examples-4" class="section-header"><a href="#examples-4">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">std::sync::atomic</span>::{<span class="ident">AtomicPtr</span>, <span class="ident">Ordering</span>};

<span class="kw">let</span> <span class="ident">ptr</span> <span class="op">=</span> <span class="kw-2">&amp;mut</span> <span class="number">5</span>;
<span class="kw">let</span> <span class="ident">some_ptr</span>  <span class="op">=</span> <span class="ident">AtomicPtr::new</span>(<span class="ident">ptr</span>);

<span class="kw">let</span> <span class="ident">value</span> <span class="op">=</span> <span class="ident">some_ptr</span>.<span class="ident">load</span>(<span class="ident">Ordering::Relaxed</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Ause%20std%3A%3Async%3A%3Aatomic%3A%3A%7BAtomicPtr%2C%20Ordering%7D%3B%0A%0Alet%20ptr%20%3D%20%26mut%205%3B%0Alet%20some_ptr%20%20%3D%20AtomicPtr%3A%3Anew(ptr)%3B%0A%0Alet%20value%20%3D%20some_ptr.load(Ordering%3A%3ARelaxed)%3B%0A%7D&amp;edition=2018">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.store" class="method has-srclink"><div class="rightside"><a class="srclink" href="../../../src/core/sync/atomic.rs.html#1017" title="goto source code">[src]</a></div><a href="#method.store" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.store" class="fnname">store</a>(&amp;self, ptr: <a class="primitive" href="../../primitive.pointer.html">*mut T</a>, order: <a class="enum" href="enum.Ordering.html" title="enum std::sync::atomic::Ordering">Ordering</a>)</h4></div></summary><div class="docblock" xpath="/html[1]/body[1]/section[1]/details[2]/div[1]/details[6]/div[1]" istranslationnode="true" main_mp="Y25yZD4/d3xuYjo7ZXFraHlyKitVYXt4eXJAZWYpQCsaG1NVS1dB" sub_mp="[&quot;c3VkOz52fWtjOzpgcGppbHMrKlBgenl8c0FkYyhBKi8aUlROVkA=&quot;]"><p class="translate-text">将值存储到指针中。</p><p>Stores a value into the pointer.</p>
<p class="translate-text">`store` 接受一个“Ordering”参数，它描述了这个操作的内存顺序。 可能的值为“SeqCst”、“Release”和“Relaxed”。</p><p><code>store</code> takes an <a href="enum.Ordering.html" title="Ordering"><code>Ordering</code></a> argument which describes the memory ordering
of this operation. Possible values are <a href="enum.Ordering.html#variant.SeqCst" title="SeqCst"><code>SeqCst</code></a>, <a href="enum.Ordering.html#variant.Release" title="Release"><code>Release</code></a> and <a href="enum.Ordering.html#variant.Relaxed" title="Relaxed"><code>Relaxed</code></a>.</p>
<h5 id="panics-1" class="section-header"><a href="#panics-1">Panics</a></h5>
<p class="translate-text">如果 `order` 是“Acquire”或“AcqRel”，则会出现panic。</p><p>Panics if <code>order</code> is <a href="enum.Ordering.html#variant.Acquire" title="Acquire"><code>Acquire</code></a> or <a href="enum.Ordering.html#variant.AcqRel" title="AcqRel"><code>AcqRel</code></a>.</p>
<h5 id="examples-5" class="section-header"><a href="#examples-5">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">std::sync::atomic</span>::{<span class="ident">AtomicPtr</span>, <span class="ident">Ordering</span>};

<span class="kw">let</span> <span class="ident">ptr</span> <span class="op">=</span> <span class="kw-2">&amp;mut</span> <span class="number">5</span>;
<span class="kw">let</span> <span class="ident">some_ptr</span>  <span class="op">=</span> <span class="ident">AtomicPtr::new</span>(<span class="ident">ptr</span>);

<span class="kw">let</span> <span class="ident">other_ptr</span> <span class="op">=</span> <span class="kw-2">&amp;mut</span> <span class="number">10</span>;

<span class="ident">some_ptr</span>.<span class="ident">store</span>(<span class="ident">other_ptr</span>, <span class="ident">Ordering::Relaxed</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Ause%20std%3A%3Async%3A%3Aatomic%3A%3A%7BAtomicPtr%2C%20Ordering%7D%3B%0A%0Alet%20ptr%20%3D%20%26mut%205%3B%0Alet%20some_ptr%20%20%3D%20AtomicPtr%3A%3Anew(ptr)%3B%0A%0Alet%20other_ptr%20%3D%20%26mut%2010%3B%0A%0Asome_ptr.store(other_ptr%2C%20Ordering%3A%3ARelaxed)%3B%0A%7D&amp;edition=2018">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.swap" class="method has-srclink"><div class="rightside"><a class="srclink" href="../../../src/core/sync/atomic.rs.html#1049" title="goto source code">[src]</a></div><a href="#method.swap" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.swap" class="fnname">swap</a>(&amp;self, ptr: <a class="primitive" href="../../primitive.pointer.html">*mut T</a>, order: <a class="enum" href="enum.Ordering.html" title="enum std::sync::atomic::Ordering">Ordering</a>) -&gt; <a class="primitive" href="../../primitive.pointer.html">*mut T</a></h4></div></summary><div class="docblock" xpath="/html[1]/body[1]/section[1]/details[2]/div[1]/details[7]/div[1]" istranslationnode="true" main_mp="Y25yZD4/d3xuYjo7ZXFraHlyKitVYXt4eXJAZWYpQCsaG1NWRVU=" sub_mp="[&quot;c3VkOz52fWtjOzpgcGppbHMrKlBgenl8c0FkYyhBKi8aUldAVA==&quot;]"><p class="translate-text">将值存储到指针中，返回前一个值。</p><p>Stores a value into the pointer, returning the previous value.</p>
<p class="translate-text">`swap` 接受一个 "Ordering" 参数，它描述了这个操作的内存顺序。 所有订购模式都是可能的。 请注意，使用“获取”使此操作的存储部分“放松”，使用“释放”使加载部分“放松”。</p><p><code>swap</code> takes an <a href="enum.Ordering.html" title="Ordering"><code>Ordering</code></a> argument which describes the memory ordering
of this operation. All ordering modes are possible. Note that using
<a href="enum.Ordering.html#variant.Acquire" title="Acquire"><code>Acquire</code></a> makes the store part of this operation <a href="enum.Ordering.html#variant.Relaxed" title="Relaxed"><code>Relaxed</code></a>, and
using <a href="enum.Ordering.html#variant.Release" title="Release"><code>Release</code></a> makes the load part <a href="enum.Ordering.html#variant.Relaxed" title="Relaxed"><code>Relaxed</code></a>.</p>
<p class="translate-text">注意：此方法仅在支持指针原子操作的平台上可用。</p><p><strong>Note:</strong> This method is only available on platforms that support atomic
operations on pointers.</p>
<h5 id="examples-6" class="section-header"><a href="#examples-6">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">std::sync::atomic</span>::{<span class="ident">AtomicPtr</span>, <span class="ident">Ordering</span>};

<span class="kw">let</span> <span class="ident">ptr</span> <span class="op">=</span> <span class="kw-2">&amp;mut</span> <span class="number">5</span>;
<span class="kw">let</span> <span class="ident">some_ptr</span>  <span class="op">=</span> <span class="ident">AtomicPtr::new</span>(<span class="ident">ptr</span>);

<span class="kw">let</span> <span class="ident">other_ptr</span> <span class="op">=</span> <span class="kw-2">&amp;mut</span> <span class="number">10</span>;

<span class="kw">let</span> <span class="ident">value</span> <span class="op">=</span> <span class="ident">some_ptr</span>.<span class="ident">swap</span>(<span class="ident">other_ptr</span>, <span class="ident">Ordering::Relaxed</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Ause%20std%3A%3Async%3A%3Aatomic%3A%3A%7BAtomicPtr%2C%20Ordering%7D%3B%0A%0Alet%20ptr%20%3D%20%26mut%205%3B%0Alet%20some_ptr%20%20%3D%20AtomicPtr%3A%3Anew(ptr)%3B%0A%0Alet%20other_ptr%20%3D%20%26mut%2010%3B%0A%0Alet%20value%20%3D%20some_ptr.swap(other_ptr%2C%20Ordering%3A%3ARelaxed)%3B%0A%7D&amp;edition=2018">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.compare_and_swap" class="method has-srclink"><div class="rightside"><a class="srclink" href="../../../src/core/sync/atomic.rs.html#1104" title="goto source code">[src]</a></div><a href="#method.compare_and_swap" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.compare_and_swap" class="fnname">compare_and_swap</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;current: <a class="primitive" href="../../primitive.pointer.html">*mut T</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;new: <a class="primitive" href="../../primitive.pointer.html">*mut T</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;order: <a class="enum" href="enum.Ordering.html" title="enum std::sync::atomic::Ordering">Ordering</a><br>) -&gt; <a class="primitive" href="../../primitive.pointer.html">*mut T</a></h4></div><div class="item-info"><div class="stab deprecated"><span class="emoji">👎</span> Deprecated since 1.50.0: <p>Use <code>compare_exchange</code> or <code>compare_exchange_weak</code> instead</p>
</div></div></summary><div class="docblock" xpath="/html[1]/body[1]/section[1]/details[2]/div[1]/details[8]/div[1]" istranslationnode="true" main_mp="Y25yZD4/d3xuYjo7ZXFraHlyKitVYXt4eXJAZWYpQCsaG0NOSVVFV0V+QU9AeldSUUE=" sub_mp="[&quot;c3VkOz52fWtjOzpgcGppbHMrKlBgenl8c0FkYyhBKi8aQk9MVERWQH9ATkV7VlNEQA==&quot;]"><p class="translate-text">如果当前值与“当前”值相同，则将值存储到指针中。</p><p>Stores a value into the pointer if the current value is the same as the <code>current</code> value.</p>
<p class="translate-text">返回值始终是前一个值。 如果它等于 `current`，则该值已更新。</p><p>The return value is always the previous value. If it is equal to <code>current</code>, then the value
was updated.</p>
<p class="translate-text">`compare_and_swap` 还接受一个“Ordering”参数，该参数描述了此操作的内存顺序。 请注意，即使使用“AcqRel”，操作也可能会失败，因此只执行“Acquire”加载，但没有“Release”语义。 如果发生这种情况，使用“Acquire”会使该操作的存储部分“放松”，而使用“Release”会使加载部分“放松”。</p><p><code>compare_and_swap</code> also takes an <a href="enum.Ordering.html" title="Ordering"><code>Ordering</code></a> argument which describes the memory
ordering of this operation. Notice that even when using <a href="enum.Ordering.html#variant.AcqRel" title="AcqRel"><code>AcqRel</code></a>, the operation
might fail and hence just perform an <code>Acquire</code> load, but not have <code>Release</code> semantics.
Using <a href="enum.Ordering.html#variant.Acquire" title="Acquire"><code>Acquire</code></a> makes the store part of this operation <a href="enum.Ordering.html#variant.Relaxed" title="Relaxed"><code>Relaxed</code></a> if it
happens, and using <a href="enum.Ordering.html#variant.Release" title="Release"><code>Release</code></a> makes the load part <a href="enum.Ordering.html#variant.Relaxed" title="Relaxed"><code>Relaxed</code></a>.</p>
<p class="translate-text">注意：此方法仅在支持指针原子操作的平台上可用。</p><p><strong>Note:</strong> This method is only available on platforms that support atomic
operations on pointers.</p>
<h5 id="migrating-to-compare_exchange-and-compare_exchange_weak" class="section-header"><a href="#migrating-to-compare_exchange-and-compare_exchange_weak">Migrating to <code>compare_exchange</code> and <code>compare_exchange_weak</code></a></h5>
<p class="translate-text">`compare_and_swap` 等价于 `compare_exchange`，具有以下内存排序映射：</p><p><code>compare_and_swap</code> is equivalent to <code>compare_exchange</code> with the following mapping for
memory orderings:</p>
<div><table><thead><tr><th>Original</th><th>Success</th><th>Failure</th></tr></thead><tbody>
<tr><td>Relaxed</td><td>Relaxed</td><td>Relaxed</td></tr>
<tr><td>Acquire</td><td>Acquire</td><td>Acquire</td></tr>
<tr><td>Release</td><td>Release</td><td>Relaxed</td></tr>
<tr><td>AcqRel</td><td>AcqRel</td><td>Acquire</td></tr>
<tr><td>SeqCst</td><td>SeqCst</td><td>SeqCst</td></tr>
</tbody></table>
</div>
<p class="translate-text">即使比较成功，`compare_exchange_weak` 也允许虚假失败，这允许编译器在循环中使用比较和交换时生成更好的汇编代码。</p><p><code>compare_exchange_weak</code> is allowed to fail spuriously even when the comparison succeeds,
which allows the compiler to generate better assembly code when the compare and swap
is used in a loop.</p>
<h5 id="examples-7" class="section-header"><a href="#examples-7">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">std::sync::atomic</span>::{<span class="ident">AtomicPtr</span>, <span class="ident">Ordering</span>};

<span class="kw">let</span> <span class="ident">ptr</span> <span class="op">=</span> <span class="kw-2">&amp;mut</span> <span class="number">5</span>;
<span class="kw">let</span> <span class="ident">some_ptr</span>  <span class="op">=</span> <span class="ident">AtomicPtr::new</span>(<span class="ident">ptr</span>);

<span class="kw">let</span> <span class="ident">other_ptr</span>   <span class="op">=</span> <span class="kw-2">&amp;mut</span> <span class="number">10</span>;

<span class="kw">let</span> <span class="ident">value</span> <span class="op">=</span> <span class="ident">some_ptr</span>.<span class="ident">compare_and_swap</span>(<span class="ident">ptr</span>, <span class="ident">other_ptr</span>, <span class="ident">Ordering::Relaxed</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Ause%20std%3A%3Async%3A%3Aatomic%3A%3A%7BAtomicPtr%2C%20Ordering%7D%3B%0A%0Alet%20ptr%20%3D%20%26mut%205%3B%0Alet%20some_ptr%20%20%3D%20AtomicPtr%3A%3Anew(ptr)%3B%0A%0Alet%20other_ptr%20%20%20%3D%20%26mut%2010%3B%0A%0Alet%20value%20%3D%20some_ptr.compare_and_swap(ptr%2C%20other_ptr%2C%20Ordering%3A%3ARelaxed)%3B%0A%7D&amp;edition=2018">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.compare_exchange" class="method has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.10.0">1.10.0</span><a class="srclink" href="../../../src/core/sync/atomic.rs.html#1144-1150" title="goto source code">[src]</a></div><a href="#method.compare_exchange" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.compare_exchange" class="fnname">compare_exchange</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;current: <a class="primitive" href="../../primitive.pointer.html">*mut T</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;new: <a class="primitive" href="../../primitive.pointer.html">*mut T</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;success: <a class="enum" href="enum.Ordering.html" title="enum std::sync::atomic::Ordering">Ordering</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;failure: <a class="enum" href="enum.Ordering.html" title="enum std::sync::atomic::Ordering">Ordering</a><br>) -&gt; <a class="enum" href="../../result/enum.Result.html" title="enum std::result::Result">Result</a>&lt;<a class="primitive" href="../../primitive.pointer.html">*mut T</a>, <a class="primitive" href="../../primitive.pointer.html">*mut T</a>&gt;</h4></div></summary><div class="docblock" xpath="/html[1]/body[1]/section[1]/details[2]/div[1]/details[9]/div[1]" istranslationnode="true" main_mp="Y25yZD4/d3xuYjo7ZXFraHlyKitVYXt4eXJAZWYpQCsaG0NOSVVFV0V+RVlHTUVLV1Q=" sub_mp="[&quot;c3VkOz52fWtjOzpgcGppbHMrKlBgenl8c0FkYyhBKi8aQk9MVERWQH9EWEJMREpCVQ==&quot;]"><p class="translate-text">如果当前值与“当前”值相同，则将值存储到指针中。</p><p>Stores a value into the pointer if the current value is the same as the <code>current</code> value.</p>
<p class="translate-text">返回值是指示是否写入新值并包含先前值的结果。 成功时，此值保证等于 `current`。</p><p>The return value is a result indicating whether the new value was written and containing
the previous value. On success this value is guaranteed to be equal to <code>current</code>.</p>
<p class="translate-text">`compare_exchange` 采用两个“Ordering”参数来描述此操作的内存顺序。 `success` 描述了在与`current` 比较成功时发生的读-修改-写操作所需的顺序。 `failure` 描述了比较失败时发生的加载操作所需的顺序。 使用“Acquire”作为成功排序使得该操作的存储部分“Relaxed”，使用“Release”使得成功加载“Relaxed”。 失败排序只能是“SeqCst”、“Acquire”或“Relaxed”，并且必须等于或弱于成功排序。</p><p><code>compare_exchange</code> takes two <a href="enum.Ordering.html" title="Ordering"><code>Ordering</code></a> arguments to describe the memory
ordering of this operation. <code>success</code> describes the required ordering for the
read-modify-write operation that takes place if the comparison with <code>current</code> succeeds.
<code>failure</code> describes the required ordering for the load operation that takes place when
the comparison fails. Using <a href="enum.Ordering.html#variant.Acquire" title="Acquire"><code>Acquire</code></a> as success ordering makes the store part
of this operation <a href="enum.Ordering.html#variant.Relaxed" title="Relaxed"><code>Relaxed</code></a>, and using <a href="enum.Ordering.html#variant.Release" title="Release"><code>Release</code></a> makes the successful load
<a href="enum.Ordering.html#variant.Relaxed" title="Relaxed"><code>Relaxed</code></a>. The failure ordering can only be <a href="enum.Ordering.html#variant.SeqCst" title="SeqCst"><code>SeqCst</code></a>, <a href="enum.Ordering.html#variant.Acquire" title="Acquire"><code>Acquire</code></a> or <a href="enum.Ordering.html#variant.Relaxed" title="Relaxed"><code>Relaxed</code></a>
and must be equivalent to or weaker than the success ordering.</p>
<p class="translate-text">注意：此方法仅在支持指针原子操作的平台上可用。</p><p><strong>Note:</strong> This method is only available on platforms that support atomic
operations on pointers.</p>
<h5 id="examples-8" class="section-header"><a href="#examples-8">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">std::sync::atomic</span>::{<span class="ident">AtomicPtr</span>, <span class="ident">Ordering</span>};

<span class="kw">let</span> <span class="ident">ptr</span> <span class="op">=</span> <span class="kw-2">&amp;mut</span> <span class="number">5</span>;
<span class="kw">let</span> <span class="ident">some_ptr</span>  <span class="op">=</span> <span class="ident">AtomicPtr::new</span>(<span class="ident">ptr</span>);

<span class="kw">let</span> <span class="ident">other_ptr</span>   <span class="op">=</span> <span class="kw-2">&amp;mut</span> <span class="number">10</span>;

<span class="kw">let</span> <span class="ident">value</span> <span class="op">=</span> <span class="ident">some_ptr</span>.<span class="ident">compare_exchange</span>(<span class="ident">ptr</span>, <span class="ident">other_ptr</span>,
                                      <span class="ident">Ordering::SeqCst</span>, <span class="ident">Ordering::Relaxed</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Ause%20std%3A%3Async%3A%3Aatomic%3A%3A%7BAtomicPtr%2C%20Ordering%7D%3B%0A%0Alet%20ptr%20%3D%20%26mut%205%3B%0Alet%20some_ptr%20%20%3D%20AtomicPtr%3A%3Anew(ptr)%3B%0A%0Alet%20other_ptr%20%20%20%3D%20%26mut%2010%3B%0A%0Alet%20value%20%3D%20some_ptr.compare_exchange(ptr%2C%20other_ptr%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20Ordering%3A%3ASeqCst%2C%20Ordering%3A%3ARelaxed)%3B%0A%7D&amp;edition=2018">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.compare_exchange_weak" class="method has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.10.0">1.10.0</span><a class="srclink" href="../../../src/core/sync/atomic.rs.html#1193-1199" title="goto source code">[src]</a></div><a href="#method.compare_exchange_weak" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.compare_exchange_weak" class="fnname">compare_exchange_weak</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;current: <a class="primitive" href="../../primitive.pointer.html">*mut T</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;new: <a class="primitive" href="../../primitive.pointer.html">*mut T</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;success: <a class="enum" href="enum.Ordering.html" title="enum std::sync::atomic::Ordering">Ordering</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;failure: <a class="enum" href="enum.Ordering.html" title="enum std::sync::atomic::Ordering">Ordering</a><br>) -&gt; <a class="enum" href="../../result/enum.Result.html" title="enum std::result::Result">Result</a>&lt;<a class="primitive" href="../../primitive.pointer.html">*mut T</a>, <a class="primitive" href="../../primitive.pointer.html">*mut T</a>&gt;</h4></div></summary><div class="docblock" xpath="/html[1]/body[1]/section[1]/details[2]/div[1]/details[10]/div[1]" istranslationnode="true" main_mp="Y25yZD4/d3xuYjo7ZXFraHlyKitVYXt4eXJAZWYpQCsaG0NOSVVFV0V+RVlHTUVLV1RvRlFUXw==" sub_mp="[&quot;c3VkOz52fWtjOzpgcGppbHMrKlBgenl8c0FkYyhBKi8aQk9MVERWQH9EWEJMREpCVW5HVFVe&quot;]"><p class="translate-text">如果当前值与“当前”值相同，则将值存储到指针中。</p><p>Stores a value into the pointer if the current value is the same as the <code>current</code> value.</p>
<p class="translate-text">与“AtomicPtr::compare_exchange”不同，即使比较成功，该函数也允许虚假失败，这可以在某些平台上产生更高效的代码。 返回值是指示是否写入新值并包含先前值的结果。</p><p>Unlike <a href="struct.AtomicPtr.html#method.compare_exchange" title="AtomicPtr::compare_exchange"><code>AtomicPtr::compare_exchange</code></a>, this function is allowed to spuriously fail even when the
comparison succeeds, which can result in more efficient code on some platforms. The
return value is a result indicating whether the new value was written and containing the
previous value.</p>
<p class="translate-text">`compare_exchange_weak` 采用两个“Ordering”参数来描述此操作的内存顺序。 `success` 描述了在与`current` 比较成功时发生的读-修改-写操作所需的顺序。 `failure` 描述了比较失败时发生的加载操作所需的顺序。 使用“Acquire”作为成功排序使得该操作的存储部分“Relaxed”，使用“Release”使得成功加载“Relaxed”。 失败排序只能是“SeqCst”、“Acquire”或“Relaxed”，并且必须等于或弱于成功排序。</p><p><code>compare_exchange_weak</code> takes two <a href="enum.Ordering.html" title="Ordering"><code>Ordering</code></a> arguments to describe the memory
ordering of this operation. <code>success</code> describes the required ordering for the
read-modify-write operation that takes place if the comparison with <code>current</code> succeeds.
<code>failure</code> describes the required ordering for the load operation that takes place when
the comparison fails. Using <a href="enum.Ordering.html#variant.Acquire" title="Acquire"><code>Acquire</code></a> as success ordering makes the store part
of this operation <a href="enum.Ordering.html#variant.Relaxed" title="Relaxed"><code>Relaxed</code></a>, and using <a href="enum.Ordering.html#variant.Release" title="Release"><code>Release</code></a> makes the successful load
<a href="enum.Ordering.html#variant.Relaxed" title="Relaxed"><code>Relaxed</code></a>. The failure ordering can only be <a href="enum.Ordering.html#variant.SeqCst" title="SeqCst"><code>SeqCst</code></a>, <a href="enum.Ordering.html#variant.Acquire" title="Acquire"><code>Acquire</code></a> or <a href="enum.Ordering.html#variant.Relaxed" title="Relaxed"><code>Relaxed</code></a>
and must be equivalent to or weaker than the success ordering.</p>
<p class="translate-text">注意：此方法仅在支持指针原子操作的平台上可用。</p><p><strong>Note:</strong> This method is only available on platforms that support atomic
operations on pointers.</p>
<h5 id="examples-9" class="section-header"><a href="#examples-9">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">std::sync::atomic</span>::{<span class="ident">AtomicPtr</span>, <span class="ident">Ordering</span>};

<span class="kw">let</span> <span class="ident">some_ptr</span> <span class="op">=</span> <span class="ident">AtomicPtr::new</span>(<span class="kw-2">&amp;mut</span> <span class="number">5</span>);

<span class="kw">let</span> <span class="ident">new</span> <span class="op">=</span> <span class="kw-2">&amp;mut</span> <span class="number">10</span>;
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">old</span> <span class="op">=</span> <span class="ident">some_ptr</span>.<span class="ident">load</span>(<span class="ident">Ordering::Relaxed</span>);
<span class="kw">loop</span> {
    <span class="kw">match</span> <span class="ident">some_ptr</span>.<span class="ident">compare_exchange_weak</span>(<span class="ident">old</span>, <span class="ident">new</span>, <span class="ident">Ordering::SeqCst</span>, <span class="ident">Ordering::Relaxed</span>) {
        <span class="prelude-val">Ok</span>(<span class="kw">_</span>) =&gt; <span class="kw">break</span>,
        <span class="prelude-val">Err</span>(<span class="ident">x</span>) =&gt; <span class="ident">old</span> <span class="op">=</span> <span class="ident">x</span>,
    }
}</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Ause%20std%3A%3Async%3A%3Aatomic%3A%3A%7BAtomicPtr%2C%20Ordering%7D%3B%0A%0Alet%20some_ptr%20%3D%20AtomicPtr%3A%3Anew(%26mut%205)%3B%0A%0Alet%20new%20%3D%20%26mut%2010%3B%0Alet%20mut%20old%20%3D%20some_ptr.load(Ordering%3A%3ARelaxed)%3B%0Aloop%20%7B%0A%20%20%20%20match%20some_ptr.compare_exchange_weak(old%2C%20new%2C%20Ordering%3A%3ASeqCst%2C%20Ordering%3A%3ARelaxed)%20%7B%0A%20%20%20%20%20%20%20%20Ok(_)%20%3D%3E%20break%2C%0A%20%20%20%20%20%20%20%20Err(x)%20%3D%3E%20old%20%3D%20x%2C%0A%20%20%20%20%7D%0A%7D%0A%7D&amp;edition=2018">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.fetch_update" class="method has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.53.0">1.53.0</span><a class="srclink" href="../../../src/core/sync/atomic.rs.html#1254-1261" title="goto source code">[src]</a></div><a href="#method.fetch_update" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.fetch_update" class="fnname">fetch_update</a>&lt;F&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;set_order: <a class="enum" href="enum.Ordering.html" title="enum std::sync::atomic::Ordering">Ordering</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;fetch_order: <a class="enum" href="enum.Ordering.html" title="enum std::sync::atomic::Ordering">Ordering</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;f: F<br>) -&gt; <a class="enum" href="../../result/enum.Result.html" title="enum std::result::Result">Result</a>&lt;<a class="primitive" href="../../primitive.pointer.html">*mut T</a>, <a class="primitive" href="../../primitive.pointer.html">*mut T</a>&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="../../ops/trait.FnMut.html" title="trait std::ops::FnMut">FnMut</a>(<a class="primitive" href="../../primitive.pointer.html">*mut T</a>) -&gt; <a class="enum" href="../../option/enum.Option.html" title="enum std::option::Option">Option</a>&lt;<a class="primitive" href="../../primitive.pointer.html">*mut T</a>&gt;,&nbsp;</span></h4></div></summary><div class="docblock" xpath="/html[1]/body[1]/section[1]/details[2]/div[1]/details[11]/div[1]" istranslationnode="true" main_mp="Y25yZD4/d3xuYjo7ZXFraHlyKitVYXt4eXJAZWYpQCsaG0ZEUEZMelVRREBQQA==" sub_mp="[&quot;c3VkOz52fWtjOzpgcGppbHMrKlBgenl8c0FkYyhBKi8aR0VVR017UFBFQVVB&quot;]"><p class="translate-text">获取该值，并对其应用一个返回可选新值的函数。 如果函数返回 `Some(_)`，则返回 `Ok(previous_value)` 的 `Result`，否则返回 `Err(previous_value)`。</p><p>Fetches the value, and applies a function to it that returns an optional
new value. Returns a <code>Result</code> of <code>Ok(previous_value)</code> if the function
returned <code>Some(_)</code>, else <code>Err(previous_value)</code>.</p>
<p class="translate-text">注意：如果同时从其他线程更改了值，这可能会多次调用该函数，只要该函数返回 `Some(_)`，但该函数将只应用于存储的值一次。</p><p>Note: This may call the function multiple times if the value has been
changed from other threads in the meantime, as long as the function
returns <code>Some(_)</code>, but the function will have been applied only once to
the stored value.</p>
<p class="translate-text">`fetch_update` 采用两个“Ordering”参数来描述此操作的内存顺序。 第一个描述了操作最终成功时所需的顺序，而第二个描述了加载所需的顺序。 这些分别对应于“AtomicPtr::compare_exchange”的成功和失败顺序。</p><p><code>fetch_update</code> takes two <a href="enum.Ordering.html" title="Ordering"><code>Ordering</code></a> arguments to describe the memory
ordering of this operation. The first describes the required ordering for
when the operation finally succeeds while the second describes the
required ordering for loads. These correspond to the success and failure
orderings of <a href="struct.AtomicPtr.html#method.compare_exchange" title="AtomicPtr::compare_exchange"><code>AtomicPtr::compare_exchange</code></a> respectively.</p>
<p class="translate-text">使用“Acquire”作为成功排序使得该操作的存储部分“Relaxed”，使用“Release”使得最终成功加载“Relaxed”。 （失败的）加载排序只能是“SeqCst”、“Acquire”或“Relaxed”，并且必须等于或弱于成功排序。</p><p>Using <a href="enum.Ordering.html#variant.Acquire" title="Acquire"><code>Acquire</code></a> as success ordering makes the store part of this
operation <a href="enum.Ordering.html#variant.Relaxed" title="Relaxed"><code>Relaxed</code></a>, and using <a href="enum.Ordering.html#variant.Release" title="Release"><code>Release</code></a> makes the final successful
load <a href="enum.Ordering.html#variant.Relaxed" title="Relaxed"><code>Relaxed</code></a>. The (failed) load ordering can only be <a href="enum.Ordering.html#variant.SeqCst" title="SeqCst"><code>SeqCst</code></a>,
<a href="enum.Ordering.html#variant.Acquire" title="Acquire"><code>Acquire</code></a> or <a href="enum.Ordering.html#variant.Relaxed" title="Relaxed"><code>Relaxed</code></a> and must be equivalent to or weaker than the
success ordering.</p>
<p class="translate-text">注意：此方法仅在支持指针原子操作的平台上可用。</p><p><strong>Note:</strong> This method is only available on platforms that support atomic
operations on pointers.</p>
<h5 id="examples-10" class="section-header"><a href="#examples-10">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">std::sync::atomic</span>::{<span class="ident">AtomicPtr</span>, <span class="ident">Ordering</span>};

<span class="kw">let</span> <span class="ident">ptr</span>: <span class="kw-2">*mut</span> <span class="kw">_</span> <span class="op">=</span> <span class="kw-2">&amp;mut</span> <span class="number">5</span>;
<span class="kw">let</span> <span class="ident">some_ptr</span> <span class="op">=</span> <span class="ident">AtomicPtr::new</span>(<span class="ident">ptr</span>);

<span class="kw">let</span> <span class="ident">new</span>: <span class="kw-2">*mut</span> <span class="kw">_</span> <span class="op">=</span> <span class="kw-2">&amp;mut</span> <span class="number">10</span>;
<span class="macro">assert_eq!</span>(<span class="ident">some_ptr</span>.<span class="ident">fetch_update</span>(<span class="ident">Ordering::SeqCst</span>, <span class="ident">Ordering::SeqCst</span>, <span class="op">|</span><span class="kw">_</span><span class="op">|</span> <span class="prelude-val">None</span>), <span class="prelude-val">Err</span>(<span class="ident">ptr</span>));
<span class="kw">let</span> <span class="ident">result</span> <span class="op">=</span> <span class="ident">some_ptr</span>.<span class="ident">fetch_update</span>(<span class="ident">Ordering::SeqCst</span>, <span class="ident">Ordering::SeqCst</span>, <span class="op">|</span><span class="ident">x</span><span class="op">|</span> {
    <span class="kw">if</span> <span class="ident">x</span> <span class="op">==</span> <span class="ident">ptr</span> {
        <span class="prelude-val">Some</span>(<span class="ident">new</span>)
    } <span class="kw">else</span> {
        <span class="prelude-val">None</span>
    }
});
<span class="macro">assert_eq!</span>(<span class="ident">result</span>, <span class="prelude-val">Ok</span>(<span class="ident">ptr</span>));
<span class="macro">assert_eq!</span>(<span class="ident">some_ptr</span>.<span class="ident">load</span>(<span class="ident">Ordering::SeqCst</span>), <span class="ident">new</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Ause%20std%3A%3Async%3A%3Aatomic%3A%3A%7BAtomicPtr%2C%20Ordering%7D%3B%0A%0Alet%20ptr%3A%20*mut%20_%20%3D%20%26mut%205%3B%0Alet%20some_ptr%20%3D%20AtomicPtr%3A%3Anew(ptr)%3B%0A%0Alet%20new%3A%20*mut%20_%20%3D%20%26mut%2010%3B%0Aassert_eq!(some_ptr.fetch_update(Ordering%3A%3ASeqCst%2C%20Ordering%3A%3ASeqCst%2C%20%7C_%7C%20None)%2C%20Err(ptr))%3B%0Alet%20result%20%3D%20some_ptr.fetch_update(Ordering%3A%3ASeqCst%2C%20Ordering%3A%3ASeqCst%2C%20%7Cx%7C%20%7B%0A%20%20%20%20if%20x%20%3D%3D%20ptr%20%7B%0A%20%20%20%20%20%20%20%20Some(new)%0A%20%20%20%20%7D%20else%20%7B%0A%20%20%20%20%20%20%20%20None%0A%20%20%20%20%7D%0A%7D)%3B%0Aassert_eq!(result%2C%20Ok(ptr))%3B%0Aassert_eq!(some_ptr.load(Ordering%3A%3ASeqCst)%2C%20new)%3B%0A%7D&amp;edition=2018">Run</a></div>
</div></details></div></details><h2 id="trait-implementations" class="small-section-header">Trait Implementations<a href="#trait-implementations" class="anchor"></a></h2><div id="trait-implementations-list"><details class="rustdoc-toggle implementors-toggle" open=""><summary><div id="impl-Debug" class="impl has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.3.0">1.3.0</span><a class="srclink" href="../../../src/core/sync/atomic.rs.html#2783-2787" title="goto source code">[src]</a></div><a href="#impl-Debug" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="../../fmt/trait.Debug.html" title="trait std::fmt::Debug">Debug</a> for <a class="struct" href="struct.AtomicPtr.html" title="struct std::sync::atomic::AtomicPtr">AtomicPtr</a>&lt;T&gt;</h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.fmt-1" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../../../src/core/sync/atomic.rs.html#2784" title="goto source code">[src]</a></div><a href="#method.fmt-1" class="anchor"></a><h4 class="code-header">pub fn <a href="../../fmt/trait.Debug.html#tymethod.fmt" class="fnname">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="../../fmt/struct.Formatter.html" title="struct std::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="enum" href="../../result/enum.Result.html" title="enum std::result::Result">Result</a>&lt;<a class="primitive" href="../../primitive.unit.html">()</a>, <a class="struct" href="../../fmt/struct.Error.html" title="struct std::fmt::Error">Error</a>&gt;</h4></div></summary><div class='docblock'><p>Formats the value using the given formatter. <a href="../../fmt/trait.Debug.html#tymethod.fmt">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open=""><summary><div id="impl-Default" class="impl has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.0.0, const unstable">1.0.0 (const: <a href="https://github.com/rust-lang/rust/issues/87864" title="Tracking issue for const_default_impls">unstable</a>)</span><a class="srclink" href="../../../src/core/sync/atomic.rs.html#173-178" title="goto source code">[src]</a></div><a href="#impl-Default" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="../../default/trait.Default.html" title="trait std::default::Default">Default</a> for <a class="struct" href="struct.AtomicPtr.html" title="struct std::sync::atomic::AtomicPtr">AtomicPtr</a>&lt;T&gt;</h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.default" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../../../src/core/sync/atomic.rs.html#175" title="goto source code">[src]</a></div><a href="#method.default" class="anchor"></a><h4 class="code-header">pub fn <a href="../../default/trait.Default.html#tymethod.default" class="fnname">default</a>() -&gt; <a class="struct" href="struct.AtomicPtr.html" title="struct std::sync::atomic::AtomicPtr">AtomicPtr</a>&lt;T&gt;</h4></div></summary><div class="docblock"><p>Creates a null <code>AtomicPtr&lt;T&gt;</code>.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open=""><summary><div id="impl-From%3C*mut%20T%3E" class="impl has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.23.0, const unstable">1.23.0 (const: <a href="https://github.com/rust-lang/rust/issues/88674" title="Tracking issue for const_convert">unstable</a>)</span><a class="srclink" href="../../../src/core/sync/atomic.rs.html#1296-1301" title="goto source code">[src]</a></div><a href="#impl-From%3C*mut%20T%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="../../convert/trait.From.html" title="trait std::convert::From">From</a>&lt;<a class="primitive" href="../../primitive.pointer.html">*mut T</a>&gt; for <a class="struct" href="struct.AtomicPtr.html" title="struct std::sync::atomic::AtomicPtr">AtomicPtr</a>&lt;T&gt;</h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.from" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../../../src/core/sync/atomic.rs.html#1298" title="goto source code">[src]</a></div><a href="#method.from" class="anchor"></a><h4 class="code-header">pub fn <a href="../../convert/trait.From.html#tymethod.from" class="fnname">from</a>(p: <a class="primitive" href="../../primitive.pointer.html">*mut T</a>) -&gt; <a class="struct" href="struct.AtomicPtr.html" title="struct std::sync::atomic::AtomicPtr">AtomicPtr</a>&lt;T&gt;</h4></div></summary><div class='docblock'><p>Performs the conversion.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open=""><summary><div id="impl-Pointer" class="impl has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.24.0">1.24.0</span><a class="srclink" href="../../../src/core/sync/atomic.rs.html#2791-2795" title="goto source code">[src]</a></div><a href="#impl-Pointer" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="../../fmt/trait.Pointer.html" title="trait std::fmt::Pointer">Pointer</a> for <a class="struct" href="struct.AtomicPtr.html" title="struct std::sync::atomic::AtomicPtr">AtomicPtr</a>&lt;T&gt;</h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.fmt" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../../../src/core/sync/atomic.rs.html#2792" title="goto source code">[src]</a></div><a href="#method.fmt" class="anchor"></a><h4 class="code-header">pub fn <a href="../../fmt/trait.Pointer.html#tymethod.fmt" class="fnname">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="../../fmt/struct.Formatter.html" title="struct std::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="enum" href="../../result/enum.Result.html" title="enum std::result::Result">Result</a>&lt;<a class="primitive" href="../../primitive.unit.html">()</a>, <a class="struct" href="../../fmt/struct.Error.html" title="struct std::fmt::Error">Error</a>&gt;</h4></div></summary><div class='docblock'><p>Formats the value using the given formatter.</p>
</div></details></div></details><div id="impl-RefUnwindSafe" class="impl has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.14.0">1.14.0</span><a class="srclink" href="../../../src/core/panic/unwind_safe.rs.html#248" title="goto source code">[src]</a></div><a href="#impl-RefUnwindSafe" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="../../panic/trait.RefUnwindSafe.html" title="trait std::panic::RefUnwindSafe">RefUnwindSafe</a> for <a class="struct" href="struct.AtomicPtr.html" title="struct std::sync::atomic::AtomicPtr">AtomicPtr</a>&lt;T&gt;</h3></div><div id="impl-Send" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../../../src/core/sync/atomic.rs.html#182" title="goto source code">[src]</a></div><a href="#impl-Send" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="../../marker/trait.Send.html" title="trait std::marker::Send">Send</a> for <a class="struct" href="struct.AtomicPtr.html" title="struct std::sync::atomic::AtomicPtr">AtomicPtr</a>&lt;T&gt;</h3></div><div id="impl-Sync" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../../../src/core/sync/atomic.rs.html#185" title="goto source code">[src]</a></div><a href="#impl-Sync" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="../../marker/trait.Sync.html" title="trait std::marker::Sync">Sync</a> for <a class="struct" href="struct.AtomicPtr.html" title="struct std::sync::atomic::AtomicPtr">AtomicPtr</a>&lt;T&gt;</h3></div></div><h2 id="synthetic-implementations" class="small-section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor"></a></h2><div id="synthetic-implementations-list"><div id="impl-Unpin" class="impl has-srclink"><div class="rightside"></div><a href="#impl-Unpin" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="../../marker/trait.Unpin.html" title="trait std::marker::Unpin">Unpin</a> for <a class="struct" href="struct.AtomicPtr.html" title="struct std::sync::atomic::AtomicPtr">AtomicPtr</a>&lt;T&gt;</h3></div><div id="impl-UnwindSafe" class="impl has-srclink"><div class="rightside"></div><a href="#impl-UnwindSafe" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="../../panic/trait.UnwindSafe.html" title="trait std::panic::UnwindSafe">UnwindSafe</a> for <a class="struct" href="struct.AtomicPtr.html" title="struct std::sync::atomic::AtomicPtr">AtomicPtr</a>&lt;T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../panic/trait.RefUnwindSafe.html" title="trait std::panic::RefUnwindSafe">RefUnwindSafe</a>,&nbsp;</span></h3></div></div><h2 id="blanket-implementations" class="small-section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor"></a></h2><div id="blanket-implementations-list"><details class="rustdoc-toggle implementors-toggle" open=""><summary><div id="impl-Any" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../../../src/core/any.rs.html#132-136" title="goto source code">[src]</a></div><a href="#impl-Any" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="../../any/trait.Any.html" title="trait std::any::Any">Any</a> for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'static + ?<a class="trait" href="../../marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,&nbsp;</span></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.type_id" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../../../src/core/any.rs.html#133" title="goto source code">[src]</a></div><a href="#method.type_id" class="anchor"></a><h4 class="code-header">pub fn <a href="../../any/trait.Any.html#tymethod.type_id" class="fnname">type_id</a>(&amp;self) -&gt; <a class="struct" href="../../any/struct.TypeId.html" title="struct std::any::TypeId">TypeId</a></h4></div></summary><div class='docblock'><p>Gets the <code>TypeId</code> of <code>self</code>. <a href="../../any/trait.Any.html#tymethod.type_id">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open=""><summary><div id="impl-Borrow%3CT%3E" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../../../src/core/borrow.rs.html#208-213" title="goto source code">[src]</a></div><a href="#impl-Borrow%3CT%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="../../borrow/trait.Borrow.html" title="trait std::borrow::Borrow">Borrow</a>&lt;T&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="../../marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,&nbsp;</span></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.borrow" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../../../src/core/borrow.rs.html#210" title="goto source code">[src]</a></div><a href="#method.borrow" class="anchor"></a><h4 class="code-header">pub fn <a href="../../borrow/trait.Borrow.html#tymethod.borrow" class="fnname">borrow</a>(&amp;self) -&gt; <a class="primitive" href="../../primitive.reference.html">&amp;</a>T</h4></div></summary><div class='docblock'><p>Immutably borrows from an owned value. <a href="../../borrow/trait.Borrow.html#tymethod.borrow">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open=""><summary><div id="impl-BorrowMut%3CT%3E" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../../../src/core/borrow.rs.html#216-220" title="goto source code">[src]</a></div><a href="#impl-BorrowMut%3CT%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="../../borrow/trait.BorrowMut.html" title="trait std::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="../../marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,&nbsp;</span></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.borrow_mut" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../../../src/core/borrow.rs.html#217" title="goto source code">[src]</a></div><a href="#method.borrow_mut" class="anchor"></a><h4 class="code-header">pub fn <a href="../../borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fnname">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="../../primitive.reference.html">&amp;mut </a>T</h4></div></summary><div class='docblock'><p>Mutably borrows from an owned value. <a href="../../borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open=""><summary><div id="impl-From%3CT%3E" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../../../src/core/convert/mod.rs.html#549-553" title="goto source code">[src]</a></div><a href="#impl-From%3CT%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="../../convert/trait.From.html" title="trait std::convert::From">From</a>&lt;T&gt; for T</h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.from-1" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../../../src/core/convert/mod.rs.html#550" title="goto source code">[src]</a></div><a href="#method.from-1" class="anchor"></a><h4 class="code-header">pub fn <a href="../../convert/trait.From.html#tymethod.from" class="fnname">from</a>(t: T) -&gt; T</h4></div></summary><div class='docblock'><p>Performs the conversion.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open=""><summary><div id="impl-Into%3CU%3E" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../../../src/core/convert/mod.rs.html#537-544" title="goto source code">[src]</a></div><a href="#impl-Into%3CU%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, U&gt; <a class="trait" href="../../convert/trait.Into.html" title="trait std::convert::Into">Into</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="../../convert/trait.From.html" title="trait std::convert::From">From</a>&lt;T&gt;,&nbsp;</span></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.into" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../../../src/core/convert/mod.rs.html#541" title="goto source code">[src]</a></div><a href="#method.into" class="anchor"></a><h4 class="code-header">pub fn <a href="../../convert/trait.Into.html#tymethod.into" class="fnname">into</a>(self) -&gt; U</h4></div></summary><div class='docblock'><p>Performs the conversion.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open=""><summary><div id="impl-TryFrom%3CU%3E" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../../../src/core/convert/mod.rs.html#587-596" title="goto source code">[src]</a></div><a href="#impl-TryFrom%3CU%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, U&gt; <a class="trait" href="../../convert/trait.TryFrom.html" title="trait std::convert::TryFrom">TryFrom</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="../../convert/trait.Into.html" title="trait std::convert::Into">Into</a>&lt;T&gt;,&nbsp;</span></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle" open=""><summary><div id="associatedtype.Error" class="type trait-impl has-srclink"><a href="#associatedtype.Error" class="anchor"></a><h4 class="code-header">type <a href="../../convert/trait.TryFrom.html#associatedtype.Error" class="type">Error</a> = <a class="enum" href="../../convert/enum.Infallible.html" title="enum std::convert::Infallible">Infallible</a></h4></div></summary><div class='docblock'><p>The type returned in the event of a conversion error.</p>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.try_from" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../../../src/core/convert/mod.rs.html#593" title="goto source code">[src]</a></div><a href="#method.try_from" class="anchor"></a><h4 class="code-header">pub fn <a href="../../convert/trait.TryFrom.html#tymethod.try_from" class="fnname">try_from</a>(value: U) -&gt; <a class="enum" href="../../result/enum.Result.html" title="enum std::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="../../convert/trait.TryFrom.html" title="trait std::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="type" href="../../convert/trait.TryFrom.html#associatedtype.Error" title="type std::convert::TryFrom::Error">Error</a>&gt;</h4></div></summary><div class='docblock'><p>Performs the conversion.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open=""><summary><div id="impl-TryInto%3CU%3E" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../../../src/core/convert/mod.rs.html#573-582" title="goto source code">[src]</a></div><a href="#impl-TryInto%3CU%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, U&gt; <a class="trait" href="../../convert/trait.TryInto.html" title="trait std::convert::TryInto">TryInto</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="../../convert/trait.TryFrom.html" title="trait std::convert::TryFrom">TryFrom</a>&lt;T&gt;,&nbsp;</span></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle" open=""><summary><div id="associatedtype.Error-1" class="type trait-impl has-srclink"><a href="#associatedtype.Error-1" class="anchor"></a><h4 class="code-header">type <a href="../../convert/trait.TryInto.html#associatedtype.Error" class="type">Error</a> = &lt;U as <a class="trait" href="../../convert/trait.TryFrom.html" title="trait std::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="type" href="../../convert/trait.TryFrom.html#associatedtype.Error" title="type std::convert::TryFrom::Error">Error</a></h4></div></summary><div class='docblock'><p>The type returned in the event of a conversion error.</p>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.try_into" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../../../src/core/convert/mod.rs.html#579" title="goto source code">[src]</a></div><a href="#method.try_into" class="anchor"></a><h4 class="code-header">pub fn <a href="../../convert/trait.TryInto.html#tymethod.try_into" class="fnname">try_into</a>(self) -&gt; <a class="enum" href="../../result/enum.Result.html" title="enum std::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="../../convert/trait.TryFrom.html" title="trait std::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="type" href="../../convert/trait.TryFrom.html#associatedtype.Error" title="type std::convert::TryFrom::Error">Error</a>&gt;</h4></div></summary><div class='docblock'><p>Performs the conversion.</p>
</div></details></div></details></div></section><section id="search" class="content hidden"></section><div id="rustdoc-vars" data-root-path="../../../" data-current-crate="std" data-search-index-js="../../../search-index1.58.0.js" data-search-js="../../../search1.58.0.js"></div>
</body></html>