<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="An integer type which can be safely shared between threads."><meta name="keywords" content="rust, rustlang, rust-lang, AtomicI32"><title>AtomicI32 in std::sync::atomic - Rust</title><link rel="stylesheet" type="text/css" href="../../../normalize1.56.1.css"><link rel="stylesheet" type="text/css" href="../../../rustdoc1.56.1.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../../light1.56.1.css" id="themeStyle"><link rel="stylesheet" type="text/css" href="../../../dark1.56.1.css" disabled=""><link rel="stylesheet" type="text/css" href="../../../ayu1.56.1.css" disabled=""><script id="default-settings"></script><script src="../../../storage1.56.1.js"></script><script src="../../../crates1.56.1.js"></script><noscript><link rel="stylesheet" href="../../../noscript1.56.1.css"></noscript><link rel="alternate icon" type="image/png" href="../../../favicon-16x161.56.1.png"><link rel="alternate icon" type="image/png" href="../../../favicon-32x321.56.1.png"><link rel="icon" type="image/svg+xml" href="../../../favicon1.56.1.svg"><style type="text/css">#crate-search{background-image:url("../../../down-arrow1.56.1.svg");}</style></head><body class="rustdoc struct"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu" role="button">&#9776;</div><a href='../../../std/index.html'><div class='logo-container rust-logo'><img src='../../../rust-logo1.56.1.png' alt='logo'></div></a><h2 class="location">Struct AtomicI32</h2><div class="sidebar-elems"><div class="block items"><h3 class="sidebar-title"><a href="#implementations">Methods</a></h3><div class="sidebar-links"><a href="#method.as_mut_ptr">as_mut_ptr</a><a href="#method.compare_and_swap">compare_and_swap</a><a href="#method.compare_exchange">compare_exchange</a><a href="#method.compare_exchange_weak">compare_exchange_weak</a><a href="#method.fetch_add">fetch_add</a><a href="#method.fetch_and">fetch_and</a><a href="#method.fetch_max">fetch_max</a><a href="#method.fetch_min">fetch_min</a><a href="#method.fetch_nand">fetch_nand</a><a href="#method.fetch_or">fetch_or</a><a href="#method.fetch_sub">fetch_sub</a><a href="#method.fetch_update">fetch_update</a><a href="#method.fetch_xor">fetch_xor</a><a href="#method.from_mut">from_mut</a><a href="#method.get_mut">get_mut</a><a href="#method.into_inner">into_inner</a><a href="#method.load">load</a><a href="#method.new">new</a><a href="#method.store">store</a><a href="#method.swap">swap</a></div><h3 class="sidebar-title"><a href="#trait-implementations">Trait Implementations</a></h3><div class="sidebar-links"><a href="#impl-Debug">Debug</a><a href="#impl-Default">Default</a><a href="#impl-From%3Ci32%3E">From&lt;i32&gt;</a><a href="#impl-RefUnwindSafe">RefUnwindSafe</a><a href="#impl-Sync">Sync</a></div><h3 class="sidebar-title"><a href="#synthetic-implementations">Auto Trait Implementations</a></h3><div class="sidebar-links"><a href="#impl-Send">Send</a><a href="#impl-Unpin">Unpin</a><a href="#impl-UnwindSafe">UnwindSafe</a></div><h3 class="sidebar-title"><a href="#blanket-implementations">Blanket Implementations</a></h3><div class="sidebar-links"><a href="#impl-Any">Any</a><a href="#impl-Borrow%3CT%3E">Borrow&lt;T&gt;</a><a href="#impl-BorrowMut%3CT%3E">BorrowMut&lt;T&gt;</a><a href="#impl-From%3CT%3E">From&lt;T&gt;</a><a href="#impl-Into%3CU%3E">Into&lt;U&gt;</a><a href="#impl-TryFrom%3CU%3E">TryFrom&lt;U&gt;</a><a href="#impl-TryInto%3CU%3E">TryInto&lt;U&gt;</a></div></div><h2 class="location">Other items in<br><a href="../../index.html">std</a>::<wbr><a href="../index.html">sync</a>::<wbr><a href="index.html">atomic</a></h2><div id="sidebar-vars" data-name="AtomicI32" data-ty="struct" data-relpath=""></div><script defer="" src="sidebar-items.js"></script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu" title="themes"><img width="18" height="18" alt="Pick another theme!" src="../../../brush1.56.1.svg"></button><div id="theme-choices" role="menu"></div></div><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" disabled="" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><button type="button" id="help-button" title="help">?</button><a id="settings-menu" href="../../../settings.html" title="settings"><img width="18" height="18" alt="Change settings" src="../../../wheel1.56.1.svg"></a></div></form></nav><section id="main" class="content"><h1 class="fqn"><span class="in-band">Struct <a href="../../index.html">std</a>::<wbr><a href="../index.html">sync</a>::<wbr><a href="index.html">atomic</a>::<wbr><a class="struct" href="#">AtomicI32</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../../../clipboard1.56.1.svg" width="19" height="18" alt="Copy item path"></button></span><span class="out-of-band"><span class="since" title="Stable since Rust version 1.34.0">1.34.0</span><span id="render-detail"><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span><a class="srclink" href="../../../src/core/sync/atomic.rs.html#2162-2179" title="goto source code">[src]</a></span></h1><div class="docblock type-decl"><pre class="rust struct"><code><div class="code-attribute">#[repr(C, align(4))]</div>pub struct AtomicI32 { /* fields omitted */ }</code></pre></div><details class="rustdoc-toggle top-doc" open=""><summary class="hideme"><span>Expand description</span></summary><div class="docblock" xpath="/html[1]/body[1]/section[1]/details[1]/div[1]" istranslationnode="true" main_mp="Y25yZD4/d3xuYjo7ZXFraHlyKitVYXt4eXJZIiY=" sub_mp="[&quot;c3VkOz52fWtjOzpgcGppbHMrKlBgenl8c1gjIw==&quot;]"><p class="translate-text">可以在线程之间安全共享的整数类型。</p><p>An integer type which can be safely shared between threads.</p>
<p class="translate-text">此类型与底层整数类型 i32 具有相同的内存表示。 有关原子类型和非原子类型之间的差异以及有关此类型可移植性的信息的更多信息，请参阅模块级文档。</p><p>This type has the same in-memory representation as the underlying
integer type, <a href="../../primitive.i32.html" title="i32"><code>i32</code></a>. For more about the differences between atomic types and
non-atomic types as well as information about the portability of
this type, please see the <a href="index.html">module-level documentation</a>.</p>
<p class="translate-text">注意：此类型仅在支持 i32 的原子加载和存储的平台上可用。</p><p><strong>Note:</strong> This type is only available on platforms that support
atomic loads and stores of <a href="../../primitive.i32.html" title="i32"><code>i32</code></a>.</p>
</div></details><h2 id="implementations" class="small-section-header">Implementations<a href="#implementations" class="anchor"></a></h2><details class="rustdoc-toggle implementors-toggle" open=""><summary><div id="impl" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../../../src/core/sync/atomic.rs.html#2162-2179" title="goto source code">[src]</a></div><a href="#impl" class="anchor"></a><h3 class="code-header in-band">impl <a class="struct" href="struct.AtomicI32.html" title="struct std::sync::atomic::AtomicI32">AtomicI32</a></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.new" class="method has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.34.0, const since 1.34.0">1.34.0 (const: 1.34.0)</span><a class="srclink" href="../../../src/core/sync/atomic.rs.html#2162-2179" title="goto source code">[src]</a></div><a href="#method.new" class="anchor"></a><h4 class="code-header">pub const fn <a href="#method.new" class="fnname">new</a>(v: <a class="primitive" href="../../primitive.i32.html">i32</a>) -&gt; <a class="struct" href="struct.AtomicI32.html" title="struct std::sync::atomic::AtomicI32">AtomicI32</a></h4></div></summary><div class="docblock" xpath="/html[1]/body[1]/section[1]/details[2]/div[1]/details[1]/div[1]" istranslationnode="true" main_mp="Y25yZD4/d3xuYjo7ZXFraHlyKitVYXt4eXJZIiYvLntFVg==" sub_mp="[&quot;c3VkOz52fWtjOzpgcGppbHMrKlBgenl8c1gjIy4venBX&quot;]"><p class="translate-text">创建一个新的原子整数。</p><p>Creates a new atomic integer.</p>
<h1 id="examples" class="section-header"><a href="#examples">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">std::sync::atomic::AtomicI32</span>;

<span class="kw">let</span> <span class="ident">atomic_forty_two</span> <span class="op">=</span> <span class="ident">AtomicI32::new</span>(<span class="number">42</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Ause%20std%3A%3Async%3A%3Aatomic%3A%3AAtomicI32%3B%0A%0Alet%20atomic_forty_two%20%3D%20AtomicI32%3A%3Anew(42)%3B%0A%7D&amp;edition=2018">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.get_mut" class="method has-srclink"><div class="rightside"><a class="srclink" href="../../../src/core/sync/atomic.rs.html#2162-2179" title="goto source code">[src]</a></div><a href="#method.get_mut" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.get_mut" class="fnname">get_mut</a>(&amp;mut self) -&gt; &amp;mut <a class="primitive" href="../../primitive.i32.html">i32</a></h4></div></summary><div class="docblock" xpath="/html[1]/body[1]/section[1]/details[2]/div[1]/details[2]/div[1]" istranslationnode="true" main_mp="Y25yZD4/d3xuYjo7ZXFraHlyKitVYXt4eXJZIiYvLnJFVX9MUVE=" sub_mp="[&quot;c3VkOz52fWtjOzpgcGppbHMrKlBgenl8c1gjIy4vc3BUfk1UUA==&quot;]"><p class="translate-text">返回对基础整数的可变引用。</p><p>Returns a mutable reference to the underlying integer.</p>
<p class="translate-text">这是安全的，因为可变引用保证没有其他线程同时访问原子数据。</p><p>This is safe because the mutable reference guarantees that no other threads are
concurrently accessing the atomic data.</p>
<h1 id="examples-1" class="section-header"><a href="#examples-1">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">std::sync::atomic</span>::{<span class="ident">AtomicI32</span>, <span class="ident">Ordering</span>};

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">some_var</span> <span class="op">=</span> <span class="ident">AtomicI32::new</span>(<span class="number">10</span>);
<span class="macro">assert_eq!</span>(<span class="kw-2">*</span><span class="ident">some_var</span>.<span class="ident">get_mut</span>(), <span class="number">10</span>);
<span class="kw-2">*</span><span class="ident">some_var</span>.<span class="ident">get_mut</span>() <span class="op">=</span> <span class="number">5</span>;
<span class="macro">assert_eq!</span>(<span class="ident">some_var</span>.<span class="ident">load</span>(<span class="ident">Ordering::SeqCst</span>), <span class="number">5</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Ause%20std%3A%3Async%3A%3Aatomic%3A%3A%7BAtomicI32%2C%20Ordering%7D%3B%0A%0Alet%20mut%20some_var%20%3D%20AtomicI32%3A%3Anew(10)%3B%0Aassert_eq!(*some_var.get_mut()%2C%2010)%3B%0A*some_var.get_mut()%20%3D%205%3B%0Aassert_eq!(some_var.load(Ordering%3A%3ASeqCst)%2C%205)%3B%0A%7D&amp;edition=2018">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.from_mut" class="method has-srclink"><div class="rightside"><a class="srclink" href="../../../src/core/sync/atomic.rs.html#2162-2179" title="goto source code">[src]</a></div><a href="#method.from_mut" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.from_mut" class="fnname">from_mut</a>(v: &amp;mut <a class="primitive" href="../../primitive.i32.html">i32</a>) -&gt; &amp;<a class="struct" href="struct.AtomicI32.html" title="struct std::sync::atomic::AtomicI32">AtomicI32</a></h4></div><div class="item-info"><div class="stab unstable"><span class="emoji">🔬</span> This is a nightly-only experimental API. (<code>atomic_from_mut</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/76314">#76314</a>)</div></div></summary><div class="docblock" xpath="/html[1]/body[1]/section[1]/details[2]/div[1]/details[3]/div[1]" istranslationnode="true" main_mp="Y25yZD4/d3xuYjo7ZXFraHlyKitVYXt4eXJZIiYvLnNSTk1+SVBQ" sub_mp="[&quot;c3VkOz52fWtjOzpgcGppbHMrKlBgenl8c1gjIy4vcmdPTH9MUVE=&quot;]"><p class="translate-text">获得对 &mut i32 的原子访问。</p><p>Get atomic access to a <code>&amp;mut i32</code>.</p>
<p class="translate-text">注意：此功能仅适用于 i32 对齐为 4 字节的目标。</p><p><strong>Note:</strong> This function is only available on targets where <code>i32</code> has an alignment of 4 bytes.</p>
<h1 id="examples-2" class="section-header"><a href="#examples-2">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attribute">#![<span class="ident">feature</span>(<span class="ident">atomic_from_mut</span>)]</span>
<span class="kw">use</span> <span class="ident">std::sync::atomic</span>::{<span class="ident">AtomicI32</span>, <span class="ident">Ordering</span>};

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">some_int</span> <span class="op">=</span> <span class="number">123</span>;
<span class="kw">let</span> <span class="ident">a</span> <span class="op">=</span> <span class="ident">AtomicI32::from_mut</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">some_int</span>);
<span class="ident">a</span>.<span class="ident">store</span>(<span class="number">100</span>, <span class="ident">Ordering::Relaxed</span>);
<span class="macro">assert_eq!</span>(<span class="ident">some_int</span>, <span class="number">100</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(atomic_from_mut)%5D%0Afn%20main()%20%7B%0Ause%20std%3A%3Async%3A%3Aatomic%3A%3A%7BAtomicI32%2C%20Ordering%7D%3B%0A%0Alet%20mut%20some_int%20%3D%20123%3B%0Alet%20a%20%3D%20AtomicI32%3A%3Afrom_mut(%26mut%20some_int)%3B%0Aa.store(100%2C%20Ordering%3A%3ARelaxed)%3B%0Aassert_eq!(some_int%2C%20100)%3B%0A%7D&amp;version=nightly&amp;edition=2018">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.into_inner" class="method has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.34.0, const unstable">1.34.0 (const: <a href="https://github.com/rust-lang/rust/issues/78729" title="Tracking issue for const_cell_into_inner">unstable</a>)</span><a class="srclink" href="../../../src/core/sync/atomic.rs.html#2162-2179" title="goto source code">[src]</a></div><a href="#method.into_inner" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.into_inner" class="fnname">into_inner</a>(self) -&gt; <a class="primitive" href="../../primitive.i32.html">i32</a></h4></div></summary><div class="docblock" xpath="/html[1]/body[1]/section[1]/details[2]/div[1]/details[4]/div[1]" istranslationnode="true" main_mp="Y25yZD4/d3xuYjo7ZXFraHlyKitVYXt4eXJZIiYvLnxOVU9+TUtKQFI=" sub_mp="[&quot;c3VkOz52fWtjOzpgcGppbHMrKlBgenl8c1gjIy4vfXtUTn9ISktBVw==&quot;]"><p class="translate-text">使用原子并返回包含的值。</p><p>Consumes the atomic and returns the contained value.</p>
<p class="translate-text">这是安全的，因为按值传递 self 可以保证没有其他线程同时访问原子数据。</p><p>This is safe because passing <code>self</code> by value guarantees that no other threads are
concurrently accessing the atomic data.</p>
<h1 id="examples-3" class="section-header"><a href="#examples-3">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">std::sync::atomic::AtomicI32</span>;

<span class="kw">let</span> <span class="ident">some_var</span> <span class="op">=</span> <span class="ident">AtomicI32::new</span>(<span class="number">5</span>);
<span class="macro">assert_eq!</span>(<span class="ident">some_var</span>.<span class="ident">into_inner</span>(), <span class="number">5</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Ause%20std%3A%3Async%3A%3Aatomic%3A%3AAtomicI32%3B%0A%0Alet%20some_var%20%3D%20AtomicI32%3A%3Anew(5)%3B%0Aassert_eq!(some_var.into_inner()%2C%205)%3B%0A%7D&amp;edition=2018">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.load" class="method has-srclink"><div class="rightside"><a class="srclink" href="../../../src/core/sync/atomic.rs.html#2162-2179" title="goto source code">[src]</a></div><a href="#method.load" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.load" class="fnname">load</a>(&amp;self, order: <a class="enum" href="enum.Ordering.html" title="enum std::sync::atomic::Ordering">Ordering</a>) -&gt; <a class="primitive" href="../../primitive.i32.html">i32</a></h4></div></summary><div class="docblock" xpath="/html[1]/body[1]/section[1]/details[2]/div[1]/details[5]/div[1]" istranslationnode="true" main_mp="Y25yZD4/d3xuYjo7ZXFraHlyKitVYXt4eXJZIiYvLnlPQEQ=" sub_mp="[&quot;c3VkOz52fWtjOzpgcGppbHMrKlBgenl8c1gjIy4veHpBRQ==&quot;]"><p class="translate-text">从原子整数加载一个值。</p><p>Loads a value from the atomic integer.</p>
<p class="translate-text">load 接受一个描述此操作的内存排序的 Ordering 参数。 可能的值为 SeqCst、Acquire 和 Relaxed。</p><p><code>load</code> takes an <a href="enum.Ordering.html" title="Ordering"><code>Ordering</code></a> argument which describes the memory ordering of this operation.
Possible values are <a href="enum.Ordering.html#variant.SeqCst" title="SeqCst"><code>SeqCst</code></a>, <a href="enum.Ordering.html#variant.Acquire" title="Acquire"><code>Acquire</code></a> and <a href="enum.Ordering.html#variant.Relaxed" title="Relaxed"><code>Relaxed</code></a>.</p>
<h1 id="panics" class="section-header"><a href="#panics">Panics</a></h1>
<p class="translate-text">如果订单是 Release 或 AcqRel，则会出现panic。</p><p>Panics if <code>order</code> is <a href="enum.Ordering.html#variant.Release" title="Release"><code>Release</code></a> or <a href="enum.Ordering.html#variant.AcqRel" title="AcqRel"><code>AcqRel</code></a>.</p>
<h1 id="examples-4" class="section-header"><a href="#examples-4">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">std::sync::atomic</span>::{<span class="ident">AtomicI32</span>, <span class="ident">Ordering</span>};

<span class="kw">let</span> <span class="ident">some_var</span> <span class="op">=</span> <span class="ident">AtomicI32::new</span>(<span class="number">5</span>);

<span class="macro">assert_eq!</span>(<span class="ident">some_var</span>.<span class="ident">load</span>(<span class="ident">Ordering::Relaxed</span>), <span class="number">5</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Ause%20std%3A%3Async%3A%3Aatomic%3A%3A%7BAtomicI32%2C%20Ordering%7D%3B%0A%0Alet%20some_var%20%3D%20AtomicI32%3A%3Anew(5)%3B%0A%0Aassert_eq!(some_var.load(Ordering%3A%3ARelaxed)%2C%205)%3B%0A%7D&amp;edition=2018">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.store" class="method has-srclink"><div class="rightside"><a class="srclink" href="../../../src/core/sync/atomic.rs.html#2162-2179" title="goto source code">[src]</a></div><a href="#method.store" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.store" class="fnname">store</a>(&amp;self, val: <a class="primitive" href="../../primitive.i32.html">i32</a>, order: <a class="enum" href="enum.Ordering.html" title="enum std::sync::atomic::Ordering">Ordering</a>)</h4></div></summary><div class="docblock" xpath="/html[1]/body[1]/section[1]/details[2]/div[1]/details[6]/div[1]" istranslationnode="true" main_mp="Y25yZD4/d3xuYjo7ZXFraHlyKitVYXt4eXJZIiYvLmZUTlJE" sub_mp="[&quot;c3VkOz52fWtjOzpgcGppbHMrKlBgenl8c1gjIy4vZ2FPU0U=&quot;]"><p class="translate-text">将值存储到原子整数中。</p><p>Stores a value into the atomic integer.</p>
<p class="translate-text">store 接受一个 Ordering 参数，该参数描述了此操作的内存顺序。 可能的值是 SeqCst、Release 和 Relaxed。</p><p><code>store</code> takes an <a href="enum.Ordering.html" title="Ordering"><code>Ordering</code></a> argument which describes the memory ordering of this operation.
Possible values are <a href="enum.Ordering.html#variant.SeqCst" title="SeqCst"><code>SeqCst</code></a>, <a href="enum.Ordering.html#variant.Release" title="Release"><code>Release</code></a> and <a href="enum.Ordering.html#variant.Relaxed" title="Relaxed"><code>Relaxed</code></a>.</p>
<h1 id="panics-1" class="section-header"><a href="#panics-1">Panics</a></h1>
<p class="translate-text">如果订单是 Acquire 或 AcqRel，则会出现panic。</p><p>Panics if <code>order</code> is <a href="enum.Ordering.html#variant.Acquire" title="Acquire"><code>Acquire</code></a> or <a href="enum.Ordering.html#variant.AcqRel" title="AcqRel"><code>AcqRel</code></a>.</p>
<h1 id="examples-5" class="section-header"><a href="#examples-5">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">std::sync::atomic</span>::{<span class="ident">AtomicI32</span>, <span class="ident">Ordering</span>};

<span class="kw">let</span> <span class="ident">some_var</span> <span class="op">=</span> <span class="ident">AtomicI32::new</span>(<span class="number">5</span>);

<span class="ident">some_var</span>.<span class="ident">store</span>(<span class="number">10</span>, <span class="ident">Ordering::Relaxed</span>);
<span class="macro">assert_eq!</span>(<span class="ident">some_var</span>.<span class="ident">load</span>(<span class="ident">Ordering::Relaxed</span>), <span class="number">10</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Ause%20std%3A%3Async%3A%3Aatomic%3A%3A%7BAtomicI32%2C%20Ordering%7D%3B%0A%0Alet%20some_var%20%3D%20AtomicI32%3A%3Anew(5)%3B%0A%0Asome_var.store(10%2C%20Ordering%3A%3ARelaxed)%3B%0Aassert_eq!(some_var.load(Ordering%3A%3ARelaxed)%2C%2010)%3B%0A%7D&amp;edition=2018">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.swap" class="method has-srclink"><div class="rightside"><a class="srclink" href="../../../src/core/sync/atomic.rs.html#2162-2179" title="goto source code">[src]</a></div><a href="#method.swap" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.swap" class="fnname">swap</a>(&amp;self, val: <a class="primitive" href="../../primitive.i32.html">i32</a>, order: <a class="enum" href="enum.Ordering.html" title="enum std::sync::atomic::Ordering">Ordering</a>) -&gt; <a class="primitive" href="../../primitive.i32.html">i32</a></h4></div></summary><div class="docblock" xpath="/html[1]/body[1]/section[1]/details[2]/div[1]/details[7]/div[1]" istranslationnode="true" main_mp="Y25yZD4/d3xuYjo7ZXFraHlyKitVYXt4eXJZIiYvLmZXQFA=" sub_mp="[&quot;c3VkOz52fWtjOzpgcGppbHMrKlBgenl8c1gjIy4vZ2JBUQ==&quot;]"><p class="translate-text">将值存储到原子整数中，返回前一个值。</p><p>Stores a value into the atomic integer, returning the previous value.</p>
<p class="translate-text">swap 接受一个 Ordering 参数，该参数描述了此操作的内存顺序。 所有订购模式都是可能的。 请注意，使用 Acquire 使该操作的存储部分变得轻松，而使用 Release 使加载部分变得轻松。</p><p><code>swap</code> takes an <a href="enum.Ordering.html" title="Ordering"><code>Ordering</code></a> argument which describes the memory ordering
of this operation. All ordering modes are possible. Note that using
<a href="enum.Ordering.html#variant.Acquire" title="Acquire"><code>Acquire</code></a> makes the store part of this operation <a href="enum.Ordering.html#variant.Relaxed" title="Relaxed"><code>Relaxed</code></a>, and
using <a href="enum.Ordering.html#variant.Release" title="Release"><code>Release</code></a> makes the load part <a href="enum.Ordering.html#variant.Relaxed" title="Relaxed"><code>Relaxed</code></a>.</p>
<p class="translate-text">注意：此方法仅在支持 i32 上的原子操作的平台上可用。</p><p><strong>Note</strong>: This method is only available on platforms that support atomic operations on
<a href="../../primitive.i32.html" title="i32"><code>i32</code></a>.</p>
<h1 id="examples-6" class="section-header"><a href="#examples-6">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">std::sync::atomic</span>::{<span class="ident">AtomicI32</span>, <span class="ident">Ordering</span>};

<span class="kw">let</span> <span class="ident">some_var</span> <span class="op">=</span> <span class="ident">AtomicI32::new</span>(<span class="number">5</span>);

<span class="macro">assert_eq!</span>(<span class="ident">some_var</span>.<span class="ident">swap</span>(<span class="number">10</span>, <span class="ident">Ordering::Relaxed</span>), <span class="number">5</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Ause%20std%3A%3Async%3A%3Aatomic%3A%3A%7BAtomicI32%2C%20Ordering%7D%3B%0A%0Alet%20some_var%20%3D%20AtomicI32%3A%3Anew(5)%3B%0A%0Aassert_eq!(some_var.swap(10%2C%20Ordering%3A%3ARelaxed)%2C%205)%3B%0A%7D&amp;edition=2018">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.compare_and_swap" class="method has-srclink"><div class="rightside"><a class="srclink" href="../../../src/core/sync/atomic.rs.html#2162-2179" title="goto source code">[src]</a></div><a href="#method.compare_and_swap" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.compare_and_swap" class="fnname">compare_and_swap</a>(&amp;self, current: <a class="primitive" href="../../primitive.i32.html">i32</a>, new: <a class="primitive" href="../../primitive.i32.html">i32</a>, order: <a class="enum" href="enum.Ordering.html" title="enum std::sync::atomic::Ordering">Ordering</a>) -&gt; <a class="primitive" href="../../primitive.i32.html">i32</a></h4></div><div class="item-info"><div class="stab deprecated"><span class="emoji">👎</span> Deprecated since 1.50.0: <p>Use <code>compare_exchange</code> or <code>compare_exchange_weak</code> instead</p>
</div></div></summary><div class="docblock" xpath="/html[1]/body[1]/section[1]/details[2]/div[1]/details[8]/div[1]" istranslationnode="true" main_mp="Y25yZD4/d3xuYjo7ZXFraHlyKitVYXt4eXJZIiYvLnZPTFBAVkB7RE5Ff1JTRFQ=" sub_mp="[&quot;c3VkOz52fWtjOzpgcGppbHMrKlBgenl8c1gjIy4vd3pNUUFTQXpFS0R+U1ZFVQ==&quot;]"><p class="translate-text">如果当前值与当前值相同，则将值存储到原子整数中。</p><p>Stores a value into the atomic integer if the current value is the same as
the <code>current</code> value.</p>
<p class="translate-text">返回值始终是前一个值。 如果它等于当前，则该值已更新。</p><p>The return value is always the previous value. If it is equal to <code>current</code>, then the
value was updated.</p>
<p class="translate-text">compare_and_swap 还接受一个描述此操作的内存顺序的 Ordering 参数。 请注意，即使使用 AcqRel，操作也可能会失败，因此只执行 Acquire 加载，但没有 Release 语义。 如果发生这种情况，使用 Acquire 会使该操作的存储部分变得轻松，而使用 Release 会使加载部分变得轻松。</p><p><code>compare_and_swap</code> also takes an <a href="enum.Ordering.html" title="Ordering"><code>Ordering</code></a> argument which describes the memory
ordering of this operation. Notice that even when using <a href="enum.Ordering.html#variant.AcqRel" title="AcqRel"><code>AcqRel</code></a>, the operation
might fail and hence just perform an <code>Acquire</code> load, but not have <code>Release</code> semantics.
Using <a href="enum.Ordering.html#variant.Acquire" title="Acquire"><code>Acquire</code></a> makes the store part of this operation <a href="enum.Ordering.html#variant.Relaxed" title="Relaxed"><code>Relaxed</code></a> if it
happens, and using <a href="enum.Ordering.html#variant.Release" title="Release"><code>Release</code></a> makes the load part <a href="enum.Ordering.html#variant.Relaxed" title="Relaxed"><code>Relaxed</code></a>.</p>
<p class="translate-text">注意：此方法仅在支持 i32 上的原子操作的平台上可用。</p><p><strong>Note</strong>: This method is only available on platforms that support atomic operations on
<a href="../../primitive.i32.html" title="i32"><code>i32</code></a>.</p>
<h1 id="migrating-to-compare_exchange-and-compare_exchange_weak" class="section-header"><a href="#migrating-to-compare_exchange-and-compare_exchange_weak">Migrating to <code>compare_exchange</code> and <code>compare_exchange_weak</code></a></h1>
<p class="translate-text">compare_and_swap 等价于 compare_exchange，具有以下内存排序映射：</p><p><code>compare_and_swap</code> is equivalent to <code>compare_exchange</code> with the following mapping for
memory orderings:</p>
<table><thead><tr><th>Original</th><th>Success</th><th>Failure</th></tr></thead><tbody>
<tr><td>Relaxed</td><td>Relaxed</td><td>Relaxed</td></tr>
<tr><td>Acquire</td><td>Acquire</td><td>Acquire</td></tr>
<tr><td>Release</td><td>Release</td><td>Relaxed</td></tr>
<tr><td>AcqRel</td><td>AcqRel</td><td>Acquire</td></tr>
<tr><td>SeqCst</td><td>SeqCst</td><td>SeqCst</td></tr>
</tbody></table>
<p class="translate-text">即使比较成功，compare_exchange_weak 也允许虚假失败，这允许编译器在循环中使用比较和交换时生成更好的汇编代码。</p><p><code>compare_exchange_weak</code> is allowed to fail spuriously even when the comparison succeeds,
which allows the compiler to generate better assembly code when the compare and swap
is used in a loop.</p>
<h1 id="examples-7" class="section-header"><a href="#examples-7">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">std::sync::atomic</span>::{<span class="ident">AtomicI32</span>, <span class="ident">Ordering</span>};

<span class="kw">let</span> <span class="ident">some_var</span> <span class="op">=</span> <span class="ident">AtomicI32::new</span>(<span class="number">5</span>);

<span class="macro">assert_eq!</span>(<span class="ident">some_var</span>.<span class="ident">compare_and_swap</span>(<span class="number">5</span>, <span class="number">10</span>, <span class="ident">Ordering::Relaxed</span>), <span class="number">5</span>);
<span class="macro">assert_eq!</span>(<span class="ident">some_var</span>.<span class="ident">load</span>(<span class="ident">Ordering::Relaxed</span>), <span class="number">10</span>);

<span class="macro">assert_eq!</span>(<span class="ident">some_var</span>.<span class="ident">compare_and_swap</span>(<span class="number">6</span>, <span class="number">12</span>, <span class="ident">Ordering::Relaxed</span>), <span class="number">10</span>);
<span class="macro">assert_eq!</span>(<span class="ident">some_var</span>.<span class="ident">load</span>(<span class="ident">Ordering::Relaxed</span>), <span class="number">10</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Ause%20std%3A%3Async%3A%3Aatomic%3A%3A%7BAtomicI32%2C%20Ordering%7D%3B%0A%0Alet%20some_var%20%3D%20AtomicI32%3A%3Anew(5)%3B%0A%0Aassert_eq!(some_var.compare_and_swap(5%2C%2010%2C%20Ordering%3A%3ARelaxed)%2C%205)%3B%0Aassert_eq!(some_var.load(Ordering%3A%3ARelaxed)%2C%2010)%3B%0A%0Aassert_eq!(some_var.compare_and_swap(6%2C%2012%2C%20Ordering%3A%3ARelaxed)%2C%2010)%3B%0Aassert_eq!(some_var.load(Ordering%3A%3ARelaxed)%2C%2010)%3B%0A%7D&amp;edition=2018">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.compare_exchange" class="method has-srclink"><div class="rightside"><a class="srclink" href="../../../src/core/sync/atomic.rs.html#2162-2179" title="goto source code">[src]</a></div><a href="#method.compare_exchange" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.compare_exchange" class="fnname">compare_exchange</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;current: <a class="primitive" href="../../primitive.i32.html">i32</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;new: <a class="primitive" href="../../primitive.i32.html">i32</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;success: <a class="enum" href="enum.Ordering.html" title="enum std::sync::atomic::Ordering">Ordering</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;failure: <a class="enum" href="enum.Ordering.html" title="enum std::sync::atomic::Ordering">Ordering</a><br>) -&gt; <a class="enum" href="../../result/enum.Result.html" title="enum std::result::Result">Result</a>&lt;<a class="primitive" href="../../primitive.i32.html">i32</a>, <a class="primitive" href="../../primitive.i32.html">i32</a>&gt;</h4></div></summary><div class="docblock" xpath="/html[1]/body[1]/section[1]/details[2]/div[1]/details[9]/div[1]" istranslationnode="true" main_mp="Y25yZD4/d3xuYjo7ZXFraHlyKitVYXt4eXJZIiYvLnZPTFBAVkB7QFhCSEBKQkE=" sub_mp="[&quot;c3VkOz52fWtjOzpgcGppbHMrKlBgenl8c1gjIy4vd3pNUUFTQXpBXUNJQU9DQA==&quot;]"><p class="translate-text">如果当前值与当前值相同，则将值存储到原子整数中。</p><p>Stores a value into the atomic integer if the current value is the same as
the <code>current</code> value.</p>
<p class="translate-text">返回值是指示是否写入新值并包含先前值的结果。 成功时，此值保证等于当前值。</p><p>The return value is a result indicating whether the new value was written and
containing the previous value. On success this value is guaranteed to be equal to
<code>current</code>.</p>
<p class="translate-text">compare_exchange 采用两个 Ordering 参数来描述此操作的内存顺序。 成功描述了在与当前比较成功时发生的读取-修改-写入操作所需的顺序。 failure 描述了比较失败时发生的加载操作所需的顺序。 使用 Acquire 作为成功排序使该操作的存储部分变得轻松，使用 Release 使成功加载变得轻松。 失败排序只能是 SeqCst、Acquire 或 Relaxed，并且必须等于或弱于成功排序。</p><p><code>compare_exchange</code> takes two <a href="enum.Ordering.html" title="Ordering"><code>Ordering</code></a> arguments to describe the memory
ordering of this operation. <code>success</code> describes the required ordering for the
read-modify-write operation that takes place if the comparison with <code>current</code> succeeds.
<code>failure</code> describes the required ordering for the load operation that takes place when
the comparison fails. Using <a href="enum.Ordering.html#variant.Acquire" title="Acquire"><code>Acquire</code></a> as success ordering makes the store part
of this operation <a href="enum.Ordering.html#variant.Relaxed" title="Relaxed"><code>Relaxed</code></a>, and using <a href="enum.Ordering.html#variant.Release" title="Release"><code>Release</code></a> makes the successful load
<a href="enum.Ordering.html#variant.Relaxed" title="Relaxed"><code>Relaxed</code></a>. The failure ordering can only be <a href="enum.Ordering.html#variant.SeqCst" title="SeqCst"><code>SeqCst</code></a>, <a href="enum.Ordering.html#variant.Acquire" title="Acquire"><code>Acquire</code></a> or <a href="enum.Ordering.html#variant.Relaxed" title="Relaxed"><code>Relaxed</code></a>
and must be equivalent to or weaker than the success ordering.</p>
<p class="translate-text">注意：此方法仅在支持 i32 上的原子操作的平台上可用。</p><p><strong>Note</strong>: This method is only available on platforms that support atomic operations on
<a href="../../primitive.i32.html" title="i32"><code>i32</code></a>.</p>
<h1 id="examples-8" class="section-header"><a href="#examples-8">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">std::sync::atomic</span>::{<span class="ident">AtomicI32</span>, <span class="ident">Ordering</span>};

<span class="kw">let</span> <span class="ident">some_var</span> <span class="op">=</span> <span class="ident">AtomicI32::new</span>(<span class="number">5</span>);

<span class="macro">assert_eq!</span>(<span class="ident">some_var</span>.<span class="ident">compare_exchange</span>(<span class="number">5</span>, <span class="number">10</span>,
                                     <span class="ident">Ordering::Acquire</span>,
                                     <span class="ident">Ordering::Relaxed</span>),
           <span class="prelude-val">Ok</span>(<span class="number">5</span>));
<span class="macro">assert_eq!</span>(<span class="ident">some_var</span>.<span class="ident">load</span>(<span class="ident">Ordering::Relaxed</span>), <span class="number">10</span>);

<span class="macro">assert_eq!</span>(<span class="ident">some_var</span>.<span class="ident">compare_exchange</span>(<span class="number">6</span>, <span class="number">12</span>,
                                     <span class="ident">Ordering::SeqCst</span>,
                                     <span class="ident">Ordering::Acquire</span>),
           <span class="prelude-val">Err</span>(<span class="number">10</span>));
<span class="macro">assert_eq!</span>(<span class="ident">some_var</span>.<span class="ident">load</span>(<span class="ident">Ordering::Relaxed</span>), <span class="number">10</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Ause%20std%3A%3Async%3A%3Aatomic%3A%3A%7BAtomicI32%2C%20Ordering%7D%3B%0A%0Alet%20some_var%20%3D%20AtomicI32%3A%3Anew(5)%3B%0A%0Aassert_eq!(some_var.compare_exchange(5%2C%2010%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20Ordering%3A%3AAcquire%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20Ordering%3A%3ARelaxed)%2C%0A%20%20%20%20%20%20%20%20%20%20%20Ok(5))%3B%0Aassert_eq!(some_var.load(Ordering%3A%3ARelaxed)%2C%2010)%3B%0A%0Aassert_eq!(some_var.compare_exchange(6%2C%2012%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20Ordering%3A%3ASeqCst%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20Ordering%3A%3AAcquire)%2C%0A%20%20%20%20%20%20%20%20%20%20%20Err(10))%3B%0Aassert_eq!(some_var.load(Ordering%3A%3ARelaxed)%2C%2010)%3B%0A%7D&amp;edition=2018">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.compare_exchange_weak" class="method has-srclink"><div class="rightside"><a class="srclink" href="../../../src/core/sync/atomic.rs.html#2162-2179" title="goto source code">[src]</a></div><a href="#method.compare_exchange_weak" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.compare_exchange_weak" class="fnname">compare_exchange_weak</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;current: <a class="primitive" href="../../primitive.i32.html">i32</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;new: <a class="primitive" href="../../primitive.i32.html">i32</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;success: <a class="enum" href="enum.Ordering.html" title="enum std::sync::atomic::Ordering">Ordering</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;failure: <a class="enum" href="enum.Ordering.html" title="enum std::sync::atomic::Ordering">Ordering</a><br>) -&gt; <a class="enum" href="../../result/enum.Result.html" title="enum std::result::Result">Result</a>&lt;<a class="primitive" href="../../primitive.i32.html">i32</a>, <a class="primitive" href="../../primitive.i32.html">i32</a>&gt;</h4></div></summary><div class="docblock" xpath="/html[1]/body[1]/section[1]/details[2]/div[1]/details[10]/div[1]" istranslationnode="true" main_mp="Y25yZD4/d3xuYjo7ZXFraHlyKitVYXt4eXJZIiYvLnZPTFBAVkB7QFhCSEBKQkF6R1RRWg==" sub_mp="[&quot;c3VkOz52fWtjOzpgcGppbHMrKlBgenl8c1gjIy4vd3pNUUFTQXpBXUNJQU9DQHtSVVBb&quot;]"><p class="translate-text">如果当前值与当前值相同，则将值存储到原子整数中。</p><p>Stores a value into the atomic integer if the current value is the same as
the <code>current</code> value.</p>
<p class="translate-text">与 AtomicI32::compare_exchange 不同，即使比较成功，此函数也允许虚假失败，这可以在某些平台上产生更高效的代码。 返回值是指示是否写入新值并包含先前值的结果。</p><p>Unlike <a href="struct.AtomicI32.html#method.compare_exchange" title="AtomicI32::compare_exchange"><code>AtomicI32::compare_exchange</code></a>,
this function is allowed to spuriously fail even
when the comparison succeeds, which can result in more efficient code on some
platforms. The return value is a result indicating whether the new value was
written and containing the previous value.</p>
<p class="translate-text">compare_exchange_weak 采用两个 Ordering 参数来描述此操作的内存排序。 成功描述了在与当前比较成功时发生的读取-修改-写入操作所需的顺序。 failure 描述了比较失败时发生的加载操作所需的顺序。 使用 Acquire 作为成功排序使该操作的存储部分变得轻松，使用 Release 使成功加载变得轻松。 失败排序只能是 SeqCst、Acquire 或 Relaxed，并且必须等于或弱于成功排序。</p><p><code>compare_exchange_weak</code> takes two <a href="enum.Ordering.html" title="Ordering"><code>Ordering</code></a> arguments to describe the memory
ordering of this operation. <code>success</code> describes the required ordering for the
read-modify-write operation that takes place if the comparison with <code>current</code> succeeds.
<code>failure</code> describes the required ordering for the load operation that takes place when
the comparison fails. Using <a href="enum.Ordering.html#variant.Acquire" title="Acquire"><code>Acquire</code></a> as success ordering makes the store part
of this operation <a href="enum.Ordering.html#variant.Relaxed" title="Relaxed"><code>Relaxed</code></a>, and using <a href="enum.Ordering.html#variant.Release" title="Release"><code>Release</code></a> makes the successful load
<a href="enum.Ordering.html#variant.Relaxed" title="Relaxed"><code>Relaxed</code></a>. The failure ordering can only be <a href="enum.Ordering.html#variant.SeqCst" title="SeqCst"><code>SeqCst</code></a>, <a href="enum.Ordering.html#variant.Acquire" title="Acquire"><code>Acquire</code></a> or <a href="enum.Ordering.html#variant.Relaxed" title="Relaxed"><code>Relaxed</code></a>
and must be equivalent to or weaker than the success ordering.</p>
<p class="translate-text">注意：此方法仅在支持 i32 上的原子操作的平台上可用。</p><p><strong>Note</strong>: This method is only available on platforms that support atomic operations on
<a href="../../primitive.i32.html" title="i32"><code>i32</code></a>.</p>
<h1 id="examples-9" class="section-header"><a href="#examples-9">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">std::sync::atomic</span>::{<span class="ident">AtomicI32</span>, <span class="ident">Ordering</span>};

<span class="kw">let</span> <span class="ident">val</span> <span class="op">=</span> <span class="ident">AtomicI32::new</span>(<span class="number">4</span>);

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">old</span> <span class="op">=</span> <span class="ident">val</span>.<span class="ident">load</span>(<span class="ident">Ordering::Relaxed</span>);
<span class="kw">loop</span> {
    <span class="kw">let</span> <span class="ident">new</span> <span class="op">=</span> <span class="ident">old</span> <span class="op">*</span> <span class="number">2</span>;
    <span class="kw">match</span> <span class="ident">val</span>.<span class="ident">compare_exchange_weak</span>(<span class="ident">old</span>, <span class="ident">new</span>, <span class="ident">Ordering::SeqCst</span>, <span class="ident">Ordering::Relaxed</span>) {
        <span class="prelude-val">Ok</span>(<span class="kw">_</span>) <span class="op">=</span><span class="op">&gt;</span> <span class="kw">break</span>,
        <span class="prelude-val">Err</span>(<span class="ident">x</span>) <span class="op">=</span><span class="op">&gt;</span> <span class="ident">old</span> <span class="op">=</span> <span class="ident">x</span>,
    }
}</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Ause%20std%3A%3Async%3A%3Aatomic%3A%3A%7BAtomicI32%2C%20Ordering%7D%3B%0A%0Alet%20val%20%3D%20AtomicI32%3A%3Anew(4)%3B%0A%0Alet%20mut%20old%20%3D%20val.load(Ordering%3A%3ARelaxed)%3B%0Aloop%20%7B%0A%20%20%20%20let%20new%20%3D%20old%20*%202%3B%0A%20%20%20%20match%20val.compare_exchange_weak(old%2C%20new%2C%20Ordering%3A%3ASeqCst%2C%20Ordering%3A%3ARelaxed)%20%7B%0A%20%20%20%20%20%20%20%20Ok(_)%20%3D%3E%20break%2C%0A%20%20%20%20%20%20%20%20Err(x)%20%3D%3E%20old%20%3D%20x%2C%0A%20%20%20%20%7D%0A%7D%0A%7D&amp;edition=2018">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.fetch_add" class="method has-srclink"><div class="rightside"><a class="srclink" href="../../../src/core/sync/atomic.rs.html#2162-2179" title="goto source code">[src]</a></div><a href="#method.fetch_add" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.fetch_add" class="fnname">fetch_add</a>(&amp;self, val: <a class="primitive" href="../../primitive.i32.html">i32</a>, order: <a class="enum" href="enum.Ordering.html" title="enum std::sync::atomic::Ordering">Ordering</a>) -&gt; <a class="primitive" href="../../primitive.i32.html">i32</a></h4></div></summary><div class="docblock" xpath="/html[1]/body[1]/section[1]/details[2]/div[1]/details[11]/div[1]" istranslationnode="true" main_mp="Y25yZD4/d3xuYjo7ZXFraHlyKitVYXt4eXJZIiYvLnNFVUNJe0RAQQ==" sub_mp="[&quot;c3VkOz52fWtjOzpgcGppbHMrKlBgenl8c1gjIy4vcnBUQkh+RUFA&quot;]"><p class="translate-text">添加到当前值，返回前一个值。</p><p>Adds to the current value, returning the previous value.</p>
<p class="translate-text">此操作在溢出时回绕。</p><p>This operation wraps around on overflow.</p>
<p class="translate-text">fetch_add 接受一个描述此操作的内存排序的 Ordering 参数。 所有订购模式都是可能的。 请注意，使用 Acquire 使该操作的存储部分变得轻松，而使用 Release 使加载部分变得轻松。</p><p><code>fetch_add</code> takes an <a href="enum.Ordering.html" title="Ordering"><code>Ordering</code></a> argument which describes the memory ordering
of this operation. All ordering modes are possible. Note that using
<a href="enum.Ordering.html#variant.Acquire" title="Acquire"><code>Acquire</code></a> makes the store part of this operation <a href="enum.Ordering.html#variant.Relaxed" title="Relaxed"><code>Relaxed</code></a>, and
using <a href="enum.Ordering.html#variant.Release" title="Release"><code>Release</code></a> makes the load part <a href="enum.Ordering.html#variant.Relaxed" title="Relaxed"><code>Relaxed</code></a>.</p>
<p class="translate-text">注意：此方法仅在支持 i32 上的原子操作的平台上可用。</p><p><strong>Note</strong>: This method is only available on platforms that support atomic operations on
<a href="../../primitive.i32.html" title="i32"><code>i32</code></a>.</p>
<h1 id="examples-10" class="section-header"><a href="#examples-10">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">std::sync::atomic</span>::{<span class="ident">AtomicI32</span>, <span class="ident">Ordering</span>};

<span class="kw">let</span> <span class="ident">foo</span> <span class="op">=</span> <span class="ident">AtomicI32::new</span>(<span class="number">0</span>);
<span class="macro">assert_eq!</span>(<span class="ident">foo</span>.<span class="ident">fetch_add</span>(<span class="number">10</span>, <span class="ident">Ordering::SeqCst</span>), <span class="number">0</span>);
<span class="macro">assert_eq!</span>(<span class="ident">foo</span>.<span class="ident">load</span>(<span class="ident">Ordering::SeqCst</span>), <span class="number">10</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Ause%20std%3A%3Async%3A%3Aatomic%3A%3A%7BAtomicI32%2C%20Ordering%7D%3B%0A%0Alet%20foo%20%3D%20AtomicI32%3A%3Anew(0)%3B%0Aassert_eq!(foo.fetch_add(10%2C%20Ordering%3A%3ASeqCst)%2C%200)%3B%0Aassert_eq!(foo.load(Ordering%3A%3ASeqCst)%2C%2010)%3B%0A%7D&amp;edition=2018">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.fetch_sub" class="method has-srclink"><div class="rightside"><a class="srclink" href="../../../src/core/sync/atomic.rs.html#2162-2179" title="goto source code">[src]</a></div><a href="#method.fetch_sub" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.fetch_sub" class="fnname">fetch_sub</a>(&amp;self, val: <a class="primitive" href="../../primitive.i32.html">i32</a>, order: <a class="enum" href="enum.Ordering.html" title="enum std::sync::atomic::Ordering">Ordering</a>) -&gt; <a class="primitive" href="../../primitive.i32.html">i32</a></h4></div></summary><div class="docblock" xpath="/html[1]/body[1]/section[1]/details[2]/div[1]/details[12]/div[1]" istranslationnode="true" main_mp="Y25yZD4/d3xuYjo7ZXFraHlyKitVYXt4eXJZIiYvLnNFVUNJe1ZRRw==" sub_mp="[&quot;c3VkOz52fWtjOzpgcGppbHMrKlBgenl8c1gjIy4vcnBUQkh+V1BG&quot;]"><p class="translate-text">从当前值中减去，返回前一个值。</p><p>Subtracts from the current value, returning the previous value.</p>
<p class="translate-text">此操作在溢出时回绕。</p><p>This operation wraps around on overflow.</p>
<p class="translate-text">fetch_sub 接受一个描述此操作的内存排序的 Ordering 参数。 所有订购模式都是可能的。 请注意，使用 Acquire 使该操作的存储部分变得轻松，而使用 Release 使加载部分变得轻松。</p><p><code>fetch_sub</code> takes an <a href="enum.Ordering.html" title="Ordering"><code>Ordering</code></a> argument which describes the memory ordering
of this operation. All ordering modes are possible. Note that using
<a href="enum.Ordering.html#variant.Acquire" title="Acquire"><code>Acquire</code></a> makes the store part of this operation <a href="enum.Ordering.html#variant.Relaxed" title="Relaxed"><code>Relaxed</code></a>, and
using <a href="enum.Ordering.html#variant.Release" title="Release"><code>Release</code></a> makes the load part <a href="enum.Ordering.html#variant.Relaxed" title="Relaxed"><code>Relaxed</code></a>.</p>
<p class="translate-text">注意：此方法仅在支持 i32 上的原子操作的平台上可用。</p><p><strong>Note</strong>: This method is only available on platforms that support atomic operations on
<a href="../../primitive.i32.html" title="i32"><code>i32</code></a>.</p>
<h1 id="examples-11" class="section-header"><a href="#examples-11">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">std::sync::atomic</span>::{<span class="ident">AtomicI32</span>, <span class="ident">Ordering</span>};

<span class="kw">let</span> <span class="ident">foo</span> <span class="op">=</span> <span class="ident">AtomicI32::new</span>(<span class="number">20</span>);
<span class="macro">assert_eq!</span>(<span class="ident">foo</span>.<span class="ident">fetch_sub</span>(<span class="number">10</span>, <span class="ident">Ordering::SeqCst</span>), <span class="number">20</span>);
<span class="macro">assert_eq!</span>(<span class="ident">foo</span>.<span class="ident">load</span>(<span class="ident">Ordering::SeqCst</span>), <span class="number">10</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Ause%20std%3A%3Async%3A%3Aatomic%3A%3A%7BAtomicI32%2C%20Ordering%7D%3B%0A%0Alet%20foo%20%3D%20AtomicI32%3A%3Anew(20)%3B%0Aassert_eq!(foo.fetch_sub(10%2C%20Ordering%3A%3ASeqCst)%2C%2020)%3B%0Aassert_eq!(foo.load(Ordering%3A%3ASeqCst)%2C%2010)%3B%0A%7D&amp;edition=2018">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.fetch_and" class="method has-srclink"><div class="rightside"><a class="srclink" href="../../../src/core/sync/atomic.rs.html#2162-2179" title="goto source code">[src]</a></div><a href="#method.fetch_and" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.fetch_and" class="fnname">fetch_and</a>(&amp;self, val: <a class="primitive" href="../../primitive.i32.html">i32</a>, order: <a class="enum" href="enum.Ordering.html" title="enum std::sync::atomic::Ordering">Ordering</a>) -&gt; <a class="primitive" href="../../primitive.i32.html">i32</a></h4></div></summary><div class="docblock" xpath="/html[1]/body[1]/section[1]/details[2]/div[1]/details[13]/div[1]" istranslationnode="true" main_mp="Y25yZD4/d3xuYjo7ZXFraHlyKitVYXt4eXJZIiYvLnNFVUNJe0RKQQ==" sub_mp="[&quot;c3VkOz52fWtjOzpgcGppbHMrKlBgenl8c1gjIy4vcnBUQkh+RUtA&quot;]"><p class="translate-text">与当前值按位“与”。</p><p>Bitwise “and” with the current value.</p>
<p class="translate-text">对当前值和参数 val 执行按位“与”运算，并将新值设置为结果。</p><p>Performs a bitwise “and” operation on the current value and the argument <code>val</code>, and
sets the new value to the result.</p>
<p class="translate-text">返回前一个值。</p><p>Returns the previous value.</p>
<p class="translate-text">fetch_and 接受一个描述此操作的内存排序的 Ordering 参数。 所有订购模式都是可能的。 请注意，使用 Acquire 使该操作的存储部分变得轻松，而使用 Release 使加载部分变得轻松。</p><p><code>fetch_and</code> takes an <a href="enum.Ordering.html" title="Ordering"><code>Ordering</code></a> argument which describes the memory ordering
of this operation. All ordering modes are possible. Note that using
<a href="enum.Ordering.html#variant.Acquire" title="Acquire"><code>Acquire</code></a> makes the store part of this operation <a href="enum.Ordering.html#variant.Relaxed" title="Relaxed"><code>Relaxed</code></a>, and
using <a href="enum.Ordering.html#variant.Release" title="Release"><code>Release</code></a> makes the load part <a href="enum.Ordering.html#variant.Relaxed" title="Relaxed"><code>Relaxed</code></a>.</p>
<p class="translate-text">注意：此方法仅在支持 i32 上的原子操作的平台上可用。</p><p><strong>Note</strong>: This method is only available on platforms that support atomic operations on
<a href="../../primitive.i32.html" title="i32"><code>i32</code></a>.</p>
<h1 id="examples-12" class="section-header"><a href="#examples-12">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">std::sync::atomic</span>::{<span class="ident">AtomicI32</span>, <span class="ident">Ordering</span>};

<span class="kw">let</span> <span class="ident">foo</span> <span class="op">=</span> <span class="ident">AtomicI32::new</span>(<span class="number">0b101101</span>);
<span class="macro">assert_eq!</span>(<span class="ident">foo</span>.<span class="ident">fetch_and</span>(<span class="number">0b110011</span>, <span class="ident">Ordering::SeqCst</span>), <span class="number">0b101101</span>);
<span class="macro">assert_eq!</span>(<span class="ident">foo</span>.<span class="ident">load</span>(<span class="ident">Ordering::SeqCst</span>), <span class="number">0b100001</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Ause%20std%3A%3Async%3A%3Aatomic%3A%3A%7BAtomicI32%2C%20Ordering%7D%3B%0A%0Alet%20foo%20%3D%20AtomicI32%3A%3Anew(0b101101)%3B%0Aassert_eq!(foo.fetch_and(0b110011%2C%20Ordering%3A%3ASeqCst)%2C%200b101101)%3B%0Aassert_eq!(foo.load(Ordering%3A%3ASeqCst)%2C%200b100001)%3B%0A%7D&amp;edition=2018">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.fetch_nand" class="method has-srclink"><div class="rightside"><a class="srclink" href="../../../src/core/sync/atomic.rs.html#2162-2179" title="goto source code">[src]</a></div><a href="#method.fetch_nand" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.fetch_nand" class="fnname">fetch_nand</a>(&amp;self, val: <a class="primitive" href="../../primitive.i32.html">i32</a>, order: <a class="enum" href="enum.Ordering.html" title="enum std::sync::atomic::Ordering">Ordering</a>) -&gt; <a class="primitive" href="../../primitive.i32.html">i32</a></h4></div></summary><div class="docblock" xpath="/html[1]/body[1]/section[1]/details[2]/div[1]/details[14]/div[1]" istranslationnode="true" main_mp="Y25yZD4/d3xuYjo7ZXFraHlyKitVYXt4eXJZIiYvLnNFVUNJe0tFS0Q=" sub_mp="[&quot;c3VkOz52fWtjOzpgcGppbHMrKlBgenl8c1gjIy4vcnBUQkh+SkRKQQ==&quot;]"><p class="translate-text">与当前值按位“nand”。</p><p>Bitwise “nand” with the current value.</p>
<p class="translate-text">对当前值和参数 val 执行按位“与”运算，并将新值设置为结果。</p><p>Performs a bitwise “nand” operation on the current value and the argument <code>val</code>, and
sets the new value to the result.</p>
<p class="translate-text">返回前一个值。</p><p>Returns the previous value.</p>
<p class="translate-text">fetch_nand 接受一个描述此操作的内存排序的 Ordering 参数。 所有订购模式都是可能的。 请注意，使用 Acquire 使该操作的存储部分变得轻松，而使用 Release 使加载部分变得轻松。</p><p><code>fetch_nand</code> takes an <a href="enum.Ordering.html" title="Ordering"><code>Ordering</code></a> argument which describes the memory ordering
of this operation. All ordering modes are possible. Note that using
<a href="enum.Ordering.html#variant.Acquire" title="Acquire"><code>Acquire</code></a> makes the store part of this operation <a href="enum.Ordering.html#variant.Relaxed" title="Relaxed"><code>Relaxed</code></a>, and
using <a href="enum.Ordering.html#variant.Release" title="Release"><code>Release</code></a> makes the load part <a href="enum.Ordering.html#variant.Relaxed" title="Relaxed"><code>Relaxed</code></a>.</p>
<p class="translate-text">注意：此方法仅在支持 i32 上的原子操作的平台上可用。</p><p><strong>Note</strong>: This method is only available on platforms that support atomic operations on
<a href="../../primitive.i32.html" title="i32"><code>i32</code></a>.</p>
<h1 id="examples-13" class="section-header"><a href="#examples-13">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">std::sync::atomic</span>::{<span class="ident">AtomicI32</span>, <span class="ident">Ordering</span>};

<span class="kw">let</span> <span class="ident">foo</span> <span class="op">=</span> <span class="ident">AtomicI32::new</span>(<span class="number">0x13</span>);
<span class="macro">assert_eq!</span>(<span class="ident">foo</span>.<span class="ident">fetch_nand</span>(<span class="number">0x31</span>, <span class="ident">Ordering::SeqCst</span>), <span class="number">0x13</span>);
<span class="macro">assert_eq!</span>(<span class="ident">foo</span>.<span class="ident">load</span>(<span class="ident">Ordering::SeqCst</span>), <span class="op">!</span>(<span class="number">0x13</span> <span class="op">&amp;</span> <span class="number">0x31</span>));</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Ause%20std%3A%3Async%3A%3Aatomic%3A%3A%7BAtomicI32%2C%20Ordering%7D%3B%0A%0Alet%20foo%20%3D%20AtomicI32%3A%3Anew(0x13)%3B%0Aassert_eq!(foo.fetch_nand(0x31%2C%20Ordering%3A%3ASeqCst)%2C%200x13)%3B%0Aassert_eq!(foo.load(Ordering%3A%3ASeqCst)%2C%20!(0x13%20%26%200x31))%3B%0A%7D&amp;edition=2018">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.fetch_or" class="method has-srclink"><div class="rightside"><a class="srclink" href="../../../src/core/sync/atomic.rs.html#2162-2179" title="goto source code">[src]</a></div><a href="#method.fetch_or" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.fetch_or" class="fnname">fetch_or</a>(&amp;self, val: <a class="primitive" href="../../primitive.i32.html">i32</a>, order: <a class="enum" href="enum.Ordering.html" title="enum std::sync::atomic::Ordering">Ordering</a>) -&gt; <a class="primitive" href="../../primitive.i32.html">i32</a></h4></div></summary><div class="docblock" xpath="/html[1]/body[1]/section[1]/details[2]/div[1]/details[15]/div[1]" istranslationnode="true" main_mp="Y25yZD4/d3xuYjo7ZXFraHlyKitVYXt4eXJZIiYvLnNFVUNJe0pW" sub_mp="[&quot;c3VkOz52fWtjOzpgcGppbHMrKlBgenl8c1gjIy4vcnBUQkh+S1c=&quot;]"><p class="translate-text">与当前值按位“或”。</p><p>Bitwise “or” with the current value.</p>
<p class="translate-text">对当前值和参数 val 执行按位“或”运算，并将新值设置为结果。</p><p>Performs a bitwise “or” operation on the current value and the argument <code>val</code>, and
sets the new value to the result.</p>
<p class="translate-text">返回前一个值。</p><p>Returns the previous value.</p>
<p class="translate-text">fetch_or 接受一个描述此操作的内存排序的 Ordering 参数。 所有订购模式都是可能的。 请注意，使用 Acquire 使该操作的存储部分变得轻松，而使用 Release 使加载部分变得轻松。</p><p><code>fetch_or</code> takes an <a href="enum.Ordering.html" title="Ordering"><code>Ordering</code></a> argument which describes the memory ordering
of this operation. All ordering modes are possible. Note that using
<a href="enum.Ordering.html#variant.Acquire" title="Acquire"><code>Acquire</code></a> makes the store part of this operation <a href="enum.Ordering.html#variant.Relaxed" title="Relaxed"><code>Relaxed</code></a>, and
using <a href="enum.Ordering.html#variant.Release" title="Release"><code>Release</code></a> makes the load part <a href="enum.Ordering.html#variant.Relaxed" title="Relaxed"><code>Relaxed</code></a>.</p>
<p class="translate-text">注意：此方法仅在支持 i32 上的原子操作的平台上可用。</p><p><strong>Note</strong>: This method is only available on platforms that support atomic operations on
<a href="../../primitive.i32.html" title="i32"><code>i32</code></a>.</p>
<h1 id="examples-14" class="section-header"><a href="#examples-14">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">std::sync::atomic</span>::{<span class="ident">AtomicI32</span>, <span class="ident">Ordering</span>};

<span class="kw">let</span> <span class="ident">foo</span> <span class="op">=</span> <span class="ident">AtomicI32::new</span>(<span class="number">0b101101</span>);
<span class="macro">assert_eq!</span>(<span class="ident">foo</span>.<span class="ident">fetch_or</span>(<span class="number">0b110011</span>, <span class="ident">Ordering::SeqCst</span>), <span class="number">0b101101</span>);
<span class="macro">assert_eq!</span>(<span class="ident">foo</span>.<span class="ident">load</span>(<span class="ident">Ordering::SeqCst</span>), <span class="number">0b111111</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Ause%20std%3A%3Async%3A%3Aatomic%3A%3A%7BAtomicI32%2C%20Ordering%7D%3B%0A%0Alet%20foo%20%3D%20AtomicI32%3A%3Anew(0b101101)%3B%0Aassert_eq!(foo.fetch_or(0b110011%2C%20Ordering%3A%3ASeqCst)%2C%200b101101)%3B%0Aassert_eq!(foo.load(Ordering%3A%3ASeqCst)%2C%200b111111)%3B%0A%7D&amp;edition=2018">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.fetch_xor" class="method has-srclink"><div class="rightside"><a class="srclink" href="../../../src/core/sync/atomic.rs.html#2162-2179" title="goto source code">[src]</a></div><a href="#method.fetch_xor" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.fetch_xor" class="fnname">fetch_xor</a>(&amp;self, val: <a class="primitive" href="../../primitive.i32.html">i32</a>, order: <a class="enum" href="enum.Ordering.html" title="enum std::sync::atomic::Ordering">Ordering</a>) -&gt; <a class="primitive" href="../../primitive.i32.html">i32</a></h4></div></summary><div class="docblock" xpath="/html[1]/body[1]/section[1]/details[2]/div[1]/details[16]/div[1]" istranslationnode="true" main_mp="Y25yZD4/d3xuYjo7ZXFraHlyKitVYXt4eXJZIiYvLnNFVUNJe11LVw==" sub_mp="[&quot;c3VkOz52fWtjOzpgcGppbHMrKlBgenl8c1gjIy4vcnBUQkh+XEpW&quot;]"><p class="translate-text">与当前值按位“异或”。</p><p>Bitwise “xor” with the current value.</p>
<p class="translate-text">对当前值和参数 val 执行按位“异或”运算，并将新值设置为结果。</p><p>Performs a bitwise “xor” operation on the current value and the argument <code>val</code>, and
sets the new value to the result.</p>
<p class="translate-text">返回前一个值。</p><p>Returns the previous value.</p>
<p class="translate-text">fetch_xor 接受一个描述此操作的内存排序的 Ordering 参数。 所有订购模式都是可能的。 请注意，使用 Acquire 使该操作的存储部分变得轻松，而使用 Release 使加载部分变得轻松。</p><p><code>fetch_xor</code> takes an <a href="enum.Ordering.html" title="Ordering"><code>Ordering</code></a> argument which describes the memory ordering
of this operation. All ordering modes are possible. Note that using
<a href="enum.Ordering.html#variant.Acquire" title="Acquire"><code>Acquire</code></a> makes the store part of this operation <a href="enum.Ordering.html#variant.Relaxed" title="Relaxed"><code>Relaxed</code></a>, and
using <a href="enum.Ordering.html#variant.Release" title="Release"><code>Release</code></a> makes the load part <a href="enum.Ordering.html#variant.Relaxed" title="Relaxed"><code>Relaxed</code></a>.</p>
<p class="translate-text">注意：此方法仅在支持 i32 上的原子操作的平台上可用。</p><p><strong>Note</strong>: This method is only available on platforms that support atomic operations on
<a href="../../primitive.i32.html" title="i32"><code>i32</code></a>.</p>
<h1 id="examples-15" class="section-header"><a href="#examples-15">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">std::sync::atomic</span>::{<span class="ident">AtomicI32</span>, <span class="ident">Ordering</span>};

<span class="kw">let</span> <span class="ident">foo</span> <span class="op">=</span> <span class="ident">AtomicI32::new</span>(<span class="number">0b101101</span>);
<span class="macro">assert_eq!</span>(<span class="ident">foo</span>.<span class="ident">fetch_xor</span>(<span class="number">0b110011</span>, <span class="ident">Ordering::SeqCst</span>), <span class="number">0b101101</span>);
<span class="macro">assert_eq!</span>(<span class="ident">foo</span>.<span class="ident">load</span>(<span class="ident">Ordering::SeqCst</span>), <span class="number">0b011110</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Ause%20std%3A%3Async%3A%3Aatomic%3A%3A%7BAtomicI32%2C%20Ordering%7D%3B%0A%0Alet%20foo%20%3D%20AtomicI32%3A%3Anew(0b101101)%3B%0Aassert_eq!(foo.fetch_xor(0b110011%2C%20Ordering%3A%3ASeqCst)%2C%200b101101)%3B%0Aassert_eq!(foo.load(Ordering%3A%3ASeqCst)%2C%200b011110)%3B%0A%7D&amp;edition=2018">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.fetch_update" class="method has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.45.0">1.45.0</span><a class="srclink" href="../../../src/core/sync/atomic.rs.html#2162-2179" title="goto source code">[src]</a></div><a href="#method.fetch_update" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.fetch_update" class="fnname">fetch_update</a>&lt;F&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;set_order: <a class="enum" href="enum.Ordering.html" title="enum std::sync::atomic::Ordering">Ordering</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;fetch_order: <a class="enum" href="enum.Ordering.html" title="enum std::sync::atomic::Ordering">Ordering</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;f: F<br>) -&gt; <a class="enum" href="../../result/enum.Result.html" title="enum std::result::Result">Result</a>&lt;<a class="primitive" href="../../primitive.i32.html">i32</a>, <a class="primitive" href="../../primitive.i32.html">i32</a>&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="../../ops/trait.FnMut.html" title="trait std::ops::FnMut">FnMut</a>(<a class="primitive" href="../../primitive.i32.html">i32</a>) -&gt; <a class="enum" href="../../option/enum.Option.html" title="enum std::option::Option">Option</a>&lt;<a class="primitive" href="../../primitive.i32.html">i32</a>&gt;,&nbsp;</span></h4></div></summary><div class="docblock" xpath="/html[1]/body[1]/section[1]/details[2]/div[1]/details[17]/div[1]" istranslationnode="true" main_mp="Y25yZD4/d3xuYjo7ZXFraHlyKitVYXt4eXJZIiYvLnNFVUNJe1BUQUFVRQ==" sub_mp="[&quot;c3VkOz52fWtjOzpgcGppbHMrKlBgenl8c1gjIy4vcnBUQkh+UVVARFRE&quot;]"><p class="translate-text">获取该值，并对其应用一个返回可选新值的函数。 如果函数返回 Some(_)，则返回 Ok(previous_value) 的结果，否则返回 Err(previous_value)。</p><p>Fetches the value, and applies a function to it that returns an optional
new value. Returns a <code>Result</code> of <code>Ok(previous_value)</code> if the function returned <code>Some(_)</code>, else
<code>Err(previous_value)</code>.</p>
<p class="translate-text">注意：如果同时从其他线程更改了值，这可能会多次调用该函数，只要该函数返回 Some(_)，但该函数将只应用于存储的值一次。</p><p>Note: This may call the function multiple times if the value has been changed from other threads in
the meantime, as long as the function returns <code>Some(_)</code>, but the function will have been applied
only once to the stored value.</p>
<p class="translate-text">fetch_update 采用两个 Ordering 参数来描述此操作的内存排序。 第一个描述了操作最终成功时所需的顺序，而第二个描述了加载所需的顺序。 这些分别对应于 AtomicI32::compare_exchange 的成功和失败顺序。</p><p><code>fetch_update</code> takes two <a href="enum.Ordering.html" title="Ordering"><code>Ordering</code></a> arguments to describe the memory ordering of this operation.
The first describes the required ordering for when the operation finally succeeds while the second
describes the required ordering for loads. These correspond to the success and failure orderings of
<a href="struct.AtomicI32.html#method.compare_exchange" title="AtomicI32::compare_exchange"><code>AtomicI32::compare_exchange</code></a>
respectively.</p>
<p class="translate-text">使用 Acquire 作为成功排序使该操作的存储部分变得轻松，使用 Release 使最终成功加载变得轻松。 （失败的）加载排序只能是 SeqCst、Acquire 或 Relaxed，并且必须等于或弱于成功排序。</p><p>Using <a href="enum.Ordering.html#variant.Acquire" title="Acquire"><code>Acquire</code></a> as success ordering makes the store part
of this operation <a href="enum.Ordering.html#variant.Relaxed" title="Relaxed"><code>Relaxed</code></a>, and using <a href="enum.Ordering.html#variant.Release" title="Release"><code>Release</code></a> makes the final successful load
<a href="enum.Ordering.html#variant.Relaxed" title="Relaxed"><code>Relaxed</code></a>. The (failed) load ordering can only be <a href="enum.Ordering.html#variant.SeqCst" title="SeqCst"><code>SeqCst</code></a>, <a href="enum.Ordering.html#variant.Acquire" title="Acquire"><code>Acquire</code></a> or <a href="enum.Ordering.html#variant.Relaxed" title="Relaxed"><code>Relaxed</code></a>
and must be equivalent to or weaker than the success ordering.</p>
<p class="translate-text">注意：此方法仅在支持 i32 上的原子操作的平台上可用。</p><p><strong>Note</strong>: This method is only available on platforms that support atomic operations on
<a href="../../primitive.i32.html" title="i32"><code>i32</code></a>.</p>
<h1 id="examples-16" class="section-header"><a href="#examples-16">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">std::sync::atomic</span>::{<span class="ident">AtomicI32</span>, <span class="ident">Ordering</span>};

<span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="ident">AtomicI32::new</span>(<span class="number">7</span>);
<span class="macro">assert_eq!</span>(<span class="ident">x</span>.<span class="ident">fetch_update</span>(<span class="ident">Ordering::SeqCst</span>, <span class="ident">Ordering::SeqCst</span>, <span class="op">|</span><span class="kw">_</span><span class="op">|</span> <span class="prelude-val">None</span>), <span class="prelude-val">Err</span>(<span class="number">7</span>));
<span class="macro">assert_eq!</span>(<span class="ident">x</span>.<span class="ident">fetch_update</span>(<span class="ident">Ordering::SeqCst</span>, <span class="ident">Ordering::SeqCst</span>, <span class="op">|</span><span class="ident">x</span><span class="op">|</span> <span class="prelude-val">Some</span>(<span class="ident">x</span> <span class="op">+</span> <span class="number">1</span>)), <span class="prelude-val">Ok</span>(<span class="number">7</span>));
<span class="macro">assert_eq!</span>(<span class="ident">x</span>.<span class="ident">fetch_update</span>(<span class="ident">Ordering::SeqCst</span>, <span class="ident">Ordering::SeqCst</span>, <span class="op">|</span><span class="ident">x</span><span class="op">|</span> <span class="prelude-val">Some</span>(<span class="ident">x</span> <span class="op">+</span> <span class="number">1</span>)), <span class="prelude-val">Ok</span>(<span class="number">8</span>));
<span class="macro">assert_eq!</span>(<span class="ident">x</span>.<span class="ident">load</span>(<span class="ident">Ordering::SeqCst</span>), <span class="number">9</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Ause%20std%3A%3Async%3A%3Aatomic%3A%3A%7BAtomicI32%2C%20Ordering%7D%3B%0A%0Alet%20x%20%3D%20AtomicI32%3A%3Anew(7)%3B%0Aassert_eq!(x.fetch_update(Ordering%3A%3ASeqCst%2C%20Ordering%3A%3ASeqCst%2C%20%7C_%7C%20None)%2C%20Err(7))%3B%0Aassert_eq!(x.fetch_update(Ordering%3A%3ASeqCst%2C%20Ordering%3A%3ASeqCst%2C%20%7Cx%7C%20Some(x%20%2B%201))%2C%20Ok(7))%3B%0Aassert_eq!(x.fetch_update(Ordering%3A%3ASeqCst%2C%20Ordering%3A%3ASeqCst%2C%20%7Cx%7C%20Some(x%20%2B%201))%2C%20Ok(8))%3B%0Aassert_eq!(x.load(Ordering%3A%3ASeqCst)%2C%209)%3B%0A%7D&amp;edition=2018">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.fetch_max" class="method has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.45.0">1.45.0</span><a class="srclink" href="../../../src/core/sync/atomic.rs.html#2162-2179" title="goto source code">[src]</a></div><a href="#method.fetch_max" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.fetch_max" class="fnname">fetch_max</a>(&amp;self, val: <a class="primitive" href="../../primitive.i32.html">i32</a>, order: <a class="enum" href="enum.Ordering.html" title="enum std::sync::atomic::Ordering">Ordering</a>) -&gt; <a class="primitive" href="../../primitive.i32.html">i32</a></h4></div></summary><div class="docblock" xpath="/html[1]/body[1]/section[1]/details[2]/div[1]/details[18]/div[1]" istranslationnode="true" main_mp="Y25yZD4/d3xuYjo7ZXFraHlyKitVYXt4eXJZIiYvLnNFVUNJe0hFXQ==" sub_mp="[&quot;c3VkOz52fWtjOzpgcGppbHMrKlBgenl8c1gjIy4vcnBUQkh+SURc&quot;]"><p class="translate-text">当前值的最大值。</p><p>Maximum with the current value.</p>
<p class="translate-text">查找当前值和参数 val 的最大值，并将新值设置为结果。</p><p>Finds the maximum of the current value and the argument <code>val</code>, and
sets the new value to the result.</p>
<p class="translate-text">返回前一个值。</p><p>Returns the previous value.</p>
<p class="translate-text">fetch_max 接受一个描述此操作的内存排序的 Ordering 参数。 所有订购模式都是可能的。 请注意，使用 Acquire 使该操作的存储部分变得轻松，而使用 Release 使加载部分变得轻松。</p><p><code>fetch_max</code> takes an <a href="enum.Ordering.html" title="Ordering"><code>Ordering</code></a> argument which describes the memory ordering
of this operation. All ordering modes are possible. Note that using
<a href="enum.Ordering.html#variant.Acquire" title="Acquire"><code>Acquire</code></a> makes the store part of this operation <a href="enum.Ordering.html#variant.Relaxed" title="Relaxed"><code>Relaxed</code></a>, and
using <a href="enum.Ordering.html#variant.Release" title="Release"><code>Release</code></a> makes the load part <a href="enum.Ordering.html#variant.Relaxed" title="Relaxed"><code>Relaxed</code></a>.</p>
<p class="translate-text">注意：此方法仅在支持 i32 上的原子操作的平台上可用。</p><p><strong>Note</strong>: This method is only available on platforms that support atomic operations on
<a href="../../primitive.i32.html" title="i32"><code>i32</code></a>.</p>
<h1 id="examples-17" class="section-header"><a href="#examples-17">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">std::sync::atomic</span>::{<span class="ident">AtomicI32</span>, <span class="ident">Ordering</span>};

<span class="kw">let</span> <span class="ident">foo</span> <span class="op">=</span> <span class="ident">AtomicI32::new</span>(<span class="number">23</span>);
<span class="macro">assert_eq!</span>(<span class="ident">foo</span>.<span class="ident">fetch_max</span>(<span class="number">42</span>, <span class="ident">Ordering::SeqCst</span>), <span class="number">23</span>);
<span class="macro">assert_eq!</span>(<span class="ident">foo</span>.<span class="ident">load</span>(<span class="ident">Ordering::SeqCst</span>), <span class="number">42</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Ause%20std%3A%3Async%3A%3Aatomic%3A%3A%7BAtomicI32%2C%20Ordering%7D%3B%0A%0Alet%20foo%20%3D%20AtomicI32%3A%3Anew(23)%3B%0Aassert_eq!(foo.fetch_max(42%2C%20Ordering%3A%3ASeqCst)%2C%2023)%3B%0Aassert_eq!(foo.load(Ordering%3A%3ASeqCst)%2C%2042)%3B%0A%7D&amp;edition=2018">Run</a></div>
<p class="translate-text">如果要一步获取最大值，可以使用以下方法：</p><p>If you want to obtain the maximum value in one step, you can use the following:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">std::sync::atomic</span>::{<span class="ident">AtomicI32</span>, <span class="ident">Ordering</span>};

<span class="kw">let</span> <span class="ident">foo</span> <span class="op">=</span> <span class="ident">AtomicI32::new</span>(<span class="number">23</span>);
<span class="kw">let</span> <span class="ident">bar</span> <span class="op">=</span> <span class="number">42</span>;
<span class="kw">let</span> <span class="ident">max_foo</span> <span class="op">=</span> <span class="ident">foo</span>.<span class="ident">fetch_max</span>(<span class="ident">bar</span>, <span class="ident">Ordering::SeqCst</span>).<span class="ident">max</span>(<span class="ident">bar</span>);
<span class="macro">assert!</span>(<span class="ident">max_foo</span> <span class="op">=</span><span class="op">=</span> <span class="number">42</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Ause%20std%3A%3Async%3A%3Aatomic%3A%3A%7BAtomicI32%2C%20Ordering%7D%3B%0A%0Alet%20foo%20%3D%20AtomicI32%3A%3Anew(23)%3B%0Alet%20bar%20%3D%2042%3B%0Alet%20max_foo%20%3D%20foo.fetch_max(bar%2C%20Ordering%3A%3ASeqCst).max(bar)%3B%0Aassert!(max_foo%20%3D%3D%2042)%3B%0A%7D&amp;edition=2018">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.fetch_min" class="method has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.45.0">1.45.0</span><a class="srclink" href="../../../src/core/sync/atomic.rs.html#2162-2179" title="goto source code">[src]</a></div><a href="#method.fetch_min" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.fetch_min" class="fnname">fetch_min</a>(&amp;self, val: <a class="primitive" href="../../primitive.i32.html">i32</a>, order: <a class="enum" href="enum.Ordering.html" title="enum std::sync::atomic::Ordering">Ordering</a>) -&gt; <a class="primitive" href="../../primitive.i32.html">i32</a></h4></div></summary><div class="docblock" xpath="/html[1]/body[1]/section[1]/details[2]/div[1]/details[19]/div[1]" istranslationnode="true" main_mp="Y25yZD4/d3xuYjo7ZXFraHlyKitVYXt4eXJZIiYvLnNFVUNJe0hNSw==" sub_mp="[&quot;c3VkOz52fWtjOzpgcGppbHMrKlBgenl8c1gjIy4vcnBUQkh+SUxK&quot;]"><p class="translate-text">当前值的最小值。</p><p>Minimum with the current value.</p>
<p class="translate-text">查找当前值和参数 val 的最小值，并将新值设置为结果。</p><p>Finds the minimum of the current value and the argument <code>val</code>, and
sets the new value to the result.</p>
<p class="translate-text">返回前一个值。</p><p>Returns the previous value.</p>
<p class="translate-text">fetch_min 接受一个描述此操作的内存排序的 Ordering 参数。 所有订购模式都是可能的。 请注意，使用 Acquire 使该操作的存储部分变得轻松，而使用 Release 使加载部分变得轻松。</p><p><code>fetch_min</code> takes an <a href="enum.Ordering.html" title="Ordering"><code>Ordering</code></a> argument which describes the memory ordering
of this operation. All ordering modes are possible. Note that using
<a href="enum.Ordering.html#variant.Acquire" title="Acquire"><code>Acquire</code></a> makes the store part of this operation <a href="enum.Ordering.html#variant.Relaxed" title="Relaxed"><code>Relaxed</code></a>, and
using <a href="enum.Ordering.html#variant.Release" title="Release"><code>Release</code></a> makes the load part <a href="enum.Ordering.html#variant.Relaxed" title="Relaxed"><code>Relaxed</code></a>.</p>
<p class="translate-text">注意：此方法仅在支持 i32 上的原子操作的平台上可用。</p><p><strong>Note</strong>: This method is only available on platforms that support atomic operations on
<a href="../../primitive.i32.html" title="i32"><code>i32</code></a>.</p>
<h1 id="examples-18" class="section-header"><a href="#examples-18">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">std::sync::atomic</span>::{<span class="ident">AtomicI32</span>, <span class="ident">Ordering</span>};

<span class="kw">let</span> <span class="ident">foo</span> <span class="op">=</span> <span class="ident">AtomicI32::new</span>(<span class="number">23</span>);
<span class="macro">assert_eq!</span>(<span class="ident">foo</span>.<span class="ident">fetch_min</span>(<span class="number">42</span>, <span class="ident">Ordering::Relaxed</span>), <span class="number">23</span>);
<span class="macro">assert_eq!</span>(<span class="ident">foo</span>.<span class="ident">load</span>(<span class="ident">Ordering::Relaxed</span>), <span class="number">23</span>);
<span class="macro">assert_eq!</span>(<span class="ident">foo</span>.<span class="ident">fetch_min</span>(<span class="number">22</span>, <span class="ident">Ordering::Relaxed</span>), <span class="number">23</span>);
<span class="macro">assert_eq!</span>(<span class="ident">foo</span>.<span class="ident">load</span>(<span class="ident">Ordering::Relaxed</span>), <span class="number">22</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Ause%20std%3A%3Async%3A%3Aatomic%3A%3A%7BAtomicI32%2C%20Ordering%7D%3B%0A%0Alet%20foo%20%3D%20AtomicI32%3A%3Anew(23)%3B%0Aassert_eq!(foo.fetch_min(42%2C%20Ordering%3A%3ARelaxed)%2C%2023)%3B%0Aassert_eq!(foo.load(Ordering%3A%3ARelaxed)%2C%2023)%3B%0Aassert_eq!(foo.fetch_min(22%2C%20Ordering%3A%3ARelaxed)%2C%2023)%3B%0Aassert_eq!(foo.load(Ordering%3A%3ARelaxed)%2C%2022)%3B%0A%7D&amp;edition=2018">Run</a></div>
<p class="translate-text">如果要一步获取最小值，可以使用以下方法：</p><p>If you want to obtain the minimum value in one step, you can use the following:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">std::sync::atomic</span>::{<span class="ident">AtomicI32</span>, <span class="ident">Ordering</span>};

<span class="kw">let</span> <span class="ident">foo</span> <span class="op">=</span> <span class="ident">AtomicI32::new</span>(<span class="number">23</span>);
<span class="kw">let</span> <span class="ident">bar</span> <span class="op">=</span> <span class="number">12</span>;
<span class="kw">let</span> <span class="ident">min_foo</span> <span class="op">=</span> <span class="ident">foo</span>.<span class="ident">fetch_min</span>(<span class="ident">bar</span>, <span class="ident">Ordering::SeqCst</span>).<span class="ident">min</span>(<span class="ident">bar</span>);
<span class="macro">assert_eq!</span>(<span class="ident">min_foo</span>, <span class="number">12</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Ause%20std%3A%3Async%3A%3Aatomic%3A%3A%7BAtomicI32%2C%20Ordering%7D%3B%0A%0Alet%20foo%20%3D%20AtomicI32%3A%3Anew(23)%3B%0Alet%20bar%20%3D%2012%3B%0Alet%20min_foo%20%3D%20foo.fetch_min(bar%2C%20Ordering%3A%3ASeqCst).min(bar)%3B%0Aassert_eq!(min_foo%2C%2012)%3B%0A%7D&amp;edition=2018">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.as_mut_ptr" class="method has-srclink"><div class="rightside"><a class="srclink" href="../../../src/core/sync/atomic.rs.html#2162-2179" title="goto source code">[src]</a></div><a href="#method.as_mut_ptr" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.as_mut_ptr" class="fnname">as_mut_ptr</a>(&amp;self) -&gt; <a class="primitive" href="../../primitive.pointer.html">*mut </a><a class="primitive" href="../../primitive.i32.html">i32</a></h4></div><div class="item-info"><div class="stab unstable"><details><summary><span class="emoji">🔬</span> This is a nightly-only experimental API. (<code>atomic_mut_ptr</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/66893">#66893</a>)</summary><p>recently added</p>
</details></div></div></summary><div class="docblock" xpath="/html[1]/body[1]/section[1]/details[2]/div[1]/details[20]/div[1]" istranslationnode="true" main_mp="Y25yZD4/d3xuYjo7ZXFraHlyKitVYXt4eXJZIiYvLnRTfk1UUHpUUVI=" sub_mp="[&quot;c3VkOz52fWtjOzpgcGppbHMrKlBgenl8c1gjIy4vdWZ/TFVVe1VQVw==&quot;]"><p class="translate-text">返回指向基础整数的可变指针。</p><p>Returns a mutable pointer to the underlying integer.</p>
<p class="translate-text">对结果整数进行非原子读取和写入可能是数据竞争。 此方法对 FFI 非常有用，其中函数签名可能使用 *mut i32 而不是 &AtomicI32。</p><p>Doing non-atomic reads and writes on the resulting integer can be a data race.
This method is mostly useful for FFI, where the function signature may use
<code>*mut i32</code> instead of <code>&amp;AtomicI32</code>.</p>
<p class="translate-text">从共享引用返回一个 *mut 指针到这个原子是安全的，因为原子类型具有内部可变性。 原子的所有修改都通过共享引用更改值，并且只要它们使用原子操作就可以安全地这样做。 对返回的原始指针的任何使用都需要一个不安全的块，并且仍然必须遵守相同的限制：对它的操作必须是原子的。</p><p>Returning an <code>*mut</code> pointer from a shared reference to this atomic is safe because the
atomic types work with interior mutability. All modifications of an atomic change the value
through a shared reference, and can do so safely as long as they use atomic operations. Any
use of the returned raw pointer requires an <code>unsafe</code> block and still has to uphold the same
restriction: operations on it must be atomic.</p>
<h1 id="examples-19" class="section-header"><a href="#examples-19">Examples</a></h1>
<div class='information'><div class='tooltip ignore'>ⓘ</div></div><div class="example-wrap"><pre class="rust rust-example-rendered ignore"><code><span class="kw">use</span> <span class="ident">std::sync::atomic::AtomicI32</span>;

<span class="kw">extern</span> <span class="string">&quot;C&quot;</span> {
    <span class="kw">fn</span> <span class="ident">my_atomic_op</span>(<span class="ident">arg</span>: <span class="kw-2">*</span><span class="kw-2">mut</span> <span class="ident">i32</span>);
}

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">atomic</span> <span class="op">=</span> <span class="ident">AtomicI32::new</span>(<span class="number">1</span>);

<span class="kw">unsafe</span> {
    <span class="ident">my_atomic_op</span>(<span class="ident">atomic</span>.<span class="ident">as_mut_ptr</span>());
}</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Ause%20std%3A%3Async%3A%3Aatomic%3A%3AAtomicI32%3B%0A%0Aextern%20%22C%22%20%7B%0A%20%20%20%20fn%20my_atomic_op(arg%3A%20*mut%20i32)%3B%0A%7D%0A%0Alet%20mut%20atomic%20%3D%20AtomicI32%3A%3Anew(1)%3B%0A%0Aunsafe%20%7B%0A%20%20%20%20my_atomic_op(atomic.as_mut_ptr())%3B%0A%7D%0A%7D&amp;edition=2018">Run</a></div>
</div></details></div></details><h2 id="trait-implementations" class="small-section-header">Trait Implementations<a href="#trait-implementations" class="anchor"></a></h2><div id="trait-implementations-list"><details class="rustdoc-toggle implementors-toggle" open=""><summary><div id="impl-Debug" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../../../src/core/sync/atomic.rs.html#2162-2179" title="goto source code">[src]</a></div><a href="#impl-Debug" class="anchor"></a><h3 class="code-header in-band">impl <a class="trait" href="../../fmt/trait.Debug.html" title="trait std::fmt::Debug">Debug</a> for <a class="struct" href="struct.AtomicI32.html" title="struct std::sync::atomic::AtomicI32">AtomicI32</a></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.fmt" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../../../src/core/sync/atomic.rs.html#2162-2179" title="goto source code">[src]</a></div><a href="#method.fmt" class="anchor"></a><h4 class="code-header">pub fn <a href="../../fmt/trait.Debug.html#tymethod.fmt" class="fnname">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="../../fmt/struct.Formatter.html" title="struct std::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="enum" href="../../result/enum.Result.html" title="enum std::result::Result">Result</a>&lt;<a class="primitive" href="../../primitive.unit.html">()</a>, <a class="struct" href="../../fmt/struct.Error.html" title="struct std::fmt::Error">Error</a>&gt;</h4></div></summary><div class='docblock'><p>Formats the value using the given formatter. <a href="../../fmt/trait.Debug.html#tymethod.fmt">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open=""><summary><div id="impl-Default" class="impl has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.34.0, const unstable">1.34.0 (const: <a href="https://github.com/rust-lang/rust/issues/87864" title="Tracking issue for const_default_impls">unstable</a>)</span><a class="srclink" href="../../../src/core/sync/atomic.rs.html#2162-2179" title="goto source code">[src]</a></div><a href="#impl-Default" class="anchor"></a><h3 class="code-header in-band">impl <a class="trait" href="../../default/trait.Default.html" title="trait std::default::Default">Default</a> for <a class="struct" href="struct.AtomicI32.html" title="struct std::sync::atomic::AtomicI32">AtomicI32</a></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.default" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../../../src/core/sync/atomic.rs.html#2162-2179" title="goto source code">[src]</a></div><a href="#method.default" class="anchor"></a><h4 class="code-header">pub fn <a href="../../default/trait.Default.html#tymethod.default" class="fnname">default</a>() -&gt; <a class="struct" href="struct.AtomicI32.html" title="struct std::sync::atomic::AtomicI32">AtomicI32</a></h4></div></summary><div class='docblock'><p>Returns the “default value” for a type. <a href="../../default/trait.Default.html#tymethod.default">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open=""><summary><div id="impl-From%3Ci32%3E" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../../../src/core/sync/atomic.rs.html#2162-2179" title="goto source code">[src]</a></div><a href="#impl-From%3Ci32%3E" class="anchor"></a><h3 class="code-header in-band">impl <a class="trait" href="../../convert/trait.From.html" title="trait std::convert::From">From</a>&lt;<a class="primitive" href="../../primitive.i32.html">i32</a>&gt; for <a class="struct" href="struct.AtomicI32.html" title="struct std::sync::atomic::AtomicI32">AtomicI32</a></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.from" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../../../src/core/sync/atomic.rs.html#2162-2179" title="goto source code">[src]</a></div><a href="#method.from" class="anchor"></a><h4 class="code-header">pub fn <a href="../../convert/trait.From.html#tymethod.from" class="fnname">from</a>(v: <a class="primitive" href="../../primitive.i32.html">i32</a>) -&gt; <a class="struct" href="struct.AtomicI32.html" title="struct std::sync::atomic::AtomicI32">AtomicI32</a></h4></div></summary><div class="docblock"><p>Converts an <code>i32</code> into an <code>AtomicI32</code>.</p>
</div></details></div></details><div id="impl-RefUnwindSafe" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../../../src/core/panic/unwind_safe.rs.html#215" title="goto source code">[src]</a></div><a href="#impl-RefUnwindSafe" class="anchor"></a><h3 class="code-header in-band">impl <a class="trait" href="../../panic/trait.RefUnwindSafe.html" title="trait std::panic::RefUnwindSafe">RefUnwindSafe</a> for <a class="struct" href="struct.AtomicI32.html" title="struct std::sync::atomic::AtomicI32">AtomicI32</a></h3></div><div id="impl-Sync" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../../../src/core/sync/atomic.rs.html#2162-2179" title="goto source code">[src]</a></div><a href="#impl-Sync" class="anchor"></a><h3 class="code-header in-band">impl <a class="trait" href="../../marker/trait.Sync.html" title="trait std::marker::Sync">Sync</a> for <a class="struct" href="struct.AtomicI32.html" title="struct std::sync::atomic::AtomicI32">AtomicI32</a></h3></div></div><h2 id="synthetic-implementations" class="small-section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor"></a></h2><div id="synthetic-implementations-list"><div id="impl-Send" class="impl has-srclink"><div class="rightside"></div><a href="#impl-Send" class="anchor"></a><h3 class="code-header in-band">impl <a class="trait" href="../../marker/trait.Send.html" title="trait std::marker::Send">Send</a> for <a class="struct" href="struct.AtomicI32.html" title="struct std::sync::atomic::AtomicI32">AtomicI32</a></h3></div><div id="impl-Unpin" class="impl has-srclink"><div class="rightside"></div><a href="#impl-Unpin" class="anchor"></a><h3 class="code-header in-band">impl <a class="trait" href="../../marker/trait.Unpin.html" title="trait std::marker::Unpin">Unpin</a> for <a class="struct" href="struct.AtomicI32.html" title="struct std::sync::atomic::AtomicI32">AtomicI32</a></h3></div><div id="impl-UnwindSafe" class="impl has-srclink"><div class="rightside"></div><a href="#impl-UnwindSafe" class="anchor"></a><h3 class="code-header in-band">impl <a class="trait" href="../../panic/trait.UnwindSafe.html" title="trait std::panic::UnwindSafe">UnwindSafe</a> for <a class="struct" href="struct.AtomicI32.html" title="struct std::sync::atomic::AtomicI32">AtomicI32</a></h3></div></div><h2 id="blanket-implementations" class="small-section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor"></a></h2><div id="blanket-implementations-list"><details class="rustdoc-toggle implementors-toggle" open=""><summary><div id="impl-Any" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../../../src/core/any.rs.html#132-136" title="goto source code">[src]</a></div><a href="#impl-Any" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="../../any/trait.Any.html" title="trait std::any::Any">Any</a> for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'static + ?<a class="trait" href="../../marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,&nbsp;</span></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.type_id" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../../../src/core/any.rs.html#133" title="goto source code">[src]</a></div><a href="#method.type_id" class="anchor"></a><h4 class="code-header">pub fn <a href="../../any/trait.Any.html#tymethod.type_id" class="fnname">type_id</a>(&amp;self) -&gt; <a class="struct" href="../../any/struct.TypeId.html" title="struct std::any::TypeId">TypeId</a></h4></div></summary><div class='docblock'><p>Gets the <code>TypeId</code> of <code>self</code>. <a href="../../any/trait.Any.html#tymethod.type_id">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open=""><summary><div id="impl-Borrow%3CT%3E" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../../../src/core/borrow.rs.html#208-213" title="goto source code">[src]</a></div><a href="#impl-Borrow%3CT%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="../../borrow/trait.Borrow.html" title="trait std::borrow::Borrow">Borrow</a>&lt;T&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="../../marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,&nbsp;</span></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.borrow" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../../../src/core/borrow.rs.html#210" title="goto source code">[src]</a></div><a href="#method.borrow" class="anchor"></a><h4 class="code-header">pub fn <a href="../../borrow/trait.Borrow.html#tymethod.borrow" class="fnname">borrow</a>(&amp;self) -&gt; <a class="primitive" href="../../primitive.reference.html">&amp;</a>T</h4></div></summary><div class='docblock'><p>Immutably borrows from an owned value. <a href="../../borrow/trait.Borrow.html#tymethod.borrow">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open=""><summary><div id="impl-BorrowMut%3CT%3E" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../../../src/core/borrow.rs.html#216-220" title="goto source code">[src]</a></div><a href="#impl-BorrowMut%3CT%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="../../borrow/trait.BorrowMut.html" title="trait std::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="../../marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,&nbsp;</span></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.borrow_mut" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../../../src/core/borrow.rs.html#217" title="goto source code">[src]</a></div><a href="#method.borrow_mut" class="anchor"></a><h4 class="code-header">pub fn <a href="../../borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fnname">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="../../primitive.reference.html">&amp;mut </a>T</h4></div></summary><div class='docblock'><p>Mutably borrows from an owned value. <a href="../../borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open=""><summary><div id="impl-From%3CT%3E" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../../../src/core/convert/mod.rs.html#546-550" title="goto source code">[src]</a></div><a href="#impl-From%3CT%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="../../convert/trait.From.html" title="trait std::convert::From">From</a>&lt;T&gt; for T</h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.from-1" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../../../src/core/convert/mod.rs.html#547" title="goto source code">[src]</a></div><a href="#method.from-1" class="anchor"></a><h4 class="code-header">pub fn <a href="../../convert/trait.From.html#tymethod.from" class="fnname">from</a>(t: T) -&gt; T</h4></div></summary><div class='docblock'><p>Performs the conversion.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open=""><summary><div id="impl-Into%3CU%3E" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../../../src/core/convert/mod.rs.html#535-542" title="goto source code">[src]</a></div><a href="#impl-Into%3CU%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, U&gt; <a class="trait" href="../../convert/trait.Into.html" title="trait std::convert::Into">Into</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="../../convert/trait.From.html" title="trait std::convert::From">From</a>&lt;T&gt;,&nbsp;</span></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.into" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../../../src/core/convert/mod.rs.html#539" title="goto source code">[src]</a></div><a href="#method.into" class="anchor"></a><h4 class="code-header">pub fn <a href="../../convert/trait.Into.html#tymethod.into" class="fnname">into</a>(self) -&gt; U</h4></div></summary><div class='docblock'><p>Performs the conversion.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open=""><summary><div id="impl-TryFrom%3CU%3E" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../../../src/core/convert/mod.rs.html#583-592" title="goto source code">[src]</a></div><a href="#impl-TryFrom%3CU%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, U&gt; <a class="trait" href="../../convert/trait.TryFrom.html" title="trait std::convert::TryFrom">TryFrom</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="../../convert/trait.Into.html" title="trait std::convert::Into">Into</a>&lt;T&gt;,&nbsp;</span></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle" open=""><summary><div id="associatedtype.Error" class="type trait-impl has-srclink"><a href="#associatedtype.Error" class="anchor"></a><h4 class="code-header">type <a href="../../convert/trait.TryFrom.html#associatedtype.Error" class="type">Error</a> = <a class="enum" href="../../convert/enum.Infallible.html" title="enum std::convert::Infallible">Infallible</a></h4></div></summary><div class='docblock'><p>The type returned in the event of a conversion error.</p>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.try_from" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../../../src/core/convert/mod.rs.html#589" title="goto source code">[src]</a></div><a href="#method.try_from" class="anchor"></a><h4 class="code-header">pub fn <a href="../../convert/trait.TryFrom.html#tymethod.try_from" class="fnname">try_from</a>(value: U) -&gt; <a class="enum" href="../../result/enum.Result.html" title="enum std::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="../../convert/trait.TryFrom.html" title="trait std::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="type" href="../../convert/trait.TryFrom.html#associatedtype.Error" title="type std::convert::TryFrom::Error">Error</a>&gt;</h4></div></summary><div class='docblock'><p>Performs the conversion.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open=""><summary><div id="impl-TryInto%3CU%3E" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../../../src/core/convert/mod.rs.html#569-578" title="goto source code">[src]</a></div><a href="#impl-TryInto%3CU%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, U&gt; <a class="trait" href="../../convert/trait.TryInto.html" title="trait std::convert::TryInto">TryInto</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="../../convert/trait.TryFrom.html" title="trait std::convert::TryFrom">TryFrom</a>&lt;T&gt;,&nbsp;</span></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle" open=""><summary><div id="associatedtype.Error-1" class="type trait-impl has-srclink"><a href="#associatedtype.Error-1" class="anchor"></a><h4 class="code-header">type <a href="../../convert/trait.TryInto.html#associatedtype.Error" class="type">Error</a> = &lt;U as <a class="trait" href="../../convert/trait.TryFrom.html" title="trait std::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="type" href="../../convert/trait.TryFrom.html#associatedtype.Error" title="type std::convert::TryFrom::Error">Error</a></h4></div></summary><div class='docblock'><p>The type returned in the event of a conversion error.</p>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.try_into" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../../../src/core/convert/mod.rs.html#575" title="goto source code">[src]</a></div><a href="#method.try_into" class="anchor"></a><h4 class="code-header">pub fn <a href="../../convert/trait.TryInto.html#tymethod.try_into" class="fnname">try_into</a>(self) -&gt; <a class="enum" href="../../result/enum.Result.html" title="enum std::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="../../convert/trait.TryFrom.html" title="trait std::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="type" href="../../convert/trait.TryFrom.html#associatedtype.Error" title="type std::convert::TryFrom::Error">Error</a>&gt;</h4></div></summary><div class='docblock'><p>Performs the conversion.</p>
</div></details></div></details></div></section><section id="search" class="content hidden"></section><div id="rustdoc-vars" data-root-path="../../../" data-current-crate="std" data-search-index-js="../../../search-index1.56.1.js" data-search-js="../../../search1.56.1.js"></div>
    <script src="../../../main1.56.1.js"></script>
</body></html>