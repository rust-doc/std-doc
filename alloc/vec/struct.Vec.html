<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="A contiguous growable array type, written as `Vec&lt;T&gt;` and pronounced ‘vector’."><meta name="keywords" content="rust, rustlang, rust-lang, Vec"><title>Vec in alloc::vec - Rust</title><link rel="stylesheet" type="text/css" href="../../normalize1.56.1.css"><link rel="stylesheet" type="text/css" href="../../rustdoc1.56.1.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../light1.56.1.css" id="themeStyle"><link rel="stylesheet" type="text/css" href="../../dark1.56.1.css" disabled=""><link rel="stylesheet" type="text/css" href="../../ayu1.56.1.css" disabled=""><script id="default-settings"></script><script src="../../storage1.56.1.js"></script><script src="../../crates1.56.1.js"></script><noscript><link rel="stylesheet" href="../../noscript1.56.1.css"></noscript><link rel="alternate icon" type="image/png" href="../../favicon-16x161.56.1.png"><link rel="alternate icon" type="image/png" href="../../favicon-32x321.56.1.png"><link rel="icon" type="image/svg+xml" href="../../favicon1.56.1.svg"><style type="text/css">#crate-search{background-image:url("../../down-arrow1.56.1.svg");}</style></head><body class="rustdoc struct"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu" role="button">&#9776;</div><a href='../../alloc/index.html'><div class='logo-container rust-logo'><img src='../../rust-logo1.56.1.png' alt='logo'></div></a><h2 class="location">Struct Vec</h2><div class="sidebar-elems"><div class="block items"><h3 class="sidebar-title"><a href="#implementations">Methods</a></h3><div class="sidebar-links"><a href="#method.allocator">allocator</a><a href="#method.append">append</a><a href="#method.as_mut_ptr">as_mut_ptr</a><a href="#method.as_mut_slice">as_mut_slice</a><a href="#method.as_ptr">as_ptr</a><a href="#method.as_slice">as_slice</a><a href="#method.capacity">capacity</a><a href="#method.clear">clear</a><a href="#method.dedup">dedup</a><a href="#method.dedup_by">dedup_by</a><a href="#method.dedup_by_key">dedup_by_key</a><a href="#method.drain">drain</a><a href="#method.drain_filter">drain_filter</a><a href="#method.extend_from_slice">extend_from_slice</a><a href="#method.extend_from_within">extend_from_within</a><a href="#method.from_raw_parts">from_raw_parts</a><a href="#method.from_raw_parts_in">from_raw_parts_in</a><a href="#method.insert">insert</a><a href="#method.into_boxed_slice">into_boxed_slice</a><a href="#method.into_raw_parts">into_raw_parts</a><a href="#method.into_raw_parts_with_alloc">into_raw_parts_with_alloc</a><a href="#method.is_empty">is_empty</a><a href="#method.leak">leak</a><a href="#method.len">len</a><a href="#method.new">new</a><a href="#method.new_in">new_in</a><a href="#method.pop">pop</a><a href="#method.push">push</a><a href="#method.remove">remove</a><a href="#method.reserve">reserve</a><a href="#method.reserve_exact">reserve_exact</a><a href="#method.resize">resize</a><a href="#method.resize_with">resize_with</a><a href="#method.retain">retain</a><a href="#method.set_len">set_len</a><a href="#method.shrink_to">shrink_to</a><a href="#method.shrink_to_fit">shrink_to_fit</a><a href="#method.spare_capacity_mut">spare_capacity_mut</a><a href="#method.splice">splice</a><a href="#method.split_at_spare_mut">split_at_spare_mut</a><a href="#method.split_off">split_off</a><a href="#method.swap_remove">swap_remove</a><a href="#method.truncate">truncate</a><a href="#method.try_reserve">try_reserve</a><a href="#method.try_reserve_exact">try_reserve_exact</a><a href="#method.with_capacity">with_capacity</a><a href="#method.with_capacity_in">with_capacity_in</a></div><h3 class="sidebar-title"><a href="#trait-implementations">Trait Implementations</a></h3><div class="sidebar-links"><a href="#impl-AsMut%3C%5BT%5D%3E">AsMut&lt;[T]&gt;</a><a href="#impl-AsMut%3CVec%3CT%2C%20A%3E%3E">AsMut&lt;Vec&lt;T, A&gt;&gt;</a><a href="#impl-AsRef%3C%5BT%5D%3E">AsRef&lt;[T]&gt;</a><a href="#impl-AsRef%3CVec%3CT%2C%20A%3E%3E">AsRef&lt;Vec&lt;T, A&gt;&gt;</a><a href="#impl-Borrow%3C%5BT%5D%3E">Borrow&lt;[T]&gt;</a><a href="#impl-BorrowMut%3C%5BT%5D%3E">BorrowMut&lt;[T]&gt;</a><a href="#impl-Clone">Clone</a><a href="#impl-Debug">Debug</a><a href="#impl-Default">Default</a><a href="#impl-Deref">Deref</a><a href="#impl-DerefMut">DerefMut</a><a href="#impl-Drop">Drop</a><a href="#impl-Eq">Eq</a><a href="#impl-Extend%3C%26%27a%20T%3E">Extend&lt;&amp;&#39;a T&gt;</a><a href="#impl-Extend%3CT%3E">Extend&lt;T&gt;</a><a href="#impl-From%3C%26%27_%20%5BT%5D%3E">From&lt;&amp;&#39;_ [T]&gt;</a><a href="#impl-From%3C%26%27_%20mut%20%5BT%5D%3E">From&lt;&amp;&#39;_ mut [T]&gt;</a><a href="#impl-From%3C%26%27_%20str%3E">From&lt;&amp;&#39;_ str&gt;</a><a href="#impl-From%3C%26%27a%20Vec%3CT%2C%20Global%3E%3E">From&lt;&amp;&#39;a Vec&lt;T, Global&gt;&gt;</a><a href="#impl-From%3C%5BT%3B%20N%5D%3E">From&lt;[T; N]&gt;</a><a href="#impl-From%3CBinaryHeap%3CT%3E%3E">From&lt;BinaryHeap&lt;T&gt;&gt;</a><a href="#impl-From%3CBox%3C%5BT%5D%2C%20A%3E%3E">From&lt;Box&lt;[T], A&gt;&gt;</a><a href="#impl-From%3CCow%3C%27a%2C%20%5BT%5D%3E%3E">From&lt;Cow&lt;&#39;a, [T]&gt;&gt;</a><a href="#impl-From%3CString%3E">From&lt;String&gt;</a><a href="#impl-From%3CVec%3CT%2C%20A%3E%3E">From&lt;Vec&lt;T, A&gt;&gt;</a><a href="#impl-From%3CVec%3CT%2C%20Global%3E%3E">From&lt;Vec&lt;T, Global&gt;&gt;</a><a href="#impl-From%3CVecDeque%3CT%2C%20A%3E%3E">From&lt;VecDeque&lt;T, A&gt;&gt;</a><a href="#impl-FromIterator%3CT%3E">FromIterator&lt;T&gt;</a><a href="#impl-Hash">Hash</a><a href="#impl-Index%3CI%3E">Index&lt;I&gt;</a><a href="#impl-IndexMut%3CI%3E">IndexMut&lt;I&gt;</a><a href="#impl-IntoIterator">IntoIterator</a><a href="#impl-Ord">Ord</a><a href="#impl-PartialEq%3C%26%27_%20%5BU%3B%20N%5D%3E">PartialEq&lt;&amp;&#39;_ [U; N]&gt;</a><a href="#impl-PartialEq%3C%26%27_%20%5BU%5D%3E">PartialEq&lt;&amp;&#39;_ [U]&gt;</a><a href="#impl-PartialEq%3C%26%27_%20mut%20%5BU%5D%3E">PartialEq&lt;&amp;&#39;_ mut [U]&gt;</a><a href="#impl-PartialEq%3C%5BU%3B%20N%5D%3E">PartialEq&lt;[U; N]&gt;</a><a href="#impl-PartialEq%3C%5BU%5D%3E">PartialEq&lt;[U]&gt;</a><a href="#impl-PartialEq%3CVec%3CU%2C%20A%3E%3E">PartialEq&lt;Vec&lt;U, A&gt;&gt;</a><a href="#impl-PartialOrd%3CVec%3CT%2C%20A%3E%3E">PartialOrd&lt;Vec&lt;T, A&gt;&gt;</a><a href="#impl-TryFrom%3CVec%3CT%2C%20A%3E%3E">TryFrom&lt;Vec&lt;T, A&gt;&gt;</a></div><h3 class="sidebar-title"><a href="#synthetic-implementations">Auto Trait Implementations</a></h3><div class="sidebar-links"><a href="#impl-RefUnwindSafe">RefUnwindSafe</a><a href="#impl-Send">Send</a><a href="#impl-Sync">Sync</a><a href="#impl-Unpin">Unpin</a><a href="#impl-UnwindSafe">UnwindSafe</a></div><h3 class="sidebar-title"><a href="#blanket-implementations">Blanket Implementations</a></h3><div class="sidebar-links"><a href="#impl-Any">Any</a><a href="#impl-Borrow%3CT%3E">Borrow&lt;T&gt;</a><a href="#impl-BorrowMut%3CT%3E">BorrowMut&lt;T&gt;</a><a href="#impl-From%3CT%3E">From&lt;T&gt;</a><a href="#impl-Into%3CU%3E">Into&lt;U&gt;</a><a href="#impl-ToOwned">ToOwned</a><a href="#impl-TryFrom%3CU%3E">TryFrom&lt;U&gt;</a><a href="#impl-TryInto%3CU%3E">TryInto&lt;U&gt;</a></div></div><h2 class="location">Other items in<br><a href="../index.html">alloc</a>::<wbr><a href="index.html">vec</a></h2><div id="sidebar-vars" data-name="Vec" data-ty="struct" data-relpath=""></div><script defer="" src="sidebar-items.js"></script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu" title="themes"><img width="18" height="18" alt="Pick another theme!" src="../../brush1.56.1.svg"></button><div id="theme-choices" role="menu"></div></div><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" disabled="" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><button type="button" id="help-button" title="help">?</button><a id="settings-menu" href="../../settings.html" title="settings"><img width="18" height="18" alt="Change settings" src="../../wheel1.56.1.svg"></a></div></form></nav><section id="main" class="content"><h1 class="fqn"><span class="in-band">Struct <a href="../index.html">alloc</a>::<wbr><a href="index.html">vec</a>::<wbr><a class="struct" href="#">Vec</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../../clipboard1.56.1.svg" width="19" height="18" alt="Copy item path"></button></span><span class="out-of-band"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><span id="render-detail"><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span><a class="srclink" href="../../src/alloc/vec/mod.rs.html#398-401" title="goto source code">[src]</a></span></h1><div class="docblock type-decl"><pre class="rust struct"><code>pub struct Vec&lt;T, A:&nbsp;<a class="trait" href="../alloc/trait.Allocator.html" title="trait alloc::alloc::Allocator">Allocator</a>&nbsp;=&nbsp;<a class="struct" href="../alloc/struct.Global.html" title="struct alloc::alloc::Global">Global</a>&gt; { /* fields omitted */ }</code></pre></div><details class="rustdoc-toggle top-doc" open=""><summary class="hideme"><span>Expand description</span></summary><div class="docblock" xpath="/html[1]/body[1]/section[1]/details[1]/div[1]" istranslationnode="true" main_mp="YW1sbmc/PnNlYjo7UmBn"><p class="translate-text">一种连续可增长的数组类型，写为 Vec<t> 并发音为“vector”。</t></p><p>A contiguous growable array type, written as <code>Vec&lt;T&gt;</code> and pronounced ‘vector’.</p>
<h1 id="examples" class="section-header"><a href="#examples">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">vec</span> <span class="op">=</span> <span class="ident">Vec::new</span>();
<span class="ident">vec</span>.<span class="ident">push</span>(<span class="number">1</span>);
<span class="ident">vec</span>.<span class="ident">push</span>(<span class="number">2</span>);

<span class="macro">assert_eq!</span>(<span class="ident">vec</span>.<span class="ident">len</span>(), <span class="number">2</span>);
<span class="macro">assert_eq!</span>(<span class="ident">vec</span>[<span class="number">0</span>], <span class="number">1</span>);

<span class="macro">assert_eq!</span>(<span class="ident">vec</span>.<span class="ident">pop</span>(), <span class="prelude-val">Some</span>(<span class="number">2</span>));
<span class="macro">assert_eq!</span>(<span class="ident">vec</span>.<span class="ident">len</span>(), <span class="number">1</span>);

<span class="ident">vec</span>[<span class="number">0</span>] <span class="op">=</span> <span class="number">7</span>;
<span class="macro">assert_eq!</span>(<span class="ident">vec</span>[<span class="number">0</span>], <span class="number">7</span>);

<span class="ident">vec</span>.<span class="ident">extend</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].<span class="ident">iter</span>().<span class="ident">copied</span>());

<span class="kw">for</span> <span class="ident">x</span> <span class="kw">in</span> <span class="kw-2">&amp;</span><span class="ident">vec</span> {
    <span class="macro">println!</span>(<span class="string">&quot;{}&quot;</span>, <span class="ident">x</span>);
}
<span class="macro">assert_eq!</span>(<span class="ident">vec</span>, [<span class="number">7</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20mut%20vec%20%3D%20Vec%3A%3Anew()%3B%0Avec.push(1)%3B%0Avec.push(2)%3B%0A%0Aassert_eq!(vec.len()%2C%202)%3B%0Aassert_eq!(vec%5B0%5D%2C%201)%3B%0A%0Aassert_eq!(vec.pop()%2C%20Some(2))%3B%0Aassert_eq!(vec.len()%2C%201)%3B%0A%0Avec%5B0%5D%20%3D%207%3B%0Aassert_eq!(vec%5B0%5D%2C%207)%3B%0A%0Avec.extend(%5B1%2C%202%2C%203%5D.iter().copied())%3B%0A%0Afor%20x%20in%20%26vec%20%7B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20x)%3B%0A%7D%0Aassert_eq!(vec%2C%20%5B7%2C%201%2C%202%2C%203%5D)%3B%0A%7D&amp;edition=2018">Run</a></div>
<p class="translate-text">维克！ 提供宏以方便初始化：</p><p>The <a href="../macro.vec.html" title="vec!"><code>vec!</code></a> macro is provided for convenient initialization:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">vec1</span> <span class="op">=</span> <span class="macro">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];
<span class="ident">vec1</span>.<span class="ident">push</span>(<span class="number">4</span>);
<span class="kw">let</span> <span class="ident">vec2</span> <span class="op">=</span> <span class="ident">Vec::from</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]);
<span class="macro">assert_eq!</span>(<span class="ident">vec1</span>, <span class="ident">vec2</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20mut%20vec1%20%3D%20vec!%5B1%2C%202%2C%203%5D%3B%0Avec1.push(4)%3B%0Alet%20vec2%20%3D%20Vec%3A%3Afrom(%5B1%2C%202%2C%203%2C%204%5D)%3B%0Aassert_eq!(vec1%2C%20vec2)%3B%0A%7D&amp;edition=2018">Run</a></div>
<p class="translate-text">它还可以使用给定值初始化 Vec<t> 的每个元素。 这可能比在单独的步骤中执行分配和初始化更有效，尤其是在初始化零Vector时：</t></p><p>It can also initialize each element of a <code>Vec&lt;T&gt;</code> with a given value.
This may be more efficient than performing allocation and initialization
in separate steps, especially when initializing a vector of zeros:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">vec</span> <span class="op">=</span> <span class="macro">vec!</span>[<span class="number">0</span>; <span class="number">5</span>];
<span class="macro">assert_eq!</span>(<span class="ident">vec</span>, [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]);

<span class="comment">// The following is equivalent, but potentially slower:</span>
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">vec</span> <span class="op">=</span> <span class="ident">Vec::with_capacity</span>(<span class="number">5</span>);
<span class="ident">vec</span>.<span class="ident">resize</span>(<span class="number">5</span>, <span class="number">0</span>);
<span class="macro">assert_eq!</span>(<span class="ident">vec</span>, [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20vec%20%3D%20vec!%5B0%3B%205%5D%3B%0Aassert_eq!(vec%2C%20%5B0%2C%200%2C%200%2C%200%2C%200%5D)%3B%0A%0A%2F%2F%20The%20following%20is%20equivalent%2C%20but%20potentially%20slower%3A%0Alet%20mut%20vec%20%3D%20Vec%3A%3Awith_capacity(5)%3B%0Avec.resize(5%2C%200)%3B%0Aassert_eq!(vec%2C%20%5B0%2C%200%2C%200%2C%200%2C%200%5D)%3B%0A%7D&amp;edition=2018">Run</a></div>
<p class="translate-text">有关详细信息，请参阅容量和重新分配。</p><p>For more information, see
<a href="#capacity-and-reallocation">Capacity and Reallocation</a>.</p>
<p class="translate-text">使用 Vec<t> 作为有效堆栈：</t></p><p>Use a <code>Vec&lt;T&gt;</code> as an efficient stack:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">stack</span> <span class="op">=</span> <span class="ident">Vec::new</span>();

<span class="ident">stack</span>.<span class="ident">push</span>(<span class="number">1</span>);
<span class="ident">stack</span>.<span class="ident">push</span>(<span class="number">2</span>);
<span class="ident">stack</span>.<span class="ident">push</span>(<span class="number">3</span>);

<span class="kw">while</span> <span class="kw">let</span> <span class="prelude-val">Some</span>(<span class="ident">top</span>) <span class="op">=</span> <span class="ident">stack</span>.<span class="ident">pop</span>() {
    <span class="comment">// Prints 3, 2, 1</span>
    <span class="macro">println!</span>(<span class="string">&quot;{}&quot;</span>, <span class="ident">top</span>);
}</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20mut%20stack%20%3D%20Vec%3A%3Anew()%3B%0A%0Astack.push(1)%3B%0Astack.push(2)%3B%0Astack.push(3)%3B%0A%0Awhile%20let%20Some(top)%20%3D%20stack.pop()%20%7B%0A%20%20%20%20%2F%2F%20Prints%203%2C%202%2C%201%0A%20%20%20%20println!(%22%7B%7D%22%2C%20top)%3B%0A%7D%0A%7D&amp;edition=2018">Run</a></div>
<h1 id="indexing" class="section-header"><a href="#indexing">Indexing</a></h1>
<p class="translate-text">Vec 类型允许通过索引访问值，因为它实现了 Index Trait。 一个例子会更明确：</p><p>The <code>Vec</code> type allows to access values by index, because it implements the
<a href="../../core/ops/index/trait.Index.html" title="Index"><code>Index</code></a> trait. An example will be more explicit:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">v</span> <span class="op">=</span> <span class="macro">vec!</span>[<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>];
<span class="macro">println!</span>(<span class="string">&quot;{}&quot;</span>, <span class="ident">v</span>[<span class="number">1</span>]); <span class="comment">// it will display &#39;2&#39;</span></code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20v%20%3D%20vec!%5B0%2C%202%2C%204%2C%206%5D%3B%0Aprintln!(%22%7B%7D%22%2C%20v%5B1%5D)%3B%20%2F%2F%20it%20will%20display%20'2'%0A%7D&amp;edition=2018">Run</a></div>
<p class="translate-text">但是要小心：如果您尝试访问不在 Vec 中的索引，您的软件将会崩溃！ 你不能做这个：</p><p>However be careful: if you try to access an index which isn’t in the <code>Vec</code>,
your software will panic! You cannot do this:</p>

<div class='information'><div class='tooltip should_panic'>ⓘ</div></div><div class="example-wrap"><pre class="rust rust-example-rendered should_panic"><code><span class="kw">let</span> <span class="ident">v</span> <span class="op">=</span> <span class="macro">vec!</span>[<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>];
<span class="macro">println!</span>(<span class="string">&quot;{}&quot;</span>, <span class="ident">v</span>[<span class="number">6</span>]); <span class="comment">// it will panic!</span></code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20v%20%3D%20vec!%5B0%2C%202%2C%204%2C%206%5D%3B%0Aprintln!(%22%7B%7D%22%2C%20v%5B6%5D)%3B%20%2F%2F%20it%20will%20panic!%0A%7D&amp;edition=2018">Run</a></div>
<p class="translate-text">如果要检查索引是否在 Vec 中，请使用 get 和 get_mut。</p><p>Use <a href="../../std/vec/struct.Vec.html#method.get"><code>get</code></a> and <a href="../../std/vec/struct.Vec.html#method.get_mut"><code>get_mut</code></a> if you want to check whether the index is in
the <code>Vec</code>.</p>
<h1 id="slicing" class="section-header"><a href="#slicing">Slicing</a></h1>
<p class="translate-text">Vec 可以是可变的。 另一方面，切片是只读对象。 要获得切片，请使用 &。 例子：</p><p>A <code>Vec</code> can be mutable. On the other hand, slices are read-only objects.
To get a <a href="https://doc.rust-lang.org/1.56.1/std/primitive.slice.html" title="slice">slice</a>, use <a href="https://doc.rust-lang.org/1.56.1/std/primitive.reference.html" title="&amp;"><code>&amp;</code></a>. Example:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">fn</span> <span class="ident">read_slice</span>(<span class="ident">slice</span>: <span class="kw-2">&amp;</span>[<span class="ident">usize</span>]) {
    <span class="comment">// ...</span>
}

<span class="kw">let</span> <span class="ident">v</span> <span class="op">=</span> <span class="macro">vec!</span>[<span class="number">0</span>, <span class="number">1</span>];
<span class="ident">read_slice</span>(<span class="kw-2">&amp;</span><span class="ident">v</span>);

<span class="comment">// ... and that&#39;s all!</span>
<span class="comment">// you can also do it like this:</span>
<span class="kw">let</span> <span class="ident">u</span>: <span class="kw-2">&amp;</span>[<span class="ident">usize</span>] <span class="op">=</span> <span class="kw-2">&amp;</span><span class="ident">v</span>;
<span class="comment">// or like this:</span>
<span class="kw">let</span> <span class="ident">u</span>: <span class="kw-2">&amp;</span>[<span class="kw">_</span>] <span class="op">=</span> <span class="kw-2">&amp;</span><span class="ident">v</span>;</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Afn%20read_slice(slice%3A%20%26%5Busize%5D)%20%7B%0A%20%20%20%20%2F%2F%20...%0A%7D%0A%0Alet%20v%20%3D%20vec!%5B0%2C%201%5D%3B%0Aread_slice(%26v)%3B%0A%0A%2F%2F%20...%20and%20that's%20all!%0A%2F%2F%20you%20can%20also%20do%20it%20like%20this%3A%0Alet%20u%3A%20%26%5Busize%5D%20%3D%20%26v%3B%0A%2F%2F%20or%20like%20this%3A%0Alet%20u%3A%20%26%5B_%5D%20%3D%20%26v%3B%0A%7D&amp;edition=2018">Run</a></div>
<p class="translate-text">在 Rust 中，当您只想提供读取访问权限时，将切片作为参数而不是Vector传递更为常见。 String 和 &str 也是如此。</p><p>In Rust, it’s more common to pass slices as arguments rather than vectors
when you just want to provide read access. The same goes for <a href="../string/struct.String.html"><code>String</code></a> and
<a href="https://doc.rust-lang.org/1.56.1/std/primitive.str.html"><code>&amp;str</code></a>.</p>
<h1 id="capacity-and-reallocation" class="section-header"><a href="#capacity-and-reallocation">Capacity and reallocation</a></h1>
<p class="translate-text">Vector的容量是为将添加到Vector上的任何未来元素分配的空间量。 不要与Vector的长度混淆，Vector的长度指定Vector中实际元素的数量。 如果一个Vector的长度超过了它的容量，它的容量会自动增加，但它的元素必须重新分配。</p><p>The capacity of a vector is the amount of space allocated for any future
elements that will be added onto the vector. This is not to be confused with
the <em>length</em> of a vector, which specifies the number of actual elements
within the vector. If a vector’s length exceeds its capacity, its capacity
will automatically be increased, but its elements will have to be
reallocated.</p>
<p class="translate-text">例如，容量为 10 且长度为 0 的Vector将是一个空Vector，其空间可容纳 10 个以上的元素。 将 10 个或更少的元素推送到Vector上不会改变其容量或导致发生重新分配。 但是，如果Vector的长度增加到 11，它将不得不重新分配，这可能会很慢。 出于这个原因，建议尽可能使用 Vec::with_capacity 来指定Vector的预期大小。</p><p>For example, a vector with capacity 10 and length 0 would be an empty vector
with space for 10 more elements. Pushing 10 or fewer elements onto the
vector will not change its capacity or cause reallocation to occur. However,
if the vector’s length is increased to 11, it will have to reallocate, which
can be slow. For this reason, it is recommended to use <a href="struct.Vec.html#method.with_capacity" title="Vec::with_capacity"><code>Vec::with_capacity</code></a>
whenever possible to specify how big the vector is expected to get.</p>
<h1 id="guarantees" class="section-header"><a href="#guarantees">Guarantees</a></h1>
<p class="translate-text">由于其令人难以置信的基本性质，Vec 对其设计做出了很多保证。 这确保了它在一般情况下的开销尽可能低，并且可以通过不安全的代码以原始方式正确操作。 请注意，这些保证指的是不合格的 Vec<t>。 如果添加了额外的类型参数（例如，支持自定义分配器），覆盖它们的默认值可能会改变行为。</t></p><p>Due to its incredibly fundamental nature, <code>Vec</code> makes a lot of guarantees
about its design. This ensures that it’s as low-overhead as possible in
the general case, and can be correctly manipulated in primitive ways
by unsafe code. Note that these guarantees refer to an unqualified <code>Vec&lt;T&gt;</code>.
If additional type parameters are added (e.g., to support custom allocators),
overriding their defaults may change the behavior.</p>
<p class="translate-text">最根本的是， Vec 一直是（指针、容量、长度）三元组。 不多也不少。 这些字段的顺序是完全未指定的，您应该使用适当的方法来修改它们。 指针永远不会为空，因此这种类型是空指针优化的。</p><p>Most fundamentally, <code>Vec</code> is and always will be a (pointer, capacity, length)
triplet. No more, no less. The order of these fields is completely
unspecified, and you should use the appropriate methods to modify these.
The pointer will never be null, so this type is null-pointer-optimized.</p>
<p class="translate-text">但是，指针可能实际上并不指向分配的内存。 特别是，如果你通过 Vec::new, vec![], Vec::with_capacity(0) 构造一个容量为 0 的 Vec，或者在一个空的 Vec 上调用 shrink_to_fit，它不会分配内存。 同样，如果您在 Vec 中存储大小为零的类型，它不会为它们分配空间。 请注意，在这种情况下，Vec 可能不会报告容量为 0。当且仅当 mem::size_of::<t>() * capacity() > 0 时，Vec 才会分配。通常，Vec 的分配细节非常微妙—— 如果您打算使用 Vec 分配内存并将其用于其他用途（传递给不安全的代码，或构建您自己的内存支持的集合），请务必使用 from_raw_parts 释放此内存以恢复 Vec 然后丢弃 它。</t></p><p>However, the pointer might not actually point to allocated memory. In particular,
if you construct a <code>Vec</code> with capacity 0 via <a href="struct.Vec.html#method.new" title="Vec::new"><code>Vec::new</code></a>, <a href="../macro.vec.html" title="vec!"><code>vec![]</code></a>,
<a href="struct.Vec.html#method.with_capacity" title="Vec::with_capacity"><code>Vec::with_capacity(0)</code></a>, or by calling <a href="struct.Vec.html#method.shrink_to_fit"><code>shrink_to_fit</code></a>
on an empty Vec, it will not allocate memory. Similarly, if you store zero-sized
types inside a <code>Vec</code>, it will not allocate space for them. <em>Note that in this case
the <code>Vec</code> might not report a <a href="struct.Vec.html#method.capacity"><code>capacity</code></a> of 0</em>. <code>Vec</code> will allocate if and only
if <a href="../../core/mem/fn.size_of.html"><code>mem::size_of::&lt;T&gt;</code></a><code>() * capacity() &gt; 0</code>. In general, <code>Vec</code>’s allocation
details are very subtle — if you intend to allocate memory using a <code>Vec</code>
and use it for something else (either to pass to unsafe code, or to build your
own memory-backed collection), be sure to deallocate this memory by using
<code>from_raw_parts</code> to recover the <code>Vec</code> and then dropping it.</p>
<p class="translate-text">如果 Vec 已分配内存，则它指向的内存在堆上（由分配器定义，Rust 配置为默认使用），并且它的指针指向 len 按顺序初始化的连续元素（如果 您将其强制为切片），然后是 capacity-len 逻辑上未初始化的连续元素。</p><p>If a <code>Vec</code> <em>has</em> allocated memory, then the memory it points to is on the heap
(as defined by the allocator Rust is configured to use by default), and its
pointer points to <a href="struct.Vec.html#method.len"><code>len</code></a> initialized, contiguous elements in order (what
you would see if you coerced it to a slice), followed by <a href="struct.Vec.html#method.capacity"><code>capacity</code></a><code>-</code><a href="struct.Vec.html#method.len"><code>len</code></a> logically uninitialized, contiguous elements.</p>
<p class="translate-text">包含容量为 4 的元素“a”和“b”的Vector可以如下所示进行可视化。 最上面的部分是 Vec 结构，它包含一个指向堆中分配头部的指针，长度和容量。 底部是堆上的分配，一个连续的内存块。</p><p>A vector containing the elements <code>'a'</code> and <code>'b'</code> with capacity 4 can be
visualized as below. The top part is the <code>Vec</code> struct, it contains a
pointer to the head of the allocation in the heap, length and capacity.
The bottom part is the allocation on the heap, a contiguous memory block.</p>
<div class="example-wrap"><pre class="language-text"><code>            ptr      len  capacity
       +--------+--------+--------+
       | 0x0123 |      2 |      4 |
       +--------+--------+--------+
            |
            v
Heap   +--------+--------+--------+--------+
       |    &#39;a&#39; |    &#39;b&#39; | uninit | uninit |
       +--------+--------+--------+--------+</code></pre></div>
<ul>
<li class="translate-text">uninit 表示未初始化的内存，请参见 MaybeUninit。</li><li><strong>uninit</strong> represents memory that is not initialized, see <a href="../../core/mem/maybe_uninit/union.MaybeUninit.html"><code>MaybeUninit</code></a>.</li>
<li class="translate-text">注意：ABI 不稳定，Vec 不保证其内存布局（包括字段顺序）。</li><li>Note: the ABI is not stable and <code>Vec</code> makes no guarantees about its memory
layout (including the order of fields).</li>
</ul>
<p class="translate-text">Vec 永远不会执行“小优化”，其中元素实际上存储在堆栈中，原因有两个：</p><p><code>Vec</code> will never perform a “small optimization” where elements are actually
stored on the stack for two reasons:</p>
<ul>
<li class="translate-text">这将使不安全代码更难以正确操作 Vec。 一个 Vec 的内容如果只是被移动就不会有一个稳定的地址，而且很难确定一个 Vec 是否真的分配了内存。</li><li>
<p>It would make it more difficult for unsafe code to correctly manipulate
a <code>Vec</code>. The contents of a <code>Vec</code> wouldn’t have a stable address if it were
only moved, and it would be more difficult to determine if a <code>Vec</code> had
actually allocated memory.</p>
</li>
<li class="translate-text">它会惩罚一般情况，每次访问都会产生一个额外的分支。</li><li>
<p>It would penalize the general case, incurring an additional branch
on every access.</p>
</li>
</ul>
<p class="translate-text">Vec 永远不会自动收缩自身，即使完全为空。 这确保不会发生不必要的分配或释放。 清空 Vec 然后将其填充回相同的 len 应该不会调用分配器。 如果您希望释放未使用的内存，请使用 shrink_to_fit 或 shrink_to。</p><p><code>Vec</code> will never automatically shrink itself, even if completely empty. This
ensures no unnecessary allocations or deallocations occur. Emptying a <code>Vec</code>
and then filling it back up to the same <a href="struct.Vec.html#method.len"><code>len</code></a> should incur no calls to
the allocator. If you wish to free up unused memory, use
<a href="struct.Vec.html#method.shrink_to_fit"><code>shrink_to_fit</code></a> or <a href="struct.Vec.html#method.shrink_to"><code>shrink_to</code></a>.</p>
<p class="translate-text">如果报告的容量足够， push 和 insert 将永远不会（重新）分配。 如果 len== 容量， push 和 insert 将（重新）分配。 也就是说，报告的容量是完全准确的，并且可以依赖。 如果需要，它甚至可以用于手动释放 Vec 分配的内存。 批量插入方法可能会重新分配，即使没有必要。</p><p><a href="struct.Vec.html#method.push"><code>push</code></a> and <a href="struct.Vec.html#method.insert"><code>insert</code></a> will never (re)allocate if the reported capacity is
sufficient. <a href="struct.Vec.html#method.push"><code>push</code></a> and <a href="struct.Vec.html#method.insert"><code>insert</code></a> <em>will</em> (re)allocate if
<a href="struct.Vec.html#method.len"><code>len</code></a><code>==</code><a href="struct.Vec.html#method.capacity"><code>capacity</code></a>. That is, the reported capacity is completely
accurate, and can be relied on. It can even be used to manually free the memory
allocated by a <code>Vec</code> if desired. Bulk insertion methods <em>may</em> reallocate, even
when not necessary.</p>
<p class="translate-text">Vec 不保证在满时重新分配或调用储备时任何特定的增长策略。 目前的策略是基本的，使用非常量生长因子可能证明是可取的。 无论使用什么策略，当然都会保证 O(1) 摊销推送。</p><p><code>Vec</code> does not guarantee any particular growth strategy when reallocating
when full, nor when <a href="struct.Vec.html#method.reserve"><code>reserve</code></a> is called. The current strategy is basic
and it may prove desirable to use a non-constant growth factor. Whatever
strategy is used will of course guarantee <em>O</em>(1) amortized <a href="struct.Vec.html#method.push"><code>push</code></a>.</p>
<p class="translate-text">Vector！[x; n]、vec![a, b, c, d] 和 Vec::with_capacity(n) 都将生成具有所需容量的 Vec。 如果 len==capacity，（就像 vec! 宏的情况一样），则 Vec<t> 可以与 Box<[T]> 相互转换，而无需重新分配或移动元素。</t></p><p><code>vec![x; n]</code>, <code>vec![a, b, c, d]</code>, and
<a href="struct.Vec.html#method.with_capacity" title="Vec::with_capacity"><code>Vec::with_capacity(n)</code></a>, will all produce a <code>Vec</code>
with exactly the requested capacity. If <a href="struct.Vec.html#method.len"><code>len</code></a><code>==</code><a href="struct.Vec.html#method.capacity"><code>capacity</code></a>,
(as is the case for the <a href="../macro.vec.html" title="vec!"><code>vec!</code></a> macro), then a <code>Vec&lt;T&gt;</code> can be converted to
and from a <a href="../boxed/struct.Box.html"><code>Box&lt;[T]&gt;</code></a> without reallocating or moving the elements.</p>
<p class="translate-text">Vec 不会专门覆盖从中删除的任何数据，但也不会专门保留它。 它的未初始化内存是它可以随意使用的暂存空间。 它通常只会做最有效或易于实施的任何事情。 出于安全目的，不要依赖删除已删除的数据。 即使你删除了一个 Vec，它的缓冲区也可能被另一个 Vec 重用。 即使您首先将 Vec 的内存归零，这实际上也可能不会发生，因为优化器并不认为这是必须保留的副作用。 然而，有一种情况我们不会打破：使用不安全的代码写入多余的容量，然后增加长度以匹配，总是有效的。</p><p><code>Vec</code> will not specifically overwrite any data that is removed from it,
but also won’t specifically preserve it. Its uninitialized memory is
scratch space that it may use however it wants. It will generally just do
whatever is most efficient or otherwise easy to implement. Do not rely on
removed data to be erased for security purposes. Even if you drop a <code>Vec</code>, its
buffer may simply be reused by another <code>Vec</code>. Even if you zero a <code>Vec</code>’s memory
first, that might not actually happen because the optimizer does not consider
this a side-effect that must be preserved. There is one case which we will
not break, however: using <code>unsafe</code> code to write to the excess capacity,
and then increasing the length to match, is always valid.</p>
<p class="translate-text">目前，Vec 不保证删除元素的顺序。 顺序过去已更改，可能会再次更改。</p><p>Currently, <code>Vec</code> does not guarantee the order in which elements are dropped.
The order has changed in the past and may change again.</p>
</div></details><h2 id="implementations" class="small-section-header">Implementations<a href="#implementations" class="anchor"></a></h2><details class="rustdoc-toggle implementors-toggle" open=""><summary><div id="impl" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../../src/alloc/vec/mod.rs.html#407-536" title="goto source code">[src]</a></div><a href="#impl" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="struct" href="struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;T&gt;</h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.new" class="method has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.0.0, const since 1.39.0">1.0.0 (const: 1.39.0)</span><a class="srclink" href="../../src/alloc/vec/mod.rs.html#421-423" title="goto source code">[src]</a></div><a href="#method.new" class="anchor"></a><h4 class="code-header">pub const fn <a href="#method.new" class="fnname">new</a>() -&gt; Self</h4></div></summary><div class="docblock" xpath="/html[1]/body[1]/section[1]/details[2]/div[1]/details[1]/div[1]" istranslationnode="true" main_mp="YW1sbmc/PnNlYjo7UmBnOUQ9MFZ4enZ0fC8qK3pwYw=="><p class="translate-text">构造一个新的空 Vec<t>。</t></p><p>Constructs a new, empty <code>Vec&lt;T&gt;</code>.</p>
<p class="translate-text">在元素被推到它上面之前，Vector不会分配。</p><p>The vector will not allocate until elements are pushed onto it.</p>
<h1 id="examples-1" class="section-header"><a href="#examples-1">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">vec</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">i32</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">Vec::new</span>();</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Ballow(unused_mut)%5D%0Afn%20main()%20%7B%0Alet%20mut%20vec%3A%20Vec%3Ci32%3E%20%3D%20Vec%3A%3Anew()%3B%0A%7D&amp;edition=2018">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.with_capacity" class="method has-srclink"><div class="rightside"><a class="srclink" href="../../src/alloc/vec/mod.rs.html#465-467" title="goto source code">[src]</a></div><a href="#method.with_capacity" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.with_capacity" class="fnname">with_capacity</a>(capacity: usize) -&gt; Self</h4></div></summary><div class="docblock" xpath="/html[1]/body[1]/section[1]/details[2]/div[1]/details[2]/div[1]" istranslationnode="true" main_mp="YW1sbmc/PnNlYjo7UmBnOUQ9MFZ4enZ0fC8qK2N8YH1/QkFRRUZNUVk="><p class="translate-text">构造一个具有指定容量的新的空 Vec<t>。</t></p><p>Constructs a new, empty <code>Vec&lt;T&gt;</code> with the specified capacity.</p>
<p class="translate-text">该Vector将能够准确地保存容量元素而无需重新分配。 如果容量为 0，则Vector不会分配。</p><p>The vector will be able to hold exactly <code>capacity</code> elements without
reallocating. If <code>capacity</code> is 0, the vector will not allocate.</p>
<p class="translate-text">需要注意的是，尽管返回的Vector具有指定的容量，但Vector的长度为零。 有关长度和容量之间差异的说明，请参阅容量和重新分配。</p><p>It is important to note that although the returned vector has the
<em>capacity</em> specified, the vector will have a zero <em>length</em>. For an
explanation of the difference between length and capacity, see
<em><a href="#capacity-and-reallocation">Capacity and reallocation</a></em>.</p>
<h1 id="panics" class="section-header"><a href="#panics">Panics</a></h1>
<p class="translate-text">如果新容量超过 isize::MAX 字节，则会出现panic。</p><p>Panics if the new capacity exceeds <code>isize::MAX</code> bytes.</p>
<h1 id="examples-2" class="section-header"><a href="#examples-2">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">vec</span> <span class="op">=</span> <span class="ident">Vec::with_capacity</span>(<span class="number">10</span>);

<span class="comment">// The vector contains no items, even though it has capacity for more</span>
<span class="macro">assert_eq!</span>(<span class="ident">vec</span>.<span class="ident">len</span>(), <span class="number">0</span>);
<span class="macro">assert_eq!</span>(<span class="ident">vec</span>.<span class="ident">capacity</span>(), <span class="number">10</span>);

<span class="comment">// These are all done without reallocating...</span>
<span class="kw">for</span> <span class="ident">i</span> <span class="kw">in</span> <span class="number">0</span>..<span class="number">10</span> {
    <span class="ident">vec</span>.<span class="ident">push</span>(<span class="ident">i</span>);
}
<span class="macro">assert_eq!</span>(<span class="ident">vec</span>.<span class="ident">len</span>(), <span class="number">10</span>);
<span class="macro">assert_eq!</span>(<span class="ident">vec</span>.<span class="ident">capacity</span>(), <span class="number">10</span>);

<span class="comment">// ...but this may make the vector reallocate</span>
<span class="ident">vec</span>.<span class="ident">push</span>(<span class="number">11</span>);
<span class="macro">assert_eq!</span>(<span class="ident">vec</span>.<span class="ident">len</span>(), <span class="number">11</span>);
<span class="macro">assert!</span>(<span class="ident">vec</span>.<span class="ident">capacity</span>() <span class="op">&gt;</span><span class="op">=</span> <span class="number">11</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Aextern%20crate%20r%23alloc%3B%0Afn%20main()%20%7B%0Alet%20mut%20vec%20%3D%20Vec%3A%3Awith_capacity(10)%3B%0A%0A%2F%2F%20The%20vector%20contains%20no%20items%2C%20even%20though%20it%20has%20capacity%20for%20more%0Aassert_eq!(vec.len()%2C%200)%3B%0Aassert_eq!(vec.capacity()%2C%2010)%3B%0A%0A%2F%2F%20These%20are%20all%20done%20without%20reallocating...%0Afor%20i%20in%200..10%20%7B%0A%20%20%20%20vec.push(i)%3B%0A%7D%0Aassert_eq!(vec.len()%2C%2010)%3B%0Aassert_eq!(vec.capacity()%2C%2010)%3B%0A%0A%2F%2F%20...but%20this%20may%20make%20the%20vector%20reallocate%0Avec.push(11)%3B%0Aassert_eq!(vec.len()%2C%2011)%3B%0Aassert!(vec.capacity()%20%3E%3D%2011)%3B%0A%7D&amp;edition=2018">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.from_raw_parts" class="method has-srclink"><div class="rightside"><a class="srclink" href="../../src/alloc/vec/mod.rs.html#533-535" title="goto source code">[src]</a></div><a href="#method.from_raw_parts" class="anchor"></a><h4 class="code-header">pub unsafe fn <a href="#method.from_raw_parts" class="fnname">from_raw_parts</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;ptr: *mut T, <br>&nbsp;&nbsp;&nbsp;&nbsp;length: usize, <br>&nbsp;&nbsp;&nbsp;&nbsp;capacity: usize<br>) -&gt; Self</h4></div></summary><div class="docblock" xpath="/html[1]/body[1]/section[1]/details[2]/div[1]/details[3]/div[1]" istranslationnode="true" main_mp="YW1sbmc/PnNlYjo7UmBnOUQ9MFZ4enZ0fC8qK3Jne3h/U0FWe1VFV1RS"><p class="translate-text">直接从另一个Vector的原始分量创建一个 Vec<t>。</t></p><p>Creates a <code>Vec&lt;T&gt;</code> directly from the raw components of another vector.</p>
<h1 id="safety" class="section-header"><a href="#safety">Safety</a></h1>
<p class="translate-text">这是非常不安全的，因为有很多不变量没有被检查：</p><p>This is highly unsafe, due to the number of invariants that aren’t
checked:</p>
<ul>
<li class="translate-text">ptr 需要事先通过 String/Vec<t> 分配（至少，如果不是，它很可能是不正确的）。</t></li><li><code>ptr</code> needs to have been previously allocated via <a href="../string/struct.String.html"><code>String</code></a>/<code>Vec&lt;T&gt;</code>
(at least, it’s highly likely to be incorrect if it wasn’t).</li>
<li class="translate-text">T 需要与 ptr 分配的大小和对齐方式相同。 （T 具有不太严格的对齐方式是不够的，对齐方式确实需要相等才能满足必须使用相同布局分配和释放内存的释放要求。）</li><li><code>T</code> needs to have the same size and alignment as what <code>ptr</code> was allocated with.
(<code>T</code> having a less strict alignment is not sufficient, the alignment really
needs to be equal to satisfy the <a href="../alloc/trait.GlobalAlloc.html#tymethod.dealloc"><code>dealloc</code></a> requirement that memory must be
allocated and deallocated with the same layout.)</li>
<li class="translate-text">长度需要小于或等于容量。</li><li><code>length</code> needs to be less than or equal to <code>capacity</code>.</li>
<li class="translate-text">容量需要是分配指针的容量。</li><li><code>capacity</code> needs to be the capacity that the pointer was allocated with.</li>
</ul>
<p class="translate-text">违反这些可能会导致诸如破坏分配器的内部数据结构之类的问题。 例如，从指向长度为 size_t 的 C char 数组的指针构建 Vec<u8> 是不安全的。 从 Vec<u16> 及其长度构建一个也不安全，因为分配器关心对齐方式，而这两种类型有不同的对齐方式。 缓冲区以对齐 2 分配（对于 u16），但在将其转换为 Vec<u8> 后，它将以对齐 1 释放。</u8></u16></u8></p><p>Violating these may cause problems like corrupting the allocator’s
internal data structures. For example it is <strong>not</strong> safe
to build a <code>Vec&lt;u8&gt;</code> from a pointer to a C <code>char</code> array with length <code>size_t</code>.
It’s also not safe to build one from a <code>Vec&lt;u16&gt;</code> and its length, because
the allocator cares about the alignment, and these two types have different
alignments. The buffer was allocated with alignment 2 (for <code>u16</code>), but after
turning it into a <code>Vec&lt;u8&gt;</code> it’ll be deallocated with alignment 1.</p>
<p class="translate-text">ptr 的所有权被有效地转移到 Vec<t> ，然后它可以随意释放、重新分配或更改指针指向的内存内容。 确保调用此函数后没有其他任何东西使用该指针。</t></p><p>The ownership of <code>ptr</code> is effectively transferred to the
<code>Vec&lt;T&gt;</code> which may then deallocate, reallocate or change the
contents of memory pointed to by the pointer at will. Ensure
that nothing else uses the pointer after calling this
function.</p>
<h1 id="examples-3" class="section-header"><a href="#examples-3">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">std::ptr</span>;
<span class="kw">use</span> <span class="ident">std::mem</span>;

<span class="kw">let</span> <span class="ident">v</span> <span class="op">=</span> <span class="macro">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];

<span class="comment">// Prevent running `v`&#39;s destructor so we are in complete control</span>
<span class="comment">// of the allocation.</span>
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">v</span> <span class="op">=</span> <span class="ident">mem::ManuallyDrop::new</span>(<span class="ident">v</span>);

<span class="comment">// Pull out the various important pieces of information about `v`</span>
<span class="kw">let</span> <span class="ident">p</span> <span class="op">=</span> <span class="ident">v</span>.<span class="ident">as_mut_ptr</span>();
<span class="kw">let</span> <span class="ident">len</span> <span class="op">=</span> <span class="ident">v</span>.<span class="ident">len</span>();
<span class="kw">let</span> <span class="ident">cap</span> <span class="op">=</span> <span class="ident">v</span>.<span class="ident">capacity</span>();

<span class="kw">unsafe</span> {
    <span class="comment">// Overwrite memory with 4, 5, 6</span>
    <span class="kw">for</span> <span class="ident">i</span> <span class="kw">in</span> <span class="number">0</span>..<span class="ident">len</span> <span class="kw">as</span> <span class="ident">isize</span> {
        <span class="ident">ptr::write</span>(<span class="ident">p</span>.<span class="ident">offset</span>(<span class="ident">i</span>), <span class="number">4</span> <span class="op">+</span> <span class="ident">i</span>);
    }

    <span class="comment">// Put everything back together into a Vec</span>
    <span class="kw">let</span> <span class="ident">rebuilt</span> <span class="op">=</span> <span class="ident">Vec::from_raw_parts</span>(<span class="ident">p</span>, <span class="ident">len</span>, <span class="ident">cap</span>);
    <span class="macro">assert_eq!</span>(<span class="ident">rebuilt</span>, [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]);
}</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Aextern%20crate%20r%23alloc%3B%0Afn%20main()%20%7B%0Ause%20std%3A%3Aptr%3B%0Ause%20std%3A%3Amem%3B%0A%0Alet%20v%20%3D%20vec!%5B1%2C%202%2C%203%5D%3B%0A%0A%2F%2F%20Prevent%20running%20%60v%60's%20destructor%20so%20we%20are%20in%20complete%20control%0A%2F%2F%20of%20the%20allocation.%0Alet%20mut%20v%20%3D%20mem%3A%3AManuallyDrop%3A%3Anew(v)%3B%0A%0A%2F%2F%20Pull%20out%20the%20various%20important%20pieces%20of%20information%20about%20%60v%60%0Alet%20p%20%3D%20v.as_mut_ptr()%3B%0Alet%20len%20%3D%20v.len()%3B%0Alet%20cap%20%3D%20v.capacity()%3B%0A%0Aunsafe%20%7B%0A%20%20%20%20%2F%2F%20Overwrite%20memory%20with%204%2C%205%2C%206%0A%20%20%20%20for%20i%20in%200..len%20as%20isize%20%7B%0A%20%20%20%20%20%20%20%20ptr%3A%3Awrite(p.offset(i)%2C%204%20%2B%20i)%3B%0A%20%20%20%20%7D%0A%0A%20%20%20%20%2F%2F%20Put%20everything%20back%20together%20into%20a%20Vec%0A%20%20%20%20let%20rebuilt%20%3D%20Vec%3A%3Afrom_raw_parts(p%2C%20len%2C%20cap)%3B%0A%20%20%20%20assert_eq!(rebuilt%2C%20%5B4%2C%205%2C%206%5D)%3B%0A%7D%0A%7D&amp;edition=2018">Run</a></div>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open=""><summary><div id="impl-1" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../../src/alloc/vec/mod.rs.html#538-2104" title="goto source code">[src]</a></div><a href="#impl-1" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, A:&nbsp;<a class="trait" href="../alloc/trait.Allocator.html" title="trait alloc::alloc::Allocator">Allocator</a>&gt; <a class="struct" href="struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;T, A&gt;</h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.new_in" class="method has-srclink"><div class="rightside"><a class="srclink" href="../../src/alloc/vec/mod.rs.html#555-557" title="goto source code">[src]</a></div><a href="#method.new_in" class="anchor"></a><h4 class="code-header">pub const fn <a href="#method.new_in" class="fnname">new_in</a>(alloc: A) -&gt; Self</h4></div><div class="item-info"><div class="stab unstable"><span class="emoji">🔬</span> This is a nightly-only experimental API. (<code>allocator_api</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/32838">#32838</a>)</div></div></summary><div class="docblock" xpath="/html[1]/body[1]/section[1]/details[3]/div[1]/details[1]/div[1]" istranslationnode="true" main_mp="YW1sbmc/PnNlYjo7UmBnOUQ9MFAqLy57dWZPeHo="><p class="translate-text">构造一个新的空 Vec<t, a="">。</t,></p><p>Constructs a new, empty <code>Vec&lt;T, A&gt;</code>.</p>
<p class="translate-text">在元素被推到它上面之前，Vector不会分配。</p><p>The vector will not allocate until elements are pushed onto it.</p>
<h1 id="examples-4" class="section-header"><a href="#examples-4">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attribute">#![<span class="ident">feature</span>(<span class="ident">allocator_api</span>)]</span>

<span class="kw">use</span> <span class="ident">std::alloc::System</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">vec</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">i32</span>, <span class="kw">_</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">Vec::new_in</span>(<span class="ident">System</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(allocator_api)%5D%0A%0Aextern%20crate%20r%23alloc%3B%0Afn%20main()%20%7B%0Ause%20std%3A%3Aalloc%3A%3ASystem%3B%0A%0A%23%5Ballow(unused_mut)%5D%0Alet%20mut%20vec%3A%20Vec%3Ci32%2C%20_%3E%20%3D%20Vec%3A%3Anew_in(System)%3B%0A%7D&amp;version=nightly&amp;edition=2018">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.with_capacity_in" class="method has-srclink"><div class="rightside"><a class="srclink" href="../../src/alloc/vec/mod.rs.html#604-606" title="goto source code">[src]</a></div><a href="#method.with_capacity_in" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.with_capacity_in" class="fnname">with_capacity_in</a>(capacity: usize, alloc: A) -&gt; Self</h4></div><div class="item-info"><div class="stab unstable"><span class="emoji">🔬</span> This is a nightly-only experimental API. (<code>allocator_api</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/32838">#32838</a>)</div></div></summary><div class="docblock" xpath="/html[1]/body[1]/section[1]/details[3]/div[1]/details[2]/div[1]" istranslationnode="true" main_mp="YW1sbmc/PnNlYjo7UmBnOUQ9MFAqLy5ieWV4Tnd0ZHRDSFRYe0xK"><p class="translate-text">使用提供的分配器构造一个具有指定容量的新的空 Vec<t, a="">。</t,></p><p>Constructs a new, empty <code>Vec&lt;T, A&gt;</code> with the specified capacity with the provided
allocator.</p>
<p class="translate-text">该Vector将能够准确地保存容量元素而无需重新分配。 如果容量为 0，则Vector不会分配。</p><p>The vector will be able to hold exactly <code>capacity</code> elements without
reallocating. If <code>capacity</code> is 0, the vector will not allocate.</p>
<p class="translate-text">需要注意的是，尽管返回的Vector具有指定的容量，但Vector的长度为零。 有关长度和容量之间差异的说明，请参阅容量和重新分配。</p><p>It is important to note that although the returned vector has the
<em>capacity</em> specified, the vector will have a zero <em>length</em>. For an
explanation of the difference between length and capacity, see
<em><a href="#capacity-and-reallocation">Capacity and reallocation</a></em>.</p>
<h1 id="panics-1" class="section-header"><a href="#panics-1">Panics</a></h1>
<p class="translate-text">如果新容量超过 isize::MAX 字节，则会出现panic。</p><p>Panics if the new capacity exceeds <code>isize::MAX</code> bytes.</p>
<h1 id="examples-5" class="section-header"><a href="#examples-5">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attribute">#![<span class="ident">feature</span>(<span class="ident">allocator_api</span>)]</span>

<span class="kw">use</span> <span class="ident">std::alloc::System</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">vec</span> <span class="op">=</span> <span class="ident">Vec::with_capacity_in</span>(<span class="number">10</span>, <span class="ident">System</span>);

<span class="comment">// The vector contains no items, even though it has capacity for more</span>
<span class="macro">assert_eq!</span>(<span class="ident">vec</span>.<span class="ident">len</span>(), <span class="number">0</span>);
<span class="macro">assert_eq!</span>(<span class="ident">vec</span>.<span class="ident">capacity</span>(), <span class="number">10</span>);

<span class="comment">// These are all done without reallocating...</span>
<span class="kw">for</span> <span class="ident">i</span> <span class="kw">in</span> <span class="number">0</span>..<span class="number">10</span> {
    <span class="ident">vec</span>.<span class="ident">push</span>(<span class="ident">i</span>);
}
<span class="macro">assert_eq!</span>(<span class="ident">vec</span>.<span class="ident">len</span>(), <span class="number">10</span>);
<span class="macro">assert_eq!</span>(<span class="ident">vec</span>.<span class="ident">capacity</span>(), <span class="number">10</span>);

<span class="comment">// ...but this may make the vector reallocate</span>
<span class="ident">vec</span>.<span class="ident">push</span>(<span class="number">11</span>);
<span class="macro">assert_eq!</span>(<span class="ident">vec</span>.<span class="ident">len</span>(), <span class="number">11</span>);
<span class="macro">assert!</span>(<span class="ident">vec</span>.<span class="ident">capacity</span>() <span class="op">&gt;</span><span class="op">=</span> <span class="number">11</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(allocator_api)%5D%0A%0Aextern%20crate%20r%23alloc%3B%0Afn%20main()%20%7B%0Ause%20std%3A%3Aalloc%3A%3ASystem%3B%0A%0Alet%20mut%20vec%20%3D%20Vec%3A%3Awith_capacity_in(10%2C%20System)%3B%0A%0A%2F%2F%20The%20vector%20contains%20no%20items%2C%20even%20though%20it%20has%20capacity%20for%20more%0Aassert_eq!(vec.len()%2C%200)%3B%0Aassert_eq!(vec.capacity()%2C%2010)%3B%0A%0A%2F%2F%20These%20are%20all%20done%20without%20reallocating...%0Afor%20i%20in%200..10%20%7B%0A%20%20%20%20vec.push(i)%3B%0A%7D%0Aassert_eq!(vec.len()%2C%2010)%3B%0Aassert_eq!(vec.capacity()%2C%2010)%3B%0A%0A%2F%2F%20...but%20this%20may%20make%20the%20vector%20reallocate%0Avec.push(11)%3B%0Aassert_eq!(vec.len()%2C%2011)%3B%0Aassert!(vec.capacity()%20%3E%3D%2011)%3B%0A%7D&amp;version=nightly&amp;edition=2018">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.from_raw_parts_in" class="method has-srclink"><div class="rightside"><a class="srclink" href="../../src/alloc/vec/mod.rs.html#680-682" title="goto source code">[src]</a></div><a href="#method.from_raw_parts_in" class="anchor"></a><h4 class="code-header">pub unsafe fn <a href="#method.from_raw_parts_in" class="fnname">from_raw_parts_in</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;ptr: *mut T, <br>&nbsp;&nbsp;&nbsp;&nbsp;length: usize, <br>&nbsp;&nbsp;&nbsp;&nbsp;capacity: usize, <br>&nbsp;&nbsp;&nbsp;&nbsp;alloc: A<br>) -&gt; Self</h4></div><div class="item-info"><div class="stab unstable"><span class="emoji">🔬</span> This is a nightly-only experimental API. (<code>allocator_api</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/32838">#32838</a>)</div></div></summary><div class="docblock" xpath="/html[1]/body[1]/section[1]/details[3]/div[1]/details[3]/div[1]" istranslationnode="true" main_mp="YW1sbmc/PnNlYjo7UmBnOUQ9MFAqLy5zYn59TmZ0Y0pQQFJVV3pNSw=="><p class="translate-text">直接从另一个Vector的原始分量创建一个 Vec<t, a="">。</t,></p><p>Creates a <code>Vec&lt;T, A&gt;</code> directly from the raw components of another vector.</p>
<h1 id="safety-1" class="section-header"><a href="#safety-1">Safety</a></h1>
<p class="translate-text">这是非常不安全的，因为有很多不变量没有被检查：</p><p>This is highly unsafe, due to the number of invariants that aren’t
checked:</p>
<ul>
<li class="translate-text">ptr 需要事先通过 String/Vec<t> 分配（至少，如果不是，它很可能是不正确的）。</t></li><li><code>ptr</code> needs to have been previously allocated via <a href="../string/struct.String.html"><code>String</code></a>/<code>Vec&lt;T&gt;</code>
(at least, it’s highly likely to be incorrect if it wasn’t).</li>
<li class="translate-text">T 需要与 ptr 分配的大小和对齐方式相同。 （T 具有不太严格的对齐方式是不够的，对齐方式确实需要相等才能满足必须使用相同布局分配和释放内存的释放要求。）</li><li><code>T</code> needs to have the same size and alignment as what <code>ptr</code> was allocated with.
(<code>T</code> having a less strict alignment is not sufficient, the alignment really
needs to be equal to satisfy the <a href="../alloc/trait.GlobalAlloc.html#tymethod.dealloc"><code>dealloc</code></a> requirement that memory must be
allocated and deallocated with the same layout.)</li>
<li class="translate-text">长度需要小于或等于容量。</li><li><code>length</code> needs to be less than or equal to <code>capacity</code>.</li>
<li class="translate-text">容量需要是分配指针的容量。</li><li><code>capacity</code> needs to be the capacity that the pointer was allocated with.</li>
</ul>
<p class="translate-text">违反这些可能会导致诸如破坏分配器的内部数据结构之类的问题。 例如，从指向长度为 size_t 的 C char 数组的指针构建 Vec<u8> 是不安全的。 从 Vec<u16> 及其长度构建一个也不安全，因为分配器关心对齐方式，而这两种类型有不同的对齐方式。 缓冲区以对齐 2 分配（对于 u16），但在将其转换为 Vec<u8> 后，它将以对齐 1 释放。</u8></u16></u8></p><p>Violating these may cause problems like corrupting the allocator’s
internal data structures. For example it is <strong>not</strong> safe
to build a <code>Vec&lt;u8&gt;</code> from a pointer to a C <code>char</code> array with length <code>size_t</code>.
It’s also not safe to build one from a <code>Vec&lt;u16&gt;</code> and its length, because
the allocator cares about the alignment, and these two types have different
alignments. The buffer was allocated with alignment 2 (for <code>u16</code>), but after
turning it into a <code>Vec&lt;u8&gt;</code> it’ll be deallocated with alignment 1.</p>
<p class="translate-text">ptr 的所有权被有效地转移到 Vec<t> ，然后它可以随意释放、重新分配或更改指针指向的内存内容。 确保调用此函数后没有其他任何东西使用该指针。</t></p><p>The ownership of <code>ptr</code> is effectively transferred to the
<code>Vec&lt;T&gt;</code> which may then deallocate, reallocate or change the
contents of memory pointed to by the pointer at will. Ensure
that nothing else uses the pointer after calling this
function.</p>
<h1 id="examples-6" class="section-header"><a href="#examples-6">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attribute">#![<span class="ident">feature</span>(<span class="ident">allocator_api</span>)]</span>

<span class="kw">use</span> <span class="ident">std::alloc::System</span>;

<span class="kw">use</span> <span class="ident">std::ptr</span>;
<span class="kw">use</span> <span class="ident">std::mem</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">v</span> <span class="op">=</span> <span class="ident">Vec::with_capacity_in</span>(<span class="number">3</span>, <span class="ident">System</span>);
<span class="ident">v</span>.<span class="ident">push</span>(<span class="number">1</span>);
<span class="ident">v</span>.<span class="ident">push</span>(<span class="number">2</span>);
<span class="ident">v</span>.<span class="ident">push</span>(<span class="number">3</span>);

<span class="comment">// Prevent running `v`&#39;s destructor so we are in complete control</span>
<span class="comment">// of the allocation.</span>
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">v</span> <span class="op">=</span> <span class="ident">mem::ManuallyDrop::new</span>(<span class="ident">v</span>);

<span class="comment">// Pull out the various important pieces of information about `v`</span>
<span class="kw">let</span> <span class="ident">p</span> <span class="op">=</span> <span class="ident">v</span>.<span class="ident">as_mut_ptr</span>();
<span class="kw">let</span> <span class="ident">len</span> <span class="op">=</span> <span class="ident">v</span>.<span class="ident">len</span>();
<span class="kw">let</span> <span class="ident">cap</span> <span class="op">=</span> <span class="ident">v</span>.<span class="ident">capacity</span>();
<span class="kw">let</span> <span class="ident">alloc</span> <span class="op">=</span> <span class="ident">v</span>.<span class="ident">allocator</span>();

<span class="kw">unsafe</span> {
    <span class="comment">// Overwrite memory with 4, 5, 6</span>
    <span class="kw">for</span> <span class="ident">i</span> <span class="kw">in</span> <span class="number">0</span>..<span class="ident">len</span> <span class="kw">as</span> <span class="ident">isize</span> {
        <span class="ident">ptr::write</span>(<span class="ident">p</span>.<span class="ident">offset</span>(<span class="ident">i</span>), <span class="number">4</span> <span class="op">+</span> <span class="ident">i</span>);
    }

    <span class="comment">// Put everything back together into a Vec</span>
    <span class="kw">let</span> <span class="ident">rebuilt</span> <span class="op">=</span> <span class="ident">Vec::from_raw_parts_in</span>(<span class="ident">p</span>, <span class="ident">len</span>, <span class="ident">cap</span>, <span class="ident">alloc</span>.<span class="ident">clone</span>());
    <span class="macro">assert_eq!</span>(<span class="ident">rebuilt</span>, [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]);
}</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(allocator_api)%5D%0A%0Aextern%20crate%20r%23alloc%3B%0Afn%20main()%20%7B%0Ause%20std%3A%3Aalloc%3A%3ASystem%3B%0A%0Ause%20std%3A%3Aptr%3B%0Ause%20std%3A%3Amem%3B%0A%0Alet%20mut%20v%20%3D%20Vec%3A%3Awith_capacity_in(3%2C%20System)%3B%0Av.push(1)%3B%0Av.push(2)%3B%0Av.push(3)%3B%0A%0A%2F%2F%20Prevent%20running%20%60v%60's%20destructor%20so%20we%20are%20in%20complete%20control%0A%2F%2F%20of%20the%20allocation.%0Alet%20mut%20v%20%3D%20mem%3A%3AManuallyDrop%3A%3Anew(v)%3B%0A%0A%2F%2F%20Pull%20out%20the%20various%20important%20pieces%20of%20information%20about%20%60v%60%0Alet%20p%20%3D%20v.as_mut_ptr()%3B%0Alet%20len%20%3D%20v.len()%3B%0Alet%20cap%20%3D%20v.capacity()%3B%0Alet%20alloc%20%3D%20v.allocator()%3B%0A%0Aunsafe%20%7B%0A%20%20%20%20%2F%2F%20Overwrite%20memory%20with%204%2C%205%2C%206%0A%20%20%20%20for%20i%20in%200..len%20as%20isize%20%7B%0A%20%20%20%20%20%20%20%20ptr%3A%3Awrite(p.offset(i)%2C%204%20%2B%20i)%3B%0A%20%20%20%20%7D%0A%0A%20%20%20%20%2F%2F%20Put%20everything%20back%20together%20into%20a%20Vec%0A%20%20%20%20let%20rebuilt%20%3D%20Vec%3A%3Afrom_raw_parts_in(p%2C%20len%2C%20cap%2C%20alloc.clone())%3B%0A%20%20%20%20assert_eq!(rebuilt%2C%20%5B4%2C%205%2C%206%5D)%3B%0A%7D%0A%7D&amp;version=nightly&amp;edition=2018">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.into_raw_parts" class="method has-srclink"><div class="rightside"><a class="srclink" href="../../src/alloc/vec/mod.rs.html#717-720" title="goto source code">[src]</a></div><a href="#method.into_raw_parts" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.into_raw_parts" class="fnname">into_raw_parts</a>(self) -&gt; (*mut T, usize, usize)</h4></div><div class="item-info"><div class="stab unstable"><details><summary><span class="emoji">🔬</span> This is a nightly-only experimental API. (<code>vec_into_raw_parts</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/65816">#65816</a>)</summary><p>new API</p>
</details></div></div></summary><div class="docblock" xpath="/html[1]/body[1]/section[1]/details[3]/div[1]/details[4]/div[1]" istranslationnode="true" main_mp="YW1sbmc/PnNlYjo7UmBnOUQ9MFAqLy58fmV/TmZ0Y0pQQFJVVw=="><p class="translate-text">将 Vec<t> 分解为其原始组件。</t></p><p>Decomposes a <code>Vec&lt;T&gt;</code> into its raw components.</p>
<p class="translate-text">返回指向基础数据的原始指针、Vector的长度（以元素为单位）和数据的分配容量（以元素为单位）。 这些是与 from_raw_parts 的参数顺序相同的参数。</p><p>Returns the raw pointer to the underlying data, the length of
the vector (in elements), and the allocated capacity of the
data (in elements). These are the same arguments in the same
order as the arguments to <a href="struct.Vec.html#method.from_raw_parts"><code>from_raw_parts</code></a>.</p>
<p class="translate-text">调用此函数后，调用者负责之前由 Vec 管理的内存。 这样做的唯一方法是使用 from_raw_parts 函数将原始指针、长度和容量转换回 Vec，从而允许析构函数执行清理。</p><p>After calling this function, the caller is responsible for the
memory previously managed by the <code>Vec</code>. The only way to do
this is to convert the raw pointer, length, and capacity back
into a <code>Vec</code> with the <a href="struct.Vec.html#method.from_raw_parts"><code>from_raw_parts</code></a> function, allowing
the destructor to perform the cleanup.</p>
<h1 id="examples-7" class="section-header"><a href="#examples-7">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attribute">#![<span class="ident">feature</span>(<span class="ident">vec_into_raw_parts</span>)]</span>
<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">i32</span><span class="op">&gt;</span> <span class="op">=</span> <span class="macro">vec!</span>[<span class="op">-</span><span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>];

<span class="kw">let</span> (<span class="ident">ptr</span>, <span class="ident">len</span>, <span class="ident">cap</span>) <span class="op">=</span> <span class="ident">v</span>.<span class="ident">into_raw_parts</span>();

<span class="kw">let</span> <span class="ident">rebuilt</span> <span class="op">=</span> <span class="kw">unsafe</span> {
    <span class="comment">// We can now make changes to the components, such as</span>
    <span class="comment">// transmuting the raw pointer to a compatible type.</span>
    <span class="kw">let</span> <span class="ident">ptr</span> <span class="op">=</span> <span class="ident">ptr</span> <span class="kw">as</span> <span class="kw-2">*</span><span class="kw-2">mut</span> <span class="ident">u32</span>;

    <span class="ident">Vec::from_raw_parts</span>(<span class="ident">ptr</span>, <span class="ident">len</span>, <span class="ident">cap</span>)
};
<span class="macro">assert_eq!</span>(<span class="ident">rebuilt</span>, [<span class="number">4294967295</span>, <span class="number">0</span>, <span class="number">1</span>]);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(vec_into_raw_parts)%5D%0Afn%20main()%20%7B%0Alet%20v%3A%20Vec%3Ci32%3E%20%3D%20vec!%5B-1%2C%200%2C%201%5D%3B%0A%0Alet%20(ptr%2C%20len%2C%20cap)%20%3D%20v.into_raw_parts()%3B%0A%0Alet%20rebuilt%20%3D%20unsafe%20%7B%0A%20%20%20%20%2F%2F%20We%20can%20now%20make%20changes%20to%20the%20components%2C%20such%20as%0A%20%20%20%20%2F%2F%20transmuting%20the%20raw%20pointer%20to%20a%20compatible%20type.%0A%20%20%20%20let%20ptr%20%3D%20ptr%20as%20*mut%20u32%3B%0A%0A%20%20%20%20Vec%3A%3Afrom_raw_parts(ptr%2C%20len%2C%20cap)%0A%7D%3B%0Aassert_eq!(rebuilt%2C%20%5B4294967295%2C%200%2C%201%5D)%3B%0A%7D&amp;version=nightly&amp;edition=2018">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.into_raw_parts_with_alloc" class="method has-srclink"><div class="rightside"><a class="srclink" href="../../src/alloc/vec/mod.rs.html#761-768" title="goto source code">[src]</a></div><a href="#method.into_raw_parts_with_alloc" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.into_raw_parts_with_alloc" class="fnname">into_raw_parts_with_alloc</a>(self) -&gt; (*mut T, usize, usize, A)</h4></div><div class="item-info"><div class="stab unstable"><span class="emoji">🔬</span> This is a nightly-only experimental API. (<code>allocator_api</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/32838">#32838</a>)</div></div></summary><div class="docblock" xpath="/html[1]/body[1]/section[1]/details[3]/div[1]/details[5]/div[1]" istranslationnode="true" main_mp="YW1sbmc/PnNlYjo7UmBnOUQ9MFAqLy58fmV/TmZ0Y0pQQFJVV3pTTFRJf0BISUtG"><p class="translate-text">将 Vec<t> 分解为其原始组件。</t></p><p>Decomposes a <code>Vec&lt;T&gt;</code> into its raw components.</p>
<p class="translate-text">返回指向基础数据的原始指针、Vector的长度（以元素为单位）、数据的分配容量（以元素为单位）和分配器。 这些是与 from_raw_parts_in 的参数顺序相同的参数。</p><p>Returns the raw pointer to the underlying data, the length of the vector (in elements),
the allocated capacity of the data (in elements), and the allocator. These are the same
arguments in the same order as the arguments to <a href="struct.Vec.html#method.from_raw_parts_in"><code>from_raw_parts_in</code></a>.</p>
<p class="translate-text">调用此函数后，调用者负责之前由 Vec 管理的内存。 这样做的唯一方法是使用 from_raw_parts_in 函数将原始指针、长度和容量转换回 Vec，从而允许析构函数执行清理。</p><p>After calling this function, the caller is responsible for the
memory previously managed by the <code>Vec</code>. The only way to do
this is to convert the raw pointer, length, and capacity back
into a <code>Vec</code> with the <a href="struct.Vec.html#method.from_raw_parts_in"><code>from_raw_parts_in</code></a> function, allowing
the destructor to perform the cleanup.</p>
<h1 id="examples-8" class="section-header"><a href="#examples-8">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attribute">#![<span class="ident">feature</span>(<span class="ident">allocator_api</span>, <span class="ident">vec_into_raw_parts</span>)]</span>

<span class="kw">use</span> <span class="ident">std::alloc::System</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">i32</span>, <span class="ident">System</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">Vec::new_in</span>(<span class="ident">System</span>);
<span class="ident">v</span>.<span class="ident">push</span>(<span class="op">-</span><span class="number">1</span>);
<span class="ident">v</span>.<span class="ident">push</span>(<span class="number">0</span>);
<span class="ident">v</span>.<span class="ident">push</span>(<span class="number">1</span>);

<span class="kw">let</span> (<span class="ident">ptr</span>, <span class="ident">len</span>, <span class="ident">cap</span>, <span class="ident">alloc</span>) <span class="op">=</span> <span class="ident">v</span>.<span class="ident">into_raw_parts_with_alloc</span>();

<span class="kw">let</span> <span class="ident">rebuilt</span> <span class="op">=</span> <span class="kw">unsafe</span> {
    <span class="comment">// We can now make changes to the components, such as</span>
    <span class="comment">// transmuting the raw pointer to a compatible type.</span>
    <span class="kw">let</span> <span class="ident">ptr</span> <span class="op">=</span> <span class="ident">ptr</span> <span class="kw">as</span> <span class="kw-2">*</span><span class="kw-2">mut</span> <span class="ident">u32</span>;

    <span class="ident">Vec::from_raw_parts_in</span>(<span class="ident">ptr</span>, <span class="ident">len</span>, <span class="ident">cap</span>, <span class="ident">alloc</span>)
};
<span class="macro">assert_eq!</span>(<span class="ident">rebuilt</span>, [<span class="number">4294967295</span>, <span class="number">0</span>, <span class="number">1</span>]);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(allocator_api%2C%20vec_into_raw_parts)%5D%0A%0Aextern%20crate%20r%23alloc%3B%0Afn%20main()%20%7B%0Ause%20std%3A%3Aalloc%3A%3ASystem%3B%0A%0Alet%20mut%20v%3A%20Vec%3Ci32%2C%20System%3E%20%3D%20Vec%3A%3Anew_in(System)%3B%0Av.push(-1)%3B%0Av.push(0)%3B%0Av.push(1)%3B%0A%0Alet%20(ptr%2C%20len%2C%20cap%2C%20alloc)%20%3D%20v.into_raw_parts_with_alloc()%3B%0A%0Alet%20rebuilt%20%3D%20unsafe%20%7B%0A%20%20%20%20%2F%2F%20We%20can%20now%20make%20changes%20to%20the%20components%2C%20such%20as%0A%20%20%20%20%2F%2F%20transmuting%20the%20raw%20pointer%20to%20a%20compatible%20type.%0A%20%20%20%20let%20ptr%20%3D%20ptr%20as%20*mut%20u32%3B%0A%0A%20%20%20%20Vec%3A%3Afrom_raw_parts_in(ptr%2C%20len%2C%20cap%2C%20alloc)%0A%7D%3B%0Aassert_eq!(rebuilt%2C%20%5B4294967295%2C%200%2C%201%5D)%3B%0A%7D&amp;version=nightly&amp;edition=2018">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.capacity" class="method has-srclink"><div class="rightside"><a class="srclink" href="../../src/alloc/vec/mod.rs.html#781-783" title="goto source code">[src]</a></div><a href="#method.capacity" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.capacity" class="fnname">capacity</a>(&amp;self) -&gt; usize</h4></div></summary><div class="docblock" xpath="/html[1]/body[1]/section[1]/details[3]/div[1]/details[6]/div[1]" istranslationnode="true" main_mp="YW1sbmc/PnNlYjo7UmBnOUQ9MFAqLy52cWFxcn1hbQ=="><p class="translate-text">返回Vector在不重新分配的情况下可以容纳的元素数。</p><p>Returns the number of elements the vector can hold without
reallocating.</p>
<h1 id="examples-9" class="section-header"><a href="#examples-9">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">vec</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">i32</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">Vec::with_capacity</span>(<span class="number">10</span>);
<span class="macro">assert_eq!</span>(<span class="ident">vec</span>.<span class="ident">capacity</span>(), <span class="number">10</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20vec%3A%20Vec%3Ci32%3E%20%3D%20Vec%3A%3Awith_capacity(10)%3B%0Aassert_eq!(vec.capacity()%2C%2010)%3B%0A%7D&amp;edition=2018">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.reserve" class="method has-srclink"><div class="rightside"><a class="srclink" href="../../src/alloc/vec/mod.rs.html#804-806" title="goto source code">[src]</a></div><a href="#method.reserve" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.reserve" class="fnname">reserve</a>(&amp;mut self, additional: usize)</h4></div></summary><div class="docblock" xpath="/html[1]/body[1]/section[1]/details[3]/div[1]/details[7]/div[1]" istranslationnode="true" main_mp="YW1sbmc/PnNlYjo7UmBnOUQ9MFAqLy5ndWJ1Y2Jw"><p class="translate-text">为要插入给定 Vec<t> 的至少更多元素保留容量。 集合可以保留更多空间以避免频繁的重新分配。 调用reserve后容量会大于等于self.len()+additional。 如果容量已经足够，则什么也不做。</t></p><p>Reserves capacity for at least <code>additional</code> more elements to be inserted
in the given <code>Vec&lt;T&gt;</code>. The collection may reserve more space to avoid
frequent reallocations. After calling <code>reserve</code>, capacity will be
greater than or equal to <code>self.len() + additional</code>. Does nothing if
capacity is already sufficient.</p>
<h1 id="panics-2" class="section-header"><a href="#panics-2">Panics</a></h1>
<p class="translate-text">如果新容量超过 isize::MAX 字节，则会出现panic。</p><p>Panics if the new capacity exceeds <code>isize::MAX</code> bytes.</p>
<h1 id="examples-10" class="section-header"><a href="#examples-10">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">vec</span> <span class="op">=</span> <span class="macro">vec!</span>[<span class="number">1</span>];
<span class="ident">vec</span>.<span class="ident">reserve</span>(<span class="number">10</span>);
<span class="macro">assert!</span>(<span class="ident">vec</span>.<span class="ident">capacity</span>() <span class="op">&gt;</span><span class="op">=</span> <span class="number">11</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20mut%20vec%20%3D%20vec!%5B1%5D%3B%0Avec.reserve(10)%3B%0Aassert!(vec.capacity()%20%3E%3D%2011)%3B%0A%7D&amp;edition=2018">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.reserve_exact" class="method has-srclink"><div class="rightside"><a class="srclink" href="../../src/alloc/vec/mod.rs.html#832-834" title="goto source code">[src]</a></div><a href="#method.reserve_exact" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.reserve_exact" class="fnname">reserve_exact</a>(&amp;mut self, additional: usize)</h4></div></summary><div class="docblock" xpath="/html[1]/body[1]/section[1]/details[3]/div[1]/details[8]/div[1]" istranslationnode="true" main_mp="YW1sbmc/PnNlYjo7UmBnOUQ9MFAqLy5ndWJ1Y2JwS3BYQENV"><p class="translate-text">为要插入给定 Vec<t> 的更多元素保留最小容量。 调用reserve_exact后，容量会大于等于self.len()+additional。 如果容量已经足够，则什么也不做。</t></p><p>Reserves the minimum capacity for exactly <code>additional</code> more elements to
be inserted in the given <code>Vec&lt;T&gt;</code>. After calling <code>reserve_exact</code>,
capacity will be greater than or equal to <code>self.len() + additional</code>.
Does nothing if the capacity is already sufficient.</p>
<p class="translate-text">请注意，分配器可能会为集合提供比其请求更多的空间。 因此，不能依赖容量精确到最小。 如果预计将来插入，则首选保留。</p><p>Note that the allocator may give the collection more space than it
requests. Therefore, capacity can not be relied upon to be precisely
minimal. Prefer <a href="struct.Vec.html#method.reserve"><code>reserve</code></a> if future insertions are expected.</p>
<h1 id="panics-3" class="section-header"><a href="#panics-3">Panics</a></h1>
<p class="translate-text">如果新容量超出使用量，则会出现panic。</p><p>Panics if the new capacity overflows <code>usize</code>.</p>
<h1 id="examples-11" class="section-header"><a href="#examples-11">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">vec</span> <span class="op">=</span> <span class="macro">vec!</span>[<span class="number">1</span>];
<span class="ident">vec</span>.<span class="ident">reserve_exact</span>(<span class="number">10</span>);
<span class="macro">assert!</span>(<span class="ident">vec</span>.<span class="ident">capacity</span>() <span class="op">&gt;</span><span class="op">=</span> <span class="number">11</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20mut%20vec%20%3D%20vec!%5B1%5D%3B%0Avec.reserve_exact(10)%3B%0Aassert!(vec.capacity()%20%3E%3D%2011)%3B%0A%7D&amp;edition=2018">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.try_reserve" class="method has-srclink"><div class="rightside"><a class="srclink" href="../../src/alloc/vec/mod.rs.html#869-871" title="goto source code">[src]</a></div><a href="#method.try_reserve" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.try_reserve" class="fnname">try_reserve</a>(&amp;mut self, additional: usize) -&gt; <a class="enum" href="../../core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;(), <a class="struct" href="../collections/struct.TryReserveError.html" title="struct alloc::collections::TryReserveError">TryReserveError</a>&gt;</h4></div><div class="item-info"><div class="stab unstable"><details><summary><span class="emoji">🔬</span> This is a nightly-only experimental API. (<code>try_reserve</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/48043">#48043</a>)</summary><p>new API</p>
</details></div></div></summary><div class="docblock" xpath="/html[1]/body[1]/section[1]/details[3]/div[1]/details[9]/div[1]" istranslationnode="true" main_mp="YW1sbmc/PnNlYjo7UmBnOUQ9MFAqLy5hYmhPY3FmcWdWRA=="><p class="translate-text">尝试为要插入给定 Vec<t> 的至少更多元素保留容量。 集合可以保留更多空间以避免频繁的重新分配。 调用try_reserve后，容量会大于等于self.len()+additional。 如果容量已经足够，则什么也不做。</t></p><p>Tries to reserve capacity for at least <code>additional</code> more elements to be inserted
in the given <code>Vec&lt;T&gt;</code>. The collection may reserve more space to avoid
frequent reallocations. After calling <code>try_reserve</code>, capacity will be
greater than or equal to <code>self.len() + additional</code>. Does nothing if
capacity is already sufficient.</p>
<h1 id="errors" class="section-header"><a href="#errors">Errors</a></h1>
<p class="translate-text">如果容量溢出，或者分配器报告失败，则返回错误。</p><p>If the capacity overflows, or the allocator reports a failure, then an error
is returned.</p>
<h1 id="examples-12" class="section-header"><a href="#examples-12">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attribute">#![<span class="ident">feature</span>(<span class="ident">try_reserve</span>)]</span>
<span class="kw">use</span> <span class="ident">std::collections::TryReserveError</span>;

<span class="kw">fn</span> <span class="ident">process_data</span>(<span class="ident">data</span>: <span class="kw-2">&amp;</span>[<span class="ident">u32</span>]) <span class="op">-</span><span class="op">&gt;</span> <span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">u32</span><span class="op">&gt;</span>, <span class="ident">TryReserveError</span><span class="op">&gt;</span> {
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">output</span> <span class="op">=</span> <span class="ident">Vec::new</span>();

    <span class="comment">// Pre-reserve the memory, exiting if we can&#39;t</span>
    <span class="ident">output</span>.<span class="ident">try_reserve</span>(<span class="ident">data</span>.<span class="ident">len</span>())<span class="question-mark">?</span>;

    <span class="comment">// Now we know this can&#39;t OOM in the middle of our complex work</span>
    <span class="ident">output</span>.<span class="ident">extend</span>(<span class="ident">data</span>.<span class="ident">iter</span>().<span class="ident">map</span>(<span class="op">|</span><span class="kw-2">&amp;</span><span class="ident">val</span><span class="op">|</span> {
        <span class="ident">val</span> <span class="op">*</span> <span class="number">2</span> <span class="op">+</span> <span class="number">5</span> <span class="comment">// very complicated</span>
    }));

    <span class="prelude-val">Ok</span>(<span class="ident">output</span>)
}</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(try_reserve)%5D%0Afn%20main()%20%7B%0Ause%20std%3A%3Acollections%3A%3ATryReserveError%3B%0A%0Afn%20process_data(data%3A%20%26%5Bu32%5D)%20-%3E%20Result%3CVec%3Cu32%3E%2C%20TryReserveError%3E%20%7B%0A%20%20%20%20let%20mut%20output%20%3D%20Vec%3A%3Anew()%3B%0A%0A%20%20%20%20%2F%2F%20Pre-reserve%20the%20memory%2C%20exiting%20if%20we%20can't%0A%20%20%20%20output.try_reserve(data.len())%3F%3B%0A%0A%20%20%20%20%2F%2F%20Now%20we%20know%20this%20can't%20OOM%20in%20the%20middle%20of%20our%20complex%20work%0A%20%20%20%20output.extend(data.iter().map(%7C%26val%7C%20%7B%0A%20%20%20%20%20%20%20%20val%20*%202%20%2B%205%20%2F%2F%20very%20complicated%0A%20%20%20%20%7D))%3B%0A%0A%20%20%20%20Ok(output)%0A%7D%0Aprocess_data(%26%5B1%2C%202%2C%203%5D).expect(%22why%20is%20the%20test%20harness%20OOMing%20on%2012%20bytes%3F%22)%3B%0A%7D&amp;version=nightly&amp;edition=2018">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.try_reserve_exact" class="method has-srclink"><div class="rightside"><a class="srclink" href="../../src/alloc/vec/mod.rs.html#912-914" title="goto source code">[src]</a></div><a href="#method.try_reserve_exact" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.try_reserve_exact" class="fnname">try_reserve_exact</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;mut self, <br>&nbsp;&nbsp;&nbsp;&nbsp;additional: usize<br>) -&gt; <a class="enum" href="../../core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;(), <a class="struct" href="../collections/struct.TryReserveError.html" title="struct alloc::collections::TryReserveError">TryReserveError</a>&gt;</h4></div><div class="item-info"><div class="stab unstable"><details><summary><span class="emoji">🔬</span> This is a nightly-only experimental API. (<code>try_reserve</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/48043">#48043</a>)</summary><p>new API</p>
</details></div></div></summary><div class="docblock" xpath="/html[1]/body[1]/section[1]/details[3]/div[1]/details[10]/div[1]" istranslationnode="true" main_mp="YW1sbmc/PnNlYjo7UmBnOUQ9MFAqLy5hYmhPY3FmcWdWRH9EXERHUQ=="><p class="translate-text">尝试为要插入给定 Vec<t> 的确切附加元素保留最小容量。 调用 try_reserve_exact 后，如果返回 Ok(())，容量将大于或等于 self.len() + additional。 如果容量已经足够，则什么也不做。</t></p><p>Tries to reserve the minimum capacity for exactly <code>additional</code>
elements to be inserted in the given <code>Vec&lt;T&gt;</code>. After calling
<code>try_reserve_exact</code>, capacity will be greater than or equal to
<code>self.len() + additional</code> if it returns <code>Ok(())</code>.
Does nothing if the capacity is already sufficient.</p>
<p class="translate-text">请注意，分配器可能会为集合提供比其请求更多的空间。 因此，不能依赖容量精确到最小。 如果预计将来插入，则首选保留。</p><p>Note that the allocator may give the collection more space than it
requests. Therefore, capacity can not be relied upon to be precisely
minimal. Prefer <a href="struct.Vec.html#method.reserve"><code>reserve</code></a> if future insertions are expected.</p>
<h1 id="errors-1" class="section-header"><a href="#errors-1">Errors</a></h1>
<p class="translate-text">如果容量溢出，或者分配器报告失败，则返回错误。</p><p>If the capacity overflows, or the allocator reports a failure, then an error
is returned.</p>
<h1 id="examples-13" class="section-header"><a href="#examples-13">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attribute">#![<span class="ident">feature</span>(<span class="ident">try_reserve</span>)]</span>
<span class="kw">use</span> <span class="ident">std::collections::TryReserveError</span>;

<span class="kw">fn</span> <span class="ident">process_data</span>(<span class="ident">data</span>: <span class="kw-2">&amp;</span>[<span class="ident">u32</span>]) <span class="op">-</span><span class="op">&gt;</span> <span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">u32</span><span class="op">&gt;</span>, <span class="ident">TryReserveError</span><span class="op">&gt;</span> {
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">output</span> <span class="op">=</span> <span class="ident">Vec::new</span>();

    <span class="comment">// Pre-reserve the memory, exiting if we can&#39;t</span>
    <span class="ident">output</span>.<span class="ident">try_reserve_exact</span>(<span class="ident">data</span>.<span class="ident">len</span>())<span class="question-mark">?</span>;

    <span class="comment">// Now we know this can&#39;t OOM in the middle of our complex work</span>
    <span class="ident">output</span>.<span class="ident">extend</span>(<span class="ident">data</span>.<span class="ident">iter</span>().<span class="ident">map</span>(<span class="op">|</span><span class="kw-2">&amp;</span><span class="ident">val</span><span class="op">|</span> {
        <span class="ident">val</span> <span class="op">*</span> <span class="number">2</span> <span class="op">+</span> <span class="number">5</span> <span class="comment">// very complicated</span>
    }));

    <span class="prelude-val">Ok</span>(<span class="ident">output</span>)
}</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(try_reserve)%5D%0Afn%20main()%20%7B%0Ause%20std%3A%3Acollections%3A%3ATryReserveError%3B%0A%0Afn%20process_data(data%3A%20%26%5Bu32%5D)%20-%3E%20Result%3CVec%3Cu32%3E%2C%20TryReserveError%3E%20%7B%0A%20%20%20%20let%20mut%20output%20%3D%20Vec%3A%3Anew()%3B%0A%0A%20%20%20%20%2F%2F%20Pre-reserve%20the%20memory%2C%20exiting%20if%20we%20can't%0A%20%20%20%20output.try_reserve_exact(data.len())%3F%3B%0A%0A%20%20%20%20%2F%2F%20Now%20we%20know%20this%20can't%20OOM%20in%20the%20middle%20of%20our%20complex%20work%0A%20%20%20%20output.extend(data.iter().map(%7C%26val%7C%20%7B%0A%20%20%20%20%20%20%20%20val%20*%202%20%2B%205%20%2F%2F%20very%20complicated%0A%20%20%20%20%7D))%3B%0A%0A%20%20%20%20Ok(output)%0A%7D%0Aprocess_data(%26%5B1%2C%202%2C%203%5D).expect(%22why%20is%20the%20test%20harness%20OOMing%20on%2012%20bytes%3F%22)%3B%0A%7D&amp;version=nightly&amp;edition=2018">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.shrink_to_fit" class="method has-srclink"><div class="rightside"><a class="srclink" href="../../src/alloc/vec/mod.rs.html#932-939" title="goto source code">[src]</a></div><a href="#method.shrink_to_fit" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.shrink_to_fit" class="fnname">shrink_to_fit</a>(&amp;mut self)</h4></div></summary><div class="docblock" xpath="/html[1]/body[1]/section[1]/details[3]/div[1]/details[11]/div[1]" istranslationnode="true" main_mp="YW1sbmc/PnNlYjo7UmBnOUQ9MFAqLy5meGN5f39KYHp/R0lV"><p class="translate-text">尽可能缩小Vector的容量。</p><p>Shrinks the capacity of the vector as much as possible.</p>
<p class="translate-text">它将尽可能接近长度下降，但分配器仍可能通知Vector有空间容纳更多元素。</p><p>It will drop down as close as possible to the length but the allocator
may still inform the vector that there is space for a few more elements.</p>
<h1 id="examples-14" class="section-header"><a href="#examples-14">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">vec</span> <span class="op">=</span> <span class="ident">Vec::with_capacity</span>(<span class="number">10</span>);
<span class="ident">vec</span>.<span class="ident">extend</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);
<span class="macro">assert_eq!</span>(<span class="ident">vec</span>.<span class="ident">capacity</span>(), <span class="number">10</span>);
<span class="ident">vec</span>.<span class="ident">shrink_to_fit</span>();
<span class="macro">assert!</span>(<span class="ident">vec</span>.<span class="ident">capacity</span>() <span class="op">&gt;</span><span class="op">=</span> <span class="number">3</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20mut%20vec%20%3D%20Vec%3A%3Awith_capacity(10)%3B%0Avec.extend(%5B1%2C%202%2C%203%5D)%3B%0Aassert_eq!(vec.capacity()%2C%2010)%3B%0Avec.shrink_to_fit()%3B%0Aassert!(vec.capacity()%20%3E%3D%203)%3B%0A%7D&amp;edition=2018">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.shrink_to" class="method has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.56.0">1.56.0</span><a class="srclink" href="../../src/alloc/vec/mod.rs.html#961-965" title="goto source code">[src]</a></div><a href="#method.shrink_to" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.shrink_to" class="fnname">shrink_to</a>(&amp;mut self, min_capacity: usize)</h4></div></summary><div class="docblock" xpath="/html[1]/body[1]/section[1]/details[3]/div[1]/details[12]/div[1]" istranslationnode="true" main_mp="YW1sbmc/PnNlYjo7UmBnOUQ9MFAqLy5meGN5f39KYHo="><p class="translate-text">使用下限缩小Vector的容量。</p><p>Shrinks the capacity of the vector with a lower bound.</p>
<p class="translate-text">容量将至少与长度和提供的值一样大。</p><p>The capacity will remain at least as large as both the length
and the supplied value.</p>
<p class="translate-text">如果当前容量小于下限，这是一个空操作。</p><p>If the current capacity is less than the lower limit, this is a no-op.</p>
<h1 id="examples-15" class="section-header"><a href="#examples-15">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">vec</span> <span class="op">=</span> <span class="ident">Vec::with_capacity</span>(<span class="number">10</span>);
<span class="ident">vec</span>.<span class="ident">extend</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);
<span class="macro">assert_eq!</span>(<span class="ident">vec</span>.<span class="ident">capacity</span>(), <span class="number">10</span>);
<span class="ident">vec</span>.<span class="ident">shrink_to</span>(<span class="number">4</span>);
<span class="macro">assert!</span>(<span class="ident">vec</span>.<span class="ident">capacity</span>() <span class="op">&gt;</span><span class="op">=</span> <span class="number">4</span>);
<span class="ident">vec</span>.<span class="ident">shrink_to</span>(<span class="number">0</span>);
<span class="macro">assert!</span>(<span class="ident">vec</span>.<span class="ident">capacity</span>() <span class="op">&gt;</span><span class="op">=</span> <span class="number">3</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20mut%20vec%20%3D%20Vec%3A%3Awith_capacity(10)%3B%0Avec.extend(%5B1%2C%202%2C%203%5D)%3B%0Aassert_eq!(vec.capacity()%2C%2010)%3B%0Avec.shrink_to(4)%3B%0Aassert!(vec.capacity()%20%3E%3D%204)%3B%0Avec.shrink_to(0)%3B%0Aassert!(vec.capacity()%20%3E%3D%203)%3B%0A%7D&amp;edition=2018">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.into_boxed_slice" class="method has-srclink"><div class="rightside"><a class="srclink" href="../../src/alloc/vec/mod.rs.html#993-1001" title="goto source code">[src]</a></div><a href="#method.into_boxed_slice" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.into_boxed_slice" class="fnname">into_boxed_slice</a>(self) -&gt; <a class="struct" href="../boxed/struct.Box.html" title="struct alloc::boxed::Box">Box</a>&lt;[T], A&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><div class="notable">Notable traits for <a class="struct" href="../boxed/struct.Box.html" title="struct alloc::boxed::Box">Box</a>&lt;I, A&gt;</div><code class="content"><span class="where fmt-newline">impl&lt;I:&nbsp;<a class="trait" href="../../core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> + ?<a class="trait" href="../../core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>, A:&nbsp;<a class="trait" href="../alloc/trait.Allocator.html" title="trait alloc::alloc::Allocator">Allocator</a>&gt; <a class="trait" href="../../core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="../boxed/struct.Box.html" title="struct alloc::boxed::Box">Box</a>&lt;I, A&gt;</span><span class="where fmt-newline">    type <a href="../../core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="type">Item</a> = I::<a class="type" href="../../core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" title="type core::iter::traits::iterator::Iterator::Item">Item</a>;</span><span class="where fmt-newline">impl&lt;F:&nbsp;?<a class="trait" href="../../core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a> + <a class="trait" href="../../core/future/future/trait.Future.html" title="trait core::future::future::Future">Future</a> + <a class="trait" href="../../core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a>, A:&nbsp;<a class="trait" href="../alloc/trait.Allocator.html" title="trait alloc::alloc::Allocator">Allocator</a>&gt; <a class="trait" href="../../core/future/future/trait.Future.html" title="trait core::future::future::Future">Future</a> for <a class="struct" href="../boxed/struct.Box.html" title="struct alloc::boxed::Box">Box</a>&lt;F, A&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;A: 'static,&nbsp;</span></span><span class="where fmt-newline">    type <a href="../../core/future/future/trait.Future.html#associatedtype.Output" class="type">Output</a> = F::<a class="type" href="../../core/future/future/trait.Future.html#associatedtype.Output" title="type core::future::future::Future::Output">Output</a>;</span></code></span></div></span></span></h4></div></summary><div class="docblock" xpath="/html[1]/body[1]/section[1]/details[3]/div[1]/details[13]/div[1]" istranslationnode="true" main_mp="YW1sbmc/PnNlYjo7UmBnOUQ9MFAqLy58fmV/TnZ6bHBEflNNTUZB"><p class="translate-text">将Vector转换为 Box<[T]>。</p><p>Converts the vector into <a href="../boxed/struct.Box.html"><code>Box&lt;[T]&gt;</code></a>.</p>
<p class="translate-text">请注意，这将减少任何多余的容量。</p><p>Note that this will drop any excess capacity.</p>
<h1 id="examples-16" class="section-header"><a href="#examples-16">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">v</span> <span class="op">=</span> <span class="macro">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];

<span class="kw">let</span> <span class="ident">slice</span> <span class="op">=</span> <span class="ident">v</span>.<span class="ident">into_boxed_slice</span>();</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20v%20%3D%20vec!%5B1%2C%202%2C%203%5D%3B%0A%0Alet%20slice%20%3D%20v.into_boxed_slice()%3B%0A%7D&amp;edition=2018">Run</a></div>
<p class="translate-text">移除任何多余的容量：</p><p>Any excess capacity is removed:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">vec</span> <span class="op">=</span> <span class="ident">Vec::with_capacity</span>(<span class="number">10</span>);
<span class="ident">vec</span>.<span class="ident">extend</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);

<span class="macro">assert_eq!</span>(<span class="ident">vec</span>.<span class="ident">capacity</span>(), <span class="number">10</span>);
<span class="kw">let</span> <span class="ident">slice</span> <span class="op">=</span> <span class="ident">vec</span>.<span class="ident">into_boxed_slice</span>();
<span class="macro">assert_eq!</span>(<span class="ident">slice</span>.<span class="ident">into_vec</span>().<span class="ident">capacity</span>(), <span class="number">3</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20mut%20vec%20%3D%20Vec%3A%3Awith_capacity(10)%3B%0Avec.extend(%5B1%2C%202%2C%203%5D)%3B%0A%0Aassert_eq!(vec.capacity()%2C%2010)%3B%0Alet%20slice%20%3D%20vec.into_boxed_slice()%3B%0Aassert_eq!(slice.into_vec().capacity()%2C%203)%3B%0A%7D&amp;edition=2018">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.truncate" class="method has-srclink"><div class="rightside"><a class="srclink" href="../../src/alloc/vec/mod.rs.html#1046-1066" title="goto source code">[src]</a></div><a href="#method.truncate" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.truncate" class="fnname">truncate</a>(&amp;mut self, len: usize)</h4></div></summary><div class="docblock" xpath="/html[1]/body[1]/section[1]/details[3]/div[1]/details[14]/div[1]" istranslationnode="true" main_mp="YW1sbmc/PnNlYjo7UmBnOUQ9MFAqLy5hYmR+cnVhcQ=="><p class="translate-text">缩短Vector，保留第一个 len 元素并丢弃其余元素。</p><p>Shortens the vector, keeping the first <code>len</code> elements and dropping
the rest.</p>
<p class="translate-text">如果 len 大于Vector的当前长度，则无效。</p><p>If <code>len</code> is greater than the vector’s current length, this has no
effect.</p>
<p class="translate-text">drain 方法可以模拟 truncate，但会导致返回而不是丢弃多余的元素。</p><p>The <a href="struct.Vec.html#method.drain"><code>drain</code></a> method can emulate <code>truncate</code>, but causes the excess
elements to be returned instead of dropped.</p>
<p class="translate-text">请注意，此方法对Vector的分配容量没有影响。</p><p>Note that this method has no effect on the allocated capacity
of the vector.</p>
<h1 id="examples-17" class="section-header"><a href="#examples-17">Examples</a></h1>
<p class="translate-text">将一个五元素Vector截断为两个元素：</p><p>Truncating a five element vector to two elements:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">vec</span> <span class="op">=</span> <span class="macro">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];
<span class="ident">vec</span>.<span class="ident">truncate</span>(<span class="number">2</span>);
<span class="macro">assert_eq!</span>(<span class="ident">vec</span>, [<span class="number">1</span>, <span class="number">2</span>]);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20mut%20vec%20%3D%20vec!%5B1%2C%202%2C%203%2C%204%2C%205%5D%3B%0Avec.truncate(2)%3B%0Aassert_eq!(vec%2C%20%5B1%2C%202%5D)%3B%0A%7D&amp;edition=2018">Run</a></div>
<p class="translate-text">当 len 大于Vector的当前长度时，不会发生截断：</p><p>No truncation occurs when <code>len</code> is greater than the vector’s current
length:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">vec</span> <span class="op">=</span> <span class="macro">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];
<span class="ident">vec</span>.<span class="ident">truncate</span>(<span class="number">8</span>);
<span class="macro">assert_eq!</span>(<span class="ident">vec</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20mut%20vec%20%3D%20vec!%5B1%2C%202%2C%203%5D%3B%0Avec.truncate(8)%3B%0Aassert_eq!(vec%2C%20%5B1%2C%202%2C%203%5D)%3B%0A%7D&amp;edition=2018">Run</a></div>
<p class="translate-text">当 len == 0 时截断相当于调用 clear 方法。</p><p>Truncating when <code>len == 0</code> is equivalent to calling the <a href="struct.Vec.html#method.clear"><code>clear</code></a>
method.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">vec</span> <span class="op">=</span> <span class="macro">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];
<span class="ident">vec</span>.<span class="ident">truncate</span>(<span class="number">0</span>);
<span class="macro">assert_eq!</span>(<span class="ident">vec</span>, []);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20mut%20vec%20%3D%20vec!%5B1%2C%202%2C%203%5D%3B%0Avec.truncate(0)%3B%0Aassert_eq!(vec%2C%20%5B%5D)%3B%0A%7D&amp;edition=2018">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.as_slice" class="method has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.7.0">1.7.0</span><a class="srclink" href="../../src/alloc/vec/mod.rs.html#1081-1083" title="goto source code">[src]</a></div><a href="#method.as_slice" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.as_slice" class="fnname">as_slice</a>(&amp;self) -&gt; &amp;[T]</h4></div></summary><div class="docblock" xpath="/html[1]/body[1]/section[1]/details[3]/div[1]/details[15]/div[1]" istranslationnode="true" main_mp="YW1sbmc/PnNlYjo7UmBnOUQ9MFAqLy50Y05jfX12cQ=="><p class="translate-text">提取包含整个Vector的切片。</p><p>Extracts a slice containing the entire vector.</p>
<p class="translate-text">等价于 &s[..]。</p><p>Equivalent to <code>&amp;s[..]</code>.</p>
<h1 id="examples-18" class="section-header"><a href="#examples-18">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">std::io</span>::{<span class="self">self</span>, <span class="ident">Write</span>};
<span class="kw">let</span> <span class="ident">buffer</span> <span class="op">=</span> <span class="macro">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>];
<span class="ident">io::sink</span>().<span class="ident">write</span>(<span class="ident">buffer</span>.<span class="ident">as_slice</span>()).<span class="ident">unwrap</span>();</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Ause%20std%3A%3Aio%3A%3A%7Bself%2C%20Write%7D%3B%0Alet%20buffer%20%3D%20vec!%5B1%2C%202%2C%203%2C%205%2C%208%5D%3B%0Aio%3A%3Asink().write(buffer.as_slice()).unwrap()%3B%0A%7D&amp;edition=2018">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.as_mut_slice" class="method has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.7.0">1.7.0</span><a class="srclink" href="../../src/alloc/vec/mod.rs.html#1098-1100" title="goto source code">[src]</a></div><a href="#method.as_mut_slice" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.as_mut_slice" class="fnname">as_mut_slice</a>(&amp;mut self) -&gt; &amp;mut [T]</h4></div></summary><div class="docblock" xpath="/html[1]/body[1]/section[1]/details[3]/div[1]/details[16]/div[1]" istranslationnode="true" main_mp="YW1sbmc/PnNlYjo7UmBnOUQ9MFAqLy50Y059ZGBKZ3lJQkU="><p class="translate-text">提取整个Vector的可变切片。</p><p>Extracts a mutable slice of the entire vector.</p>
<p class="translate-text">等效于 &mut s[..]。</p><p>Equivalent to <code>&amp;mut s[..]</code>.</p>
<h1 id="examples-19" class="section-header"><a href="#examples-19">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">std::io</span>::{<span class="self">self</span>, <span class="ident">Read</span>};
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">buffer</span> <span class="op">=</span> <span class="macro">vec!</span>[<span class="number">0</span>; <span class="number">3</span>];
<span class="ident">io::repeat</span>(<span class="number">0b101</span>).<span class="ident">read_exact</span>(<span class="ident">buffer</span>.<span class="ident">as_mut_slice</span>()).<span class="ident">unwrap</span>();</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Ause%20std%3A%3Aio%3A%3A%7Bself%2C%20Read%7D%3B%0Alet%20mut%20buffer%20%3D%20vec!%5B0%3B%203%5D%3B%0Aio%3A%3Arepeat(0b101).read_exact(buffer.as_mut_slice()).unwrap()%3B%0A%7D&amp;edition=2018">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.as_ptr" class="method has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.37.0">1.37.0</span><a class="srclink" href="../../src/alloc/vec/mod.rs.html#1129-1137" title="goto source code">[src]</a></div><a href="#method.as_ptr" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.as_ptr" class="fnname">as_ptr</a>(&amp;self) -&gt; *const T</h4></div></summary><div class="docblock" xpath="/html[1]/body[1]/section[1]/details[3]/div[1]/details[17]/div[1]" istranslationnode="true" main_mp="YW1sbmc/PnNlYjo7UmBnOUQ9MFAqLy50Y05gZWY="><p class="translate-text">返回指向Vector缓冲区的原始指针。</p><p>Returns a raw pointer to the vector’s buffer.</p>
<p class="translate-text">调用者必须确保Vector比这个函数返回的指针的寿命更长，否则它将最终指向垃圾。 修改Vector可能会导致其缓冲区被重新分配，这也会使指向它的任何指针无效。</p><p>The caller must ensure that the vector outlives the pointer this
function returns, or else it will end up pointing to garbage.
Modifying the vector may cause its buffer to be reallocated,
which would also make any pointers to it invalid.</p>
<p class="translate-text">调用者还必须确保指针（非传递性）指向的内存永远不会使用此指针或从它派生的任何指针写入（在 UnsafeCell 内除外）。 如果您需要改变切片的内容，请使用 as_mut_ptr。</p><p>The caller must also ensure that the memory the pointer (non-transitively) points to
is never written to (except inside an <code>UnsafeCell</code>) using this pointer or any pointer
derived from it. If you need to mutate the contents of the slice, use <a href="struct.Vec.html#method.as_mut_ptr"><code>as_mut_ptr</code></a>.</p>
<h1 id="examples-20" class="section-header"><a href="#examples-20">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="macro">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>];
<span class="kw">let</span> <span class="ident">x_ptr</span> <span class="op">=</span> <span class="ident">x</span>.<span class="ident">as_ptr</span>();

<span class="kw">unsafe</span> {
    <span class="kw">for</span> <span class="ident">i</span> <span class="kw">in</span> <span class="number">0</span>..<span class="ident">x</span>.<span class="ident">len</span>() {
        <span class="macro">assert_eq!</span>(<span class="kw-2">*</span><span class="ident">x_ptr</span>.<span class="ident">add</span>(<span class="ident">i</span>), <span class="number">1</span> <span class="op">&lt;</span><span class="op">&lt;</span> <span class="ident">i</span>);
    }
}</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20x%20%3D%20vec!%5B1%2C%202%2C%204%5D%3B%0Alet%20x_ptr%20%3D%20x.as_ptr()%3B%0A%0Aunsafe%20%7B%0A%20%20%20%20for%20i%20in%200..x.len()%20%7B%0A%20%20%20%20%20%20%20%20assert_eq!(*x_ptr.add(i)%2C%201%20%3C%3C%20i)%3B%0A%20%20%20%20%7D%0A%7D%0A%7D&amp;edition=2018">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.as_mut_ptr" class="method has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.37.0">1.37.0</span><a class="srclink" href="../../src/alloc/vec/mod.rs.html#1165-1173" title="goto source code">[src]</a></div><a href="#method.as_mut_ptr" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.as_mut_ptr" class="fnname">as_mut_ptr</a>(&amp;mut self) -&gt; *mut T</h4></div></summary><div class="docblock" xpath="/html[1]/body[1]/section[1]/details[3]/div[1]/details[18]/div[1]" istranslationnode="true" main_mp="YW1sbmc/PnNlYjo7UmBnOUQ9MFAqLy50Y059ZGBKZGFS"><p class="translate-text">返回指向Vector缓冲区的不安全可变指针。</p><p>Returns an unsafe mutable pointer to the vector’s buffer.</p>
<p class="translate-text">调用者必须确保Vector比这个函数返回的指针的寿命更长，否则它将最终指向垃圾。 修改Vector可能会导致其缓冲区被重新分配，这也会使指向它的任何指针无效。</p><p>The caller must ensure that the vector outlives the pointer this
function returns, or else it will end up pointing to garbage.
Modifying the vector may cause its buffer to be reallocated,
which would also make any pointers to it invalid.</p>
<h1 id="examples-21" class="section-header"><a href="#examples-21">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Allocate vector big enough for 4 elements.</span>
<span class="kw">let</span> <span class="ident">size</span> <span class="op">=</span> <span class="number">4</span>;
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">x</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">i32</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">Vec::with_capacity</span>(<span class="ident">size</span>);
<span class="kw">let</span> <span class="ident">x_ptr</span> <span class="op">=</span> <span class="ident">x</span>.<span class="ident">as_mut_ptr</span>();

<span class="comment">// Initialize elements via raw pointer writes, then set length.</span>
<span class="kw">unsafe</span> {
    <span class="kw">for</span> <span class="ident">i</span> <span class="kw">in</span> <span class="number">0</span>..<span class="ident">size</span> {
        <span class="kw-2">*</span><span class="ident">x_ptr</span>.<span class="ident">add</span>(<span class="ident">i</span>) <span class="op">=</span> <span class="ident">i</span> <span class="kw">as</span> <span class="ident">i32</span>;
    }
    <span class="ident">x</span>.<span class="ident">set_len</span>(<span class="ident">size</span>);
}
<span class="macro">assert_eq!</span>(<span class="kw-2">&amp;</span><span class="kw-2">*</span><span class="ident">x</span>, <span class="kw-2">&amp;</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%2F%2F%20Allocate%20vector%20big%20enough%20for%204%20elements.%0Afn%20main()%20%7B%0Alet%20size%20%3D%204%3B%0Alet%20mut%20x%3A%20Vec%3Ci32%3E%20%3D%20Vec%3A%3Awith_capacity(size)%3B%0Alet%20x_ptr%20%3D%20x.as_mut_ptr()%3B%0A%0A%2F%2F%20Initialize%20elements%20via%20raw%20pointer%20writes%2C%20then%20set%20length.%0Aunsafe%20%7B%0A%20%20%20%20for%20i%20in%200..size%20%7B%0A%20%20%20%20%20%20%20%20*x_ptr.add(i)%20%3D%20i%20as%20i32%3B%0A%20%20%20%20%7D%0A%20%20%20%20x.set_len(size)%3B%0A%7D%0Aassert_eq!(%26*x%2C%20%26%5B0%2C%201%2C%202%2C%203%5D)%3B%0A%7D&amp;edition=2018">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.allocator" class="method has-srclink"><div class="rightside"><a class="srclink" href="../../src/alloc/vec/mod.rs.html#1178-1180" title="goto source code">[src]</a></div><a href="#method.allocator" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.allocator" class="fnname">allocator</a>(&amp;self) -&gt; &amp;A</h4></div><div class="item-info"><div class="stab unstable"><span class="emoji">🔬</span> This is a nightly-only experimental API. (<code>allocator_api</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/32838">#32838</a>)</div></div></summary><div class="docblock" xpath="/html[1]/body[1]/section[1]/details[3]/div[1]/details[19]/div[1]" istranslationnode="true" main_mp="YW1sbmc/PnNlYjo7UmBnOUQ9MFAqLy50fH1/cnVhe2c="><p class="translate-text">返回对底层分配器的引用。</p><p>Returns a reference to the underlying allocator.</p>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.set_len" class="method has-srclink"><div class="rightside"><a class="srclink" href="../../src/alloc/vec/mod.rs.html#1262-1266" title="goto source code">[src]</a></div><a href="#method.set_len" class="anchor"></a><h4 class="code-header">pub unsafe fn <a href="#method.set_len" class="fnname">set_len</a>(&amp;mut self, new_len: usize)</h4></div></summary><div class="docblock" xpath="/html[1]/body[1]/section[1]/details[3]/div[1]/details[20]/div[1]" istranslationnode="true" main_mp="YW1sbmc/PnNlYjo7UmBnOUQ9MFAqLy5mdWVPfXF7"><p class="translate-text">将Vector的长度强制为 new_len。</p><p>Forces the length of the vector to <code>new_len</code>.</p>
<p class="translate-text">这是一个低级操作，不维护该类型的任何正常不变量。 通常，更改Vector的长度是使用安全操作之一来完成的，例如截断、调整大小、扩展或清除。</p><p>This is a low-level operation that maintains none of the normal
invariants of the type. Normally changing the length of a vector
is done using one of the safe operations instead, such as
<a href="struct.Vec.html#method.truncate"><code>truncate</code></a>, <a href="struct.Vec.html#method.resize"><code>resize</code></a>, <a href="../../core/iter/traits/collect/trait.Extend.html#tymethod.extend"><code>extend</code></a>, or <a href="struct.Vec.html#method.clear"><code>clear</code></a>.</p>
<h1 id="safety-2" class="section-header"><a href="#safety-2">Safety</a></h1>
<ul>
<li class="translate-text">new_len 必须小于或等于 capacity()。</li><li><code>new_len</code> must be less than or equal to <a href="struct.Vec.html#method.capacity"><code>capacity()</code></a>.</li>
<li class="translate-text">old_len..new_len 的元素必须被初始化。</li><li>The elements at <code>old_len..new_len</code> must be initialized.</li>
</ul>
<h1 id="examples-22" class="section-header"><a href="#examples-22">Examples</a></h1>
<p class="translate-text">此方法对于Vector用作其他代码的缓冲区的情况非常有用，特别是在 FFI 上：</p><p>This method can be useful for situations in which the vector
is serving as a buffer for other code, particularly over FFI:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">get_dictionary</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">u8</span><span class="op">&gt;</span><span class="op">&gt;</span> {
    <span class="comment">// Per the FFI method&#39;s docs, &quot;32768 bytes is always enough&quot;.</span>
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">dict</span> <span class="op">=</span> <span class="ident">Vec::with_capacity</span>(<span class="number">32_768</span>);
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">dict_length</span> <span class="op">=</span> <span class="number">0</span>;
    <span class="comment">// SAFETY: When `deflateGetDictionary` returns `Z_OK`, it holds that:</span>
    <span class="comment">// 1. `dict_length` elements were initialized.</span>
    <span class="comment">// 2. `dict_length` &lt;= the capacity (32_768)</span>
    <span class="comment">// which makes `set_len` safe to call.</span>
    <span class="kw">unsafe</span> {
        <span class="comment">// Make the FFI call...</span>
        <span class="kw">let</span> <span class="ident">r</span> <span class="op">=</span> <span class="ident">deflateGetDictionary</span>(<span class="self">self</span>.<span class="ident">strm</span>, <span class="ident">dict</span>.<span class="ident">as_mut_ptr</span>(), <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">dict_length</span>);
        <span class="kw">if</span> <span class="ident">r</span> <span class="op">=</span><span class="op">=</span> <span class="ident">Z_OK</span> {
            <span class="comment">// ...and update the length to what was initialized.</span>
            <span class="ident">dict</span>.<span class="ident">set_len</span>(<span class="ident">dict_length</span>);
            <span class="prelude-val">Some</span>(<span class="ident">dict</span>)
        } <span class="kw">else</span> {
            <span class="prelude-val">None</span>
        }
    }
}</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Ballow(dead_code)%5D%0A%2F%2F%20This%20is%20just%20a%20minimal%20skeleton%20for%20the%20doc%20example%3B%0A%2F%2F%20don't%20use%20this%20as%20a%20starting%20point%20for%20a%20real%20library.%0Afn%20main()%20%7B%0Apub%20struct%20StreamWrapper%20%7B%20strm%3A%20*mut%20std%3A%3Affi%3A%3Ac_void%20%7D%0Aconst%20Z_OK%3A%20i32%20%3D%200%3B%0Aextern%20%22C%22%20%7B%0A%20%20%20%20fn%20deflateGetDictionary(%0A%20%20%20%20%20%20%20%20strm%3A%20*mut%20std%3A%3Affi%3A%3Ac_void%2C%0A%20%20%20%20%20%20%20%20dictionary%3A%20*mut%20u8%2C%0A%20%20%20%20%20%20%20%20dictLength%3A%20*mut%20usize%2C%0A%20%20%20%20)%20-%3E%20i32%3B%0A%7D%0Aimpl%20StreamWrapper%20%7B%0Apub%20fn%20get_dictionary(%26self)%20-%3E%20Option%3CVec%3Cu8%3E%3E%20%7B%0A%20%20%20%20%2F%2F%20Per%20the%20FFI%20method's%20docs%2C%20%2232768%20bytes%20is%20always%20enough%22.%0A%20%20%20%20let%20mut%20dict%20%3D%20Vec%3A%3Awith_capacity(32_768)%3B%0A%20%20%20%20let%20mut%20dict_length%20%3D%200%3B%0A%20%20%20%20%2F%2F%20SAFETY%3A%20When%20%60deflateGetDictionary%60%20returns%20%60Z_OK%60%2C%20it%20holds%20that%3A%0A%20%20%20%20%2F%2F%201.%20%60dict_length%60%20elements%20were%20initialized.%0A%20%20%20%20%2F%2F%202.%20%60dict_length%60%20%3C%3D%20the%20capacity%20(32_768)%0A%20%20%20%20%2F%2F%20which%20makes%20%60set_len%60%20safe%20to%20call.%0A%20%20%20%20unsafe%20%7B%0A%20%20%20%20%20%20%20%20%2F%2F%20Make%20the%20FFI%20call...%0A%20%20%20%20%20%20%20%20let%20r%20%3D%20deflateGetDictionary(self.strm%2C%20dict.as_mut_ptr()%2C%20%26mut%20dict_length)%3B%0A%20%20%20%20%20%20%20%20if%20r%20%3D%3D%20Z_OK%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20...and%20update%20the%20length%20to%20what%20was%20initialized.%0A%20%20%20%20%20%20%20%20%20%20%20%20dict.set_len(dict_length)%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20Some(dict)%0A%20%20%20%20%20%20%20%20%7D%20else%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20None%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%7D%0A%7D%0A%7D&amp;edition=2018">Run</a></div>
<p class="translate-text">虽然下面的示例是合理的，但存在内存泄漏，因为在 set_len 调用之前没有释放内部Vector：</p><p>While the following example is sound, there is a memory leak since
the inner vectors were not freed prior to the <code>set_len</code> call:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">vec</span> <span class="op">=</span> <span class="macro">vec!</span>[<span class="macro">vec!</span>[<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>],
                   <span class="macro">vec!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>],
                   <span class="macro">vec!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]];
<span class="comment">// SAFETY:</span>
<span class="comment">// 1. `old_len..0` is empty so no elements need to be initialized.</span>
<span class="comment">// 2. `0 &lt;= capacity` always holds whatever `capacity` is.</span>
<span class="kw">unsafe</span> {
    <span class="ident">vec</span>.<span class="ident">set_len</span>(<span class="number">0</span>);
}</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20mut%20vec%20%3D%20vec!%5Bvec!%5B1%2C%200%2C%200%5D%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20vec!%5B0%2C%201%2C%200%5D%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20vec!%5B0%2C%200%2C%201%5D%5D%3B%0A%2F%2F%20SAFETY%3A%0A%2F%2F%201.%20%60old_len..0%60%20is%20empty%20so%20no%20elements%20need%20to%20be%20initialized.%0A%2F%2F%202.%20%600%20%3C%3D%20capacity%60%20always%20holds%20whatever%20%60capacity%60%20is.%0Aunsafe%20%7B%0A%20%20%20%20vec.set_len(0)%3B%0A%7D%0A%7D&amp;edition=2018">Run</a></div>
<p class="translate-text">通常，在这里，人们会使用 clear 来正确删除内容，从而不会泄漏内存。</p><p>Normally, here, one would use <a href="struct.Vec.html#method.clear"><code>clear</code></a> instead to correctly drop
the contents and thus not leak memory.</p>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.swap_remove" class="method has-srclink"><div class="rightside"><a class="srclink" href="../../src/alloc/vec/mod.rs.html#1291-1311" title="goto source code">[src]</a></div><a href="#method.swap_remove" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.swap_remove" class="fnname">swap_remove</a>(&amp;mut self, index: usize) -&gt; T</h4></div></summary><div class="docblock" xpath="/html[1]/body[1]/section[1]/details[3]/div[1]/details[21]/div[1]" istranslationnode="true" main_mp="YW1sbmc/PnNlYjo7UmBnOUQ9MFAqLy5mZ3BgTmZweXpWRA=="><p class="translate-text">从Vector中移除一个元素并返回它。</p><p>Removes an element from the vector and returns it.</p>
<p class="translate-text">移除的元素被Vector的最后一个元素替换。</p><p>The removed element is replaced by the last element of the vector.</p>
<p class="translate-text">这不保留顺序，而是 O(1)。</p><p>This does not preserve ordering, but is O(1).</p>
<h1 id="panics-4" class="section-header"><a href="#panics-4">Panics</a></h1>
<p class="translate-text">如果索引超出范围，则会出现panic。</p><p>Panics if <code>index</code> is out of bounds.</p>
<h1 id="examples-23" class="section-header"><a href="#examples-23">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">v</span> <span class="op">=</span> <span class="macro">vec!</span>[<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>, <span class="string">&quot;baz&quot;</span>, <span class="string">&quot;qux&quot;</span>];

<span class="macro">assert_eq!</span>(<span class="ident">v</span>.<span class="ident">swap_remove</span>(<span class="number">1</span>), <span class="string">&quot;bar&quot;</span>);
<span class="macro">assert_eq!</span>(<span class="ident">v</span>, [<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;qux&quot;</span>, <span class="string">&quot;baz&quot;</span>]);

<span class="macro">assert_eq!</span>(<span class="ident">v</span>.<span class="ident">swap_remove</span>(<span class="number">0</span>), <span class="string">&quot;foo&quot;</span>);
<span class="macro">assert_eq!</span>(<span class="ident">v</span>, [<span class="string">&quot;baz&quot;</span>, <span class="string">&quot;qux&quot;</span>]);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20mut%20v%20%3D%20vec!%5B%22foo%22%2C%20%22bar%22%2C%20%22baz%22%2C%20%22qux%22%5D%3B%0A%0Aassert_eq!(v.swap_remove(1)%2C%20%22bar%22)%3B%0Aassert_eq!(v%2C%20%5B%22foo%22%2C%20%22qux%22%2C%20%22baz%22%5D)%3B%0A%0Aassert_eq!(v.swap_remove(0)%2C%20%22foo%22)%3B%0Aassert_eq!(v%2C%20%5B%22baz%22%2C%20%22qux%22%5D)%3B%0A%7D&amp;edition=2018">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.insert" class="method has-srclink"><div class="rightside"><a class="srclink" href="../../src/alloc/vec/mod.rs.html#1331-1362" title="goto source code">[src]</a></div><a href="#method.insert" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.insert" class="fnname">insert</a>(&amp;mut self, index: usize, element: T)</h4></div></summary><div class="docblock" xpath="/html[1]/body[1]/section[1]/details[3]/div[1]/details[22]/div[1]" istranslationnode="true" main_mp="YW1sbmc/PnNlYjo7UmBnOUQ9MFAqLy58fmJ1Y2A="><p class="translate-text">在Vector内的索引位置插入一个元素，将其后的所有元素向右移动。</p><p>Inserts an element at position <code>index</code> within the vector, shifting all
elements after it to the right.</p>
<h1 id="panics-5" class="section-header"><a href="#panics-5">Panics</a></h1>
<p class="translate-text">如果 index > len 会出现panic。</p><p>Panics if <code>index &gt; len</code>.</p>
<h1 id="examples-24" class="section-header"><a href="#examples-24">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">vec</span> <span class="op">=</span> <span class="macro">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];
<span class="ident">vec</span>.<span class="ident">insert</span>(<span class="number">1</span>, <span class="number">4</span>);
<span class="macro">assert_eq!</span>(<span class="ident">vec</span>, [<span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>]);
<span class="ident">vec</span>.<span class="ident">insert</span>(<span class="number">4</span>, <span class="number">5</span>);
<span class="macro">assert_eq!</span>(<span class="ident">vec</span>, [<span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>]);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20mut%20vec%20%3D%20vec!%5B1%2C%202%2C%203%5D%3B%0Avec.insert(1%2C%204)%3B%0Aassert_eq!(vec%2C%20%5B1%2C%204%2C%202%2C%203%5D)%3B%0Avec.insert(4%2C%205)%3B%0Aassert_eq!(vec%2C%20%5B1%2C%204%2C%202%2C%203%2C%205%5D)%3B%0A%7D&amp;edition=2018">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.remove" class="method has-srclink"><div class="rightside"><a class="srclink" href="../../src/alloc/vec/mod.rs.html#1386-1414" title="goto source code">[src]</a></div><a href="#method.remove" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.remove" class="fnname">remove</a>(&amp;mut self, index: usize) -&gt; T</h4></div></summary><div class="docblock" xpath="/html[1]/body[1]/section[1]/details[3]/div[1]/details[23]/div[1]" istranslationnode="true" main_mp="YW1sbmc/PnNlYjo7UmBnOUQ9MFAqLy5ndXx/Z3E="><p class="translate-text">移除并返回Vector内 index 位置的元素，将其后的所有元素向左移动。</p><p>Removes and returns the element at position <code>index</code> within the vector,
shifting all elements after it to the left.</p>
<p class="translate-text">注意：因为这会在剩余元素上移动，所以它的最坏情况性能为 O(n)。 如果您不需要保留元素的顺序，请改用 swap_remove。</p><p>Note: Because this shifts over the remaining elements, it has a
worst-case performance of O(n). If you don’t need the order of elements
to be preserved, use <a href="struct.Vec.html#method.swap_remove"><code>swap_remove</code></a> instead.</p>
<h1 id="panics-6" class="section-header"><a href="#panics-6">Panics</a></h1>
<p class="translate-text">如果索引超出范围，则会出现panic。</p><p>Panics if <code>index</code> is out of bounds.</p>
<h1 id="examples-25" class="section-header"><a href="#examples-25">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">v</span> <span class="op">=</span> <span class="macro">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];
<span class="macro">assert_eq!</span>(<span class="ident">v</span>.<span class="ident">remove</span>(<span class="number">1</span>), <span class="number">2</span>);
<span class="macro">assert_eq!</span>(<span class="ident">v</span>, [<span class="number">1</span>, <span class="number">3</span>]);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20mut%20v%20%3D%20vec!%5B1%2C%202%2C%203%5D%3B%0Aassert_eq!(v.remove(1)%2C%202)%3B%0Aassert_eq!(v%2C%20%5B1%2C%203%5D)%3B%0A%7D&amp;edition=2018">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.retain" class="method has-srclink"><div class="rightside"><a class="srclink" href="../../src/alloc/vec/mod.rs.html#1441-1514" title="goto source code">[src]</a></div><a href="#method.retain" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.retain" class="fnname">retain</a>&lt;F&gt;(&amp;mut self, f: F) <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="../../core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(&amp;T) -&gt; bool,&nbsp;</span></h4></div></summary><div class="docblock" xpath="/html[1]/body[1]/section[1]/details[3]/div[1]/details[24]/div[1]" istranslationnode="true" main_mp="YW1sbmc/PnNlYjo7UmBnOUQ9MFAqLy5ndWVxeHo="><p class="translate-text">仅保留谓词指定的元素。</p><p>Retains only the elements specified by the predicate.</p>
<p class="translate-text">换句话说，删除所有元素 e 使得 f(&e) 返回 false。 该方法就地操作，按原始顺序对每个元素仅访问一次，并保留保留元素的顺序。</p><p>In other words, remove all elements <code>e</code> such that <code>f(&amp;e)</code> returns <code>false</code>.
This method operates in place, visiting each element exactly once in the
original order, and preserves the order of the retained elements.</p>
<h1 id="examples-26" class="section-header"><a href="#examples-26">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">vec</span> <span class="op">=</span> <span class="macro">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];
<span class="ident">vec</span>.<span class="ident">retain</span>(<span class="op">|</span><span class="kw-2">&amp;</span><span class="ident">x</span><span class="op">|</span> <span class="ident">x</span> <span class="op">%</span> <span class="number">2</span> <span class="op">=</span><span class="op">=</span> <span class="number">0</span>);
<span class="macro">assert_eq!</span>(<span class="ident">vec</span>, [<span class="number">2</span>, <span class="number">4</span>]);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20mut%20vec%20%3D%20vec!%5B1%2C%202%2C%203%2C%204%5D%3B%0Avec.retain(%7C%26x%7C%20x%20%25%202%20%3D%3D%200)%3B%0Aassert_eq!(vec%2C%20%5B2%2C%204%5D)%3B%0A%7D&amp;edition=2018">Run</a></div>
<p class="translate-text">因为元素按原始顺序仅被访问一次，所以可以使用外部状态来决定保留哪些元素。</p><p>Because the elements are visited exactly once in the original order,
external state may be used to decide which elements to keep.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">vec</span> <span class="op">=</span> <span class="macro">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];
<span class="kw">let</span> <span class="ident">keep</span> <span class="op">=</span> [<span class="bool-val">false</span>, <span class="bool-val">true</span>, <span class="bool-val">true</span>, <span class="bool-val">false</span>, <span class="bool-val">true</span>];
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">iter</span> <span class="op">=</span> <span class="ident">keep</span>.<span class="ident">iter</span>();
<span class="ident">vec</span>.<span class="ident">retain</span>(<span class="op">|</span><span class="kw">_</span><span class="op">|</span> <span class="kw-2">*</span><span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">unwrap</span>());
<span class="macro">assert_eq!</span>(<span class="ident">vec</span>, [<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>]);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20mut%20vec%20%3D%20vec!%5B1%2C%202%2C%203%2C%204%2C%205%5D%3B%0Alet%20keep%20%3D%20%5Bfalse%2C%20true%2C%20true%2C%20false%2C%20true%5D%3B%0Alet%20mut%20iter%20%3D%20keep.iter()%3B%0Avec.retain(%7C_%7C%20*iter.next().unwrap())%3B%0Aassert_eq!(vec%2C%20%5B2%2C%203%2C%205%5D)%3B%0A%7D&amp;edition=2018">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.dedup_by_key" class="method has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.16.0">1.16.0</span><a class="srclink" href="../../src/alloc/vec/mod.rs.html#1532-1538" title="goto source code">[src]</a></div><a href="#method.dedup_by_key" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.dedup_by_key" class="fnname">dedup_by_key</a>&lt;F, K&gt;(&amp;mut self, key: F) <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="../../core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(&amp;mut T) -&gt; K,<br>&nbsp;&nbsp;&nbsp;&nbsp;K: <a class="trait" href="../../core/cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a>,&nbsp;</span></h4></div></summary><div class="docblock" xpath="/html[1]/body[1]/section[1]/details[3]/div[1]/details[25]/div[1]" istranslationnode="true" main_mp="YW1sbmc/PnNlYjo7UmBnOUQ9MFAqLy5xdXVlYUt3bUpLRFk="><p class="translate-text">删除Vector中解析为相同键的所有连续元素，但第一个元素除外。</p><p>Removes all but the first of consecutive elements in the vector that resolve to the same
key.</p>
<p class="translate-text">如果Vector已排序，则会删除所有重复项。</p><p>If the vector is sorted, this removes all duplicates.</p>
<h1 id="examples-27" class="section-header"><a href="#examples-27">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">vec</span> <span class="op">=</span> <span class="macro">vec!</span>[<span class="number">10</span>, <span class="number">20</span>, <span class="number">21</span>, <span class="number">30</span>, <span class="number">20</span>];

<span class="ident">vec</span>.<span class="ident">dedup_by_key</span>(<span class="op">|</span><span class="ident">i</span><span class="op">|</span> <span class="kw-2">*</span><span class="ident">i</span> <span class="op">/</span> <span class="number">10</span>);

<span class="macro">assert_eq!</span>(<span class="ident">vec</span>, [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">20</span>]);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20mut%20vec%20%3D%20vec!%5B10%2C%2020%2C%2021%2C%2030%2C%2020%5D%3B%0A%0Avec.dedup_by_key(%7Ci%7C%20*i%20%2F%2010)%3B%0A%0Aassert_eq!(vec%2C%20%5B10%2C%2020%2C%2030%2C%2020%5D)%3B%0A%7D&amp;edition=2018">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.dedup_by" class="method has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.16.0">1.16.0</span><a class="srclink" href="../../src/alloc/vec/mod.rs.html#1559-1652" title="goto source code">[src]</a></div><a href="#method.dedup_by" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.dedup_by" class="fnname">dedup_by</a>&lt;F&gt;(&amp;mut self, same_bucket: F) <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="../../core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(&amp;mut T, &amp;mut T) -&gt; bool,&nbsp;</span></h4></div></summary><div class="docblock" xpath="/html[1]/body[1]/section[1]/details[3]/div[1]/details[26]/div[1]" istranslationnode="true" main_mp="YW1sbmc/PnNlYjo7UmBnOUQ9MFAqLy5xdXVlYUt3bQ=="><p class="translate-text">删除满足给定等式关系的Vector中除了第一个连续元素之外的所有元素。</p><p>Removes all but the first of consecutive elements in the vector satisfying a given equality
relation.</p>
<p class="translate-text">same_bucket 函数传递对Vector中两个元素的引用，并且必须确定元素比较是否相等。 元素的传递顺序与它们在切片中的顺序相反，因此如果 same_bucket(a, b) 返回 true，则删除 a。</p><p>The <code>same_bucket</code> function is passed references to two elements from the vector and
must determine if the elements compare equal. The elements are passed in opposite order
from their order in the slice, so if <code>same_bucket(a, b)</code> returns <code>true</code>, <code>a</code> is removed.</p>
<p class="translate-text">如果Vector已排序，则会删除所有重复项。</p><p>If the vector is sorted, this removes all duplicates.</p>
<h1 id="examples-28" class="section-header"><a href="#examples-28">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">vec</span> <span class="op">=</span> <span class="macro">vec!</span>[<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>, <span class="string">&quot;Bar&quot;</span>, <span class="string">&quot;baz&quot;</span>, <span class="string">&quot;bar&quot;</span>];

<span class="ident">vec</span>.<span class="ident">dedup_by</span>(<span class="op">|</span><span class="ident">a</span>, <span class="ident">b</span><span class="op">|</span> <span class="ident">a</span>.<span class="ident">eq_ignore_ascii_case</span>(<span class="ident">b</span>));

<span class="macro">assert_eq!</span>(<span class="ident">vec</span>, [<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>, <span class="string">&quot;baz&quot;</span>, <span class="string">&quot;bar&quot;</span>]);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20mut%20vec%20%3D%20vec!%5B%22foo%22%2C%20%22bar%22%2C%20%22Bar%22%2C%20%22baz%22%2C%20%22bar%22%5D%3B%0A%0Avec.dedup_by(%7Ca%2C%20b%7C%20a.eq_ignore_ascii_case(b))%3B%0A%0Aassert_eq!(vec%2C%20%5B%22foo%22%2C%20%22bar%22%2C%20%22baz%22%2C%20%22bar%22%5D)%3B%0A%7D&amp;edition=2018">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.push" class="method has-srclink"><div class="rightside"><a class="srclink" href="../../src/alloc/vec/mod.rs.html#1670-1681" title="goto source code">[src]</a></div><a href="#method.push" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.push" class="fnname">push</a>(&amp;mut self, value: T)</h4></div></summary><div class="docblock" xpath="/html[1]/body[1]/section[1]/details[3]/div[1]/details[27]/div[1]" istranslationnode="true" main_mp="YW1sbmc/PnNlYjo7UmBnOUQ9MFAqLy5lZWJ4"><p class="translate-text">将元素附加到集合的后面。</p><p>Appends an element to the back of a collection.</p>
<h1 id="panics-7" class="section-header"><a href="#panics-7">Panics</a></h1>
<p class="translate-text">如果新容量超过 isize::MAX 字节，则会出现panic。</p><p>Panics if the new capacity exceeds <code>isize::MAX</code> bytes.</p>
<h1 id="examples-29" class="section-header"><a href="#examples-29">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">vec</span> <span class="op">=</span> <span class="macro">vec!</span>[<span class="number">1</span>, <span class="number">2</span>];
<span class="ident">vec</span>.<span class="ident">push</span>(<span class="number">3</span>);
<span class="macro">assert_eq!</span>(<span class="ident">vec</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20mut%20vec%20%3D%20vec!%5B1%2C%202%5D%3B%0Avec.push(3)%3B%0Aassert_eq!(vec%2C%20%5B1%2C%202%2C%203%5D)%3B%0A%7D&amp;edition=2018">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.pop" class="method has-srclink"><div class="rightside"><a class="srclink" href="../../src/alloc/vec/mod.rs.html#1695-1704" title="goto source code">[src]</a></div><a href="#method.pop" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.pop" class="fnname">pop</a>(&amp;mut self) -&gt; <a class="enum" href="../../core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;T&gt;</h4></div></summary><div class="docblock" xpath="/html[1]/body[1]/section[1]/details[3]/div[1]/details[28]/div[1]" istranslationnode="true" main_mp="YW1sbmc/PnNlYjo7UmBnOUQ9MFAqLy5lf2E="><p class="translate-text">从Vector中移除最后一个元素并返回它，如果为空则返回 None。</p><p>Removes the last element from a vector and returns it, or <a href="../../core/option/enum.Option.html#variant.None" title="None"><code>None</code></a> if it
is empty.</p>
<h1 id="examples-30" class="section-header"><a href="#examples-30">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">vec</span> <span class="op">=</span> <span class="macro">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];
<span class="macro">assert_eq!</span>(<span class="ident">vec</span>.<span class="ident">pop</span>(), <span class="prelude-val">Some</span>(<span class="number">3</span>));
<span class="macro">assert_eq!</span>(<span class="ident">vec</span>, [<span class="number">1</span>, <span class="number">2</span>]);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20mut%20vec%20%3D%20vec!%5B1%2C%202%2C%203%5D%3B%0Aassert_eq!(vec.pop()%2C%20Some(3))%3B%0Aassert_eq!(vec%2C%20%5B1%2C%202%5D)%3B%0A%7D&amp;edition=2018">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.append" class="method has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.4.0">1.4.0</span><a class="srclink" href="../../src/alloc/vec/mod.rs.html#1724-1729" title="goto source code">[src]</a></div><a href="#method.append" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.append" class="fnname">append</a>(&amp;mut self, other: &amp;mut Self)</h4></div></summary><div class="docblock" xpath="/html[1]/body[1]/section[1]/details[3]/div[1]/details[29]/div[1]" istranslationnode="true" main_mp="YW1sbmc/PnNlYjo7UmBnOUQ9MFAqLy50YGF1f3A="><p class="translate-text">将他者的所有元素移入自我，让他者为空。</p><p>Moves all the elements of <code>other</code> into <code>Self</code>, leaving <code>other</code> empty.</p>
<h1 id="panics-8" class="section-header"><a href="#panics-8">Panics</a></h1>
<p class="translate-text">如果Vector中的元素数量溢出使用大小，则会出现panic。</p><p>Panics if the number of elements in the vector overflows a <code>usize</code>.</p>
<h1 id="examples-31" class="section-header"><a href="#examples-31">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">vec</span> <span class="op">=</span> <span class="macro">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">vec2</span> <span class="op">=</span> <span class="macro">vec!</span>[<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];
<span class="ident">vec</span>.<span class="ident">append</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">vec2</span>);
<span class="macro">assert_eq!</span>(<span class="ident">vec</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]);
<span class="macro">assert_eq!</span>(<span class="ident">vec2</span>, []);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20mut%20vec%20%3D%20vec!%5B1%2C%202%2C%203%5D%3B%0Alet%20mut%20vec2%20%3D%20vec!%5B4%2C%205%2C%206%5D%3B%0Avec.append(%26mut%20vec2)%3B%0Aassert_eq!(vec%2C%20%5B1%2C%202%2C%203%2C%204%2C%205%2C%206%5D)%3B%0Aassert_eq!(vec2%2C%20%5B%5D)%3B%0A%7D&amp;edition=2018">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.drain" class="method has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.6.0">1.6.0</span><a class="srclink" href="../../src/alloc/vec/mod.rs.html#1768-1798" title="goto source code">[src]</a></div><a href="#method.drain" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.drain" class="fnname">drain</a>&lt;R&gt;(&amp;mut self, range: R) -&gt; <a class="struct" href="struct.Drain.html" title="struct alloc::vec::Drain">Drain</a>&lt;'_, T, A&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><div class="notable">Notable traits for <a class="struct" href="struct.Drain.html" title="struct alloc::vec::Drain">Drain</a>&lt;'_, T, A&gt;</div><code class="content"><span class="where fmt-newline">impl&lt;T, A:&nbsp;<a class="trait" href="../alloc/trait.Allocator.html" title="trait alloc::alloc::Allocator">Allocator</a>&gt; <a class="trait" href="../../core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="struct.Drain.html" title="struct alloc::vec::Drain">Drain</a>&lt;'_, T, A&gt;</span><span class="where fmt-newline">    type <a href="../../core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="type">Item</a> = T;</span></code></span></div></span></span> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;R: <a class="trait" href="../../core/ops/range/trait.RangeBounds.html" title="trait core::ops::range::RangeBounds">RangeBounds</a>&lt;usize&gt;,&nbsp;</span></h4></div></summary><div class="docblock" xpath="/html[1]/body[1]/section[1]/details[3]/div[1]/details[30]/div[1]" istranslationnode="true" main_mp="YW1sbmc/PnNlYjo7UmBnOUQ9MFAqLy5xYnB5fw=="><p class="translate-text">创建一个排水迭代器，该迭代器删除Vector中的指定范围并产生删除的项目。</p><p>Creates a draining iterator that removes the specified range in the vector
and yields the removed items.</p>
<p class="translate-text">当迭代器被删除时，范围内的所有元素都会从Vector中删除，即使迭代器没有完全消耗。 如果没有删除迭代器（例如使用 mem::forget），则未指定删除了多少元素。</p><p>When the iterator <strong>is</strong> dropped, all elements in the range are removed
from the vector, even if the iterator was not fully consumed. If the
iterator <strong>is not</strong> dropped (with <a href="../../core/mem/fn.forget.html" title="mem::forget"><code>mem::forget</code></a> for example), it is
unspecified how many elements are removed.</p>
<h1 id="panics-9" class="section-header"><a href="#panics-9">Panics</a></h1>
<p class="translate-text">如果起点大于终点或终点大于Vector的长度，则会出现panic。</p><p>Panics if the starting point is greater than the end point or if
the end point is greater than the length of the vector.</p>
<h1 id="examples-32" class="section-header"><a href="#examples-32">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">v</span> <span class="op">=</span> <span class="macro">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];
<span class="kw">let</span> <span class="ident">u</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw">_</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">v</span>.<span class="ident">drain</span>(<span class="number">1</span>..).<span class="ident">collect</span>();
<span class="macro">assert_eq!</span>(<span class="ident">v</span>, <span class="kw-2">&amp;</span>[<span class="number">1</span>]);
<span class="macro">assert_eq!</span>(<span class="ident">u</span>, <span class="kw-2">&amp;</span>[<span class="number">2</span>, <span class="number">3</span>]);

<span class="comment">// A full range clears the vector</span>
<span class="ident">v</span>.<span class="ident">drain</span>(..);
<span class="macro">assert_eq!</span>(<span class="ident">v</span>, <span class="kw-2">&amp;</span>[]);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20mut%20v%20%3D%20vec!%5B1%2C%202%2C%203%5D%3B%0Alet%20u%3A%20Vec%3C_%3E%20%3D%20v.drain(1..).collect()%3B%0Aassert_eq!(v%2C%20%26%5B1%5D)%3B%0Aassert_eq!(u%2C%20%26%5B2%2C%203%5D)%3B%0A%0A%2F%2F%20A%20full%20range%20clears%20the%20vector%0Av.drain(..)%3B%0Aassert_eq!(v%2C%20%26%5B%5D)%3B%0A%7D&amp;edition=2018">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.clear" class="method has-srclink"><div class="rightside"><a class="srclink" href="../../src/alloc/vec/mod.rs.html#1816-1818" title="goto source code">[src]</a></div><a href="#method.clear" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.clear" class="fnname">clear</a>(&amp;mut self)</h4></div></summary><div class="docblock" xpath="/html[1]/body[1]/section[1]/details[3]/div[1]/details[31]/div[1]" istranslationnode="true" main_mp="YW1sbmc/PnNlYjo7UmBnOUQ9MFAqLy52fHRxYw=="><p class="translate-text">清除Vector，删除所有值。</p><p>Clears the vector, removing all values.</p>
<p class="translate-text">请注意，此方法对Vector的分配容量没有影响。</p><p>Note that this method has no effect on the allocated capacity
of the vector.</p>
<h1 id="examples-33" class="section-header"><a href="#examples-33">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">v</span> <span class="op">=</span> <span class="macro">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];

<span class="ident">v</span>.<span class="ident">clear</span>();

<span class="macro">assert!</span>(<span class="ident">v</span>.<span class="ident">is_empty</span>());</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20mut%20v%20%3D%20vec!%5B1%2C%202%2C%203%5D%3B%0A%0Av.clear()%3B%0A%0Aassert!(v.is_empty())%3B%0A%7D&amp;edition=2018">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.len" class="method has-srclink"><div class="rightside"><a class="srclink" href="../../src/alloc/vec/mod.rs.html#1831-1833" title="goto source code">[src]</a></div><a href="#method.len" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.len" class="fnname">len</a>(&amp;self) -&gt; usize</h4></div></summary><div class="docblock" xpath="/html[1]/body[1]/section[1]/details[3]/div[1]/details[32]/div[1]" istranslationnode="true" main_mp="YW1sbmc/PnNlYjo7UmBnOUQ9MFAqLy55dX8="><p class="translate-text">返回Vector中元素的数量，也称为“长度”。</p><p>Returns the number of elements in the vector, also referred to
as its ‘length’.</p>
<h1 id="examples-34" class="section-header"><a href="#examples-34">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">a</span> <span class="op">=</span> <span class="macro">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];
<span class="macro">assert_eq!</span>(<span class="ident">a</span>.<span class="ident">len</span>(), <span class="number">3</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20a%20%3D%20vec!%5B1%2C%202%2C%203%5D%3B%0Aassert_eq!(a.len()%2C%203)%3B%0A%7D&amp;edition=2018">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.is_empty" class="method has-srclink"><div class="rightside"><a class="srclink" href="../../src/alloc/vec/mod.rs.html#1847-1849" title="goto source code">[src]</a></div><a href="#method.is_empty" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.is_empty" class="fnname">is_empty</a>(&amp;self) -&gt; bool</h4></div></summary><div class="docblock" xpath="/html[1]/body[1]/section[1]/details[3]/div[1]/details[33]/div[1]" istranslationnode="true" main_mp="YW1sbmc/PnNlYjo7UmBnOUQ9MFAqLy58Y051fGRhbQ=="><p class="translate-text">如果Vector不包含任何元素，则返回 true。</p><p>Returns <code>true</code> if the vector contains no elements.</p>
<h1 id="examples-35" class="section-header"><a href="#examples-35">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">v</span> <span class="op">=</span> <span class="ident">Vec::new</span>();
<span class="macro">assert!</span>(<span class="ident">v</span>.<span class="ident">is_empty</span>());

<span class="ident">v</span>.<span class="ident">push</span>(<span class="number">1</span>);
<span class="macro">assert!</span>(<span class="op">!</span><span class="ident">v</span>.<span class="ident">is_empty</span>());</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20mut%20v%20%3D%20Vec%3A%3Anew()%3B%0Aassert!(v.is_empty())%3B%0A%0Av.push(1)%3B%0Aassert!(!v.is_empty())%3B%0A%7D&amp;edition=2018">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.split_off" class="method has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.4.0">1.4.0</span><a class="srclink" href="../../src/alloc/vec/mod.rs.html#1873-1906" title="goto source code">[src]</a></div><a href="#method.split_off" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.split_off" class="fnname">split_off</a>(&amp;mut self, at: usize) -&gt; Self <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;A: <a class="trait" href="../../core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,&nbsp;</span></h4></div></summary><div class="docblock" xpath="/html[1]/body[1]/section[1]/details[3]/div[1]/details[34]/div[1]" istranslationnode="true" main_mp="YW1sbmc/PnNlYjo7UmBnOUQ9MFAqLy5mYH15ZUt6cnM="><p class="translate-text">在给定索引处将集合拆分为两个。</p><p>Splits the collection into two at the given index.</p>
<p class="translate-text">返回一个新分配的Vector，其中包含 [at, len) 范围内的元素。 调用后，原始Vector将保留包含元素 [0, at) 且其先前容量不变。</p><p>Returns a newly allocated vector containing the elements in the range
<code>[at, len)</code>. After the call, the original vector will be left containing
the elements <code>[0, at)</code> with its previous capacity unchanged.</p>
<h1 id="panics-10" class="section-header"><a href="#panics-10">Panics</a></h1>
<p class="translate-text">panic如果在> len。</p><p>Panics if <code>at &gt; len</code>.</p>
<h1 id="examples-36" class="section-header"><a href="#examples-36">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">vec</span> <span class="op">=</span> <span class="macro">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];
<span class="kw">let</span> <span class="ident">vec2</span> <span class="op">=</span> <span class="ident">vec</span>.<span class="ident">split_off</span>(<span class="number">1</span>);
<span class="macro">assert_eq!</span>(<span class="ident">vec</span>, [<span class="number">1</span>]);
<span class="macro">assert_eq!</span>(<span class="ident">vec2</span>, [<span class="number">2</span>, <span class="number">3</span>]);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20mut%20vec%20%3D%20vec!%5B1%2C%202%2C%203%5D%3B%0Alet%20vec2%20%3D%20vec.split_off(1)%3B%0Aassert_eq!(vec%2C%20%5B1%5D)%3B%0Aassert_eq!(vec2%2C%20%5B2%2C%203%5D)%3B%0A%7D&amp;edition=2018">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.resize_with" class="method has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.33.0">1.33.0</span><a class="srclink" href="../../src/alloc/vec/mod.rs.html#1936-1946" title="goto source code">[src]</a></div><a href="#method.resize_with" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.resize_with" class="fnname">resize_with</a>&lt;F&gt;(&amp;mut self, new_len: usize, f: F) <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="../../core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>() -&gt; T,&nbsp;</span></h4></div></summary><div class="docblock" xpath="/html[1]/body[1]/section[1]/details[3]/div[1]/details[35]/div[1]" istranslationnode="true" main_mp="YW1sbmc/PnNlYjo7UmBnOUQ9MFAqLy5ndWJ5a3FKY3xUSQ=="><p class="translate-text">就地调整 Vec 的大小，使 len 等于 new_len。</p><p>Resizes the <code>Vec</code> in-place so that <code>len</code> is equal to <code>new_len</code>.</p>
<p class="translate-text">如果 new_len 大于 len，则 Vec 将扩展差异，每个额外的槽都填充调用闭包 f 的结果。 f 的返回值将按照它们生成的顺序在 Vec 中结束。</p><p>If <code>new_len</code> is greater than <code>len</code>, the <code>Vec</code> is extended by the
difference, with each additional slot filled with the result of
calling the closure <code>f</code>. The return values from <code>f</code> will end up
in the <code>Vec</code> in the order they have been generated.</p>
<p class="translate-text">如果 new_len 小于 len，则简单地截断 Vec。</p><p>If <code>new_len</code> is less than <code>len</code>, the <code>Vec</code> is simply truncated.</p>
<p class="translate-text">此方法使用闭包在每次推送时创建新值。 如果您希望克隆给定值，请使用 Vec::resize。 如果你想使用 Default trait 来生成值，你可以传递 Default::default 作为第二个参数。</p><p>This method uses a closure to create new values on every push. If
you’d rather <a href="../../core/clone/trait.Clone.html" title="Clone"><code>Clone</code></a> a given value, use <a href="struct.Vec.html#method.resize" title="Vec::resize"><code>Vec::resize</code></a>. If you
want to use the <a href="../../core/default/trait.Default.html" title="Default"><code>Default</code></a> trait to generate values, you can
pass <a href="../../core/default/trait.Default.html#tymethod.default" title="Default::default"><code>Default::default</code></a> as the second argument.</p>
<h1 id="examples-37" class="section-header"><a href="#examples-37">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">vec</span> <span class="op">=</span> <span class="macro">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];
<span class="ident">vec</span>.<span class="ident">resize_with</span>(<span class="number">5</span>, <span class="ident">Default::default</span>);
<span class="macro">assert_eq!</span>(<span class="ident">vec</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">0</span>]);

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">vec</span> <span class="op">=</span> <span class="macro">vec!</span>[];
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">p</span> <span class="op">=</span> <span class="number">1</span>;
<span class="ident">vec</span>.<span class="ident">resize_with</span>(<span class="number">4</span>, <span class="op">|</span><span class="op">|</span> { <span class="ident">p</span> <span class="kw-2">*</span><span class="op">=</span> <span class="number">2</span>; <span class="ident">p</span> });
<span class="macro">assert_eq!</span>(<span class="ident">vec</span>, [<span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">16</span>]);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20mut%20vec%20%3D%20vec!%5B1%2C%202%2C%203%5D%3B%0Avec.resize_with(5%2C%20Default%3A%3Adefault)%3B%0Aassert_eq!(vec%2C%20%5B1%2C%202%2C%203%2C%200%2C%200%5D)%3B%0A%0Alet%20mut%20vec%20%3D%20vec!%5B%5D%3B%0Alet%20mut%20p%20%3D%201%3B%0Avec.resize_with(4%2C%20%7C%7C%20%7B%20p%20*%3D%202%3B%20p%20%7D)%3B%0Aassert_eq!(vec%2C%20%5B2%2C%204%2C%208%2C%2016%5D)%3B%0A%7D&amp;edition=2018">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.leak" class="method has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.47.0">1.47.0</span><a class="srclink" href="../../src/alloc/vec/mod.rs.html#1973-1978" title="goto source code">[src]</a></div><a href="#method.leak" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.leak" class="fnname">leak</a>&lt;'a&gt;(self) -&gt; &amp;'a mut [T] <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;A: 'a,&nbsp;</span></h4></div></summary><div class="docblock" xpath="/html[1]/body[1]/section[1]/details[3]/div[1]/details[36]/div[1]" istranslationnode="true" main_mp="YW1sbmc/PnNlYjo7UmBnOUQ9MFAqLy55dXB7"><p class="translate-text">使用并泄漏 Vec，返回对内容的可变引用，&'a mut [T]。 请注意，类型 T 必须比选择的生命周期 'a. 如果该类型只有静态引用，或者根本没有，那么这可以选择为“静态”。</p><p>Consumes and leaks the <code>Vec</code>, returning a mutable reference to the contents,
<code>&amp;'a mut [T]</code>. Note that the type <code>T</code> must outlive the chosen lifetime
<code>'a</code>. If the type has only static references, or none at all, then this
may be chosen to be <code>'static</code>.</p>
<p class="translate-text">该功能与 Box 上的泄漏功能类似，只是无法恢复泄漏的内存。</p><p>This function is similar to the <a href="../boxed/struct.Box.html#method.leak" title="Box::leak"><code>leak</code></a> function on <a href="../boxed/struct.Box.html" title="Box"><code>Box</code></a>
except that there is no way to recover the leaked memory.</p>
<p class="translate-text">此函数主要用于在程序的剩余生命周期中存在的数据。 删除返回的引用将导致内存泄漏。</p><p>This function is mainly useful for data that lives for the remainder of
the program’s life. Dropping the returned reference will cause a memory
leak.</p>
<h1 id="examples-38" class="section-header"><a href="#examples-38">Examples</a></h1>
<p class="translate-text">简单用法：</p><p>Simple usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="macro">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];
<span class="kw">let</span> <span class="ident">static_ref</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;static</span> <span class="kw-2">mut</span> [<span class="ident">usize</span>] <span class="op">=</span> <span class="ident">x</span>.<span class="ident">leak</span>();
<span class="ident">static_ref</span>[<span class="number">0</span>] <span class="op">+</span><span class="op">=</span> <span class="number">1</span>;
<span class="macro">assert_eq!</span>(<span class="ident">static_ref</span>, <span class="kw-2">&amp;</span>[<span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>]);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20x%20%3D%20vec!%5B1%2C%202%2C%203%5D%3B%0Alet%20static_ref%3A%20%26'static%20mut%20%5Busize%5D%20%3D%20x.leak()%3B%0Astatic_ref%5B0%5D%20%2B%3D%201%3B%0Aassert_eq!(static_ref%2C%20%26%5B2%2C%202%2C%203%5D)%3B%0A%7D&amp;edition=2018">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.spare_capacity_mut" class="method has-srclink"><div class="rightside"><a class="srclink" href="../../src/alloc/vec/mod.rs.html#2012-2022" title="goto source code">[src]</a></div><a href="#method.spare_capacity_mut" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.spare_capacity_mut" class="fnname">spare_capacity_mut</a>(&amp;mut self) -&gt; &amp;mut [<a class="union" href="../../core/mem/maybe_uninit/union.MaybeUninit.html" title="union core::mem::maybe_uninit::MaybeUninit">MaybeUninit</a>&lt;T&gt;]</h4></div><div class="item-info"><div class="stab unstable"><span class="emoji">🔬</span> This is a nightly-only experimental API. (<code>vec_spare_capacity</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/75017">#75017</a>)</div></div></summary><div class="docblock" xpath="/html[1]/body[1]/section[1]/details[3]/div[1]/details[37]/div[1]" istranslationnode="true" main_mp="YW1sbmc/PnNlYjo7UmBnOUQ9MFAqLy5mYHBidEt2dWVBQklVXXpJUFQ="><p class="translate-text">将Vector的剩余备用容量作为 MaybeUninit<t> 的切片返回。</t></p><p>Returns the remaining spare capacity of the vector as a slice of
<code>MaybeUninit&lt;T&gt;</code>.</p>
<p class="translate-text">返回的切片可用于在使用 set_len 方法将数据标记为已初始化之前用数据填充Vector（例如，通过从文件中读取）。</p><p>The returned slice can be used to fill the vector with data (e.g. by
reading from a file) before marking the data as initialized using the
<a href="struct.Vec.html#method.set_len"><code>set_len</code></a> method.</p>
<h1 id="examples-39" class="section-header"><a href="#examples-39">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attribute">#![<span class="ident">feature</span>(<span class="ident">vec_spare_capacity</span>, <span class="ident">maybe_uninit_extra</span>)]</span>

<span class="comment">// Allocate vector big enough for 10 elements.</span>
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">v</span> <span class="op">=</span> <span class="ident">Vec::with_capacity</span>(<span class="number">10</span>);

<span class="comment">// Fill in the first 3 elements.</span>
<span class="kw">let</span> <span class="ident">uninit</span> <span class="op">=</span> <span class="ident">v</span>.<span class="ident">spare_capacity_mut</span>();
<span class="ident">uninit</span>[<span class="number">0</span>].<span class="ident">write</span>(<span class="number">0</span>);
<span class="ident">uninit</span>[<span class="number">1</span>].<span class="ident">write</span>(<span class="number">1</span>);
<span class="ident">uninit</span>[<span class="number">2</span>].<span class="ident">write</span>(<span class="number">2</span>);

<span class="comment">// Mark the first 3 elements of the vector as being initialized.</span>
<span class="kw">unsafe</span> {
    <span class="ident">v</span>.<span class="ident">set_len</span>(<span class="number">3</span>);
}

<span class="macro">assert_eq!</span>(<span class="kw-2">&amp;</span><span class="ident">v</span>, <span class="kw-2">&amp;</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(vec_spare_capacity%2C%20maybe_uninit_extra)%5D%0A%0A%2F%2F%20Allocate%20vector%20big%20enough%20for%2010%20elements.%0Afn%20main()%20%7B%0Alet%20mut%20v%20%3D%20Vec%3A%3Awith_capacity(10)%3B%0A%0A%2F%2F%20Fill%20in%20the%20first%203%20elements.%0Alet%20uninit%20%3D%20v.spare_capacity_mut()%3B%0Auninit%5B0%5D.write(0)%3B%0Auninit%5B1%5D.write(1)%3B%0Auninit%5B2%5D.write(2)%3B%0A%0A%2F%2F%20Mark%20the%20first%203%20elements%20of%20the%20vector%20as%20being%20initialized.%0Aunsafe%20%7B%0A%20%20%20%20v.set_len(3)%3B%0A%7D%0A%0Aassert_eq!(%26v%2C%20%26%5B0%2C%201%2C%202%5D)%3B%0A%7D&amp;version=nightly&amp;edition=2018">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.split_at_spare_mut" class="method has-srclink"><div class="rightside"><a class="srclink" href="../../src/alloc/vec/mod.rs.html#2077-2082" title="goto source code">[src]</a></div><a href="#method.split_at_spare_mut" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.split_at_spare_mut" class="fnname">split_at_spare_mut</a>(&amp;mut self) -&gt; (&amp;mut [T], &amp;mut [<a class="union" href="../../core/mem/maybe_uninit/union.MaybeUninit.html" title="union core::mem::maybe_uninit::MaybeUninit">MaybeUninit</a>&lt;T&gt;])</h4></div><div class="item-info"><div class="stab unstable"><span class="emoji">🔬</span> This is a nightly-only experimental API. (<code>vec_split_at_spare</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/81944">#81944</a>)</div></div></summary><div class="docblock" xpath="/html[1]/body[1]/section[1]/details[3]/div[1]/details[38]/div[1]" istranslationnode="true" main_mp="YW1sbmc/PnNlYjo7UmBnOUQ9MFAqLy5mYH15ZUt0YEpTUUFTQXpJUFQ="><p class="translate-text">将Vector内容作为 T 的切片返回，并将Vector的剩余备用容量作为 MaybeUninit<t> 的切片返回。</t></p><p>Returns vector content as a slice of <code>T</code>, along with the remaining spare
capacity of the vector as a slice of <code>MaybeUninit&lt;T&gt;</code>.</p>
<p class="translate-text">返回的备用容量切片可用于在使用 set_len 方法将数据标记为已初始化之前用数据填充Vector（例如，通过从文件中读取）。</p><p>The returned spare capacity slice can be used to fill the vector with data
(e.g. by reading from a file) before marking the data as initialized using
the <a href="struct.Vec.html#method.set_len"><code>set_len</code></a> method.</p>
<p class="translate-text">请注意，这是一个低级 API，应谨慎使用以进行优化。 如果您需要将数据附加到 Vec，您可以使用 push、extend、extend_from_slice、extend_from_within、insert、append、resize 或 resize_with，具体取决于您的具体需求。</p><p>Note that this is a low-level API, which should be used with care for
optimization purposes. If you need to append data to a <code>Vec</code>
you can use <a href="struct.Vec.html#method.push"><code>push</code></a>, <a href="struct.Vec.html#method.extend"><code>extend</code></a>, <a href="struct.Vec.html#method.extend_from_slice"><code>extend_from_slice</code></a>,
<a href="struct.Vec.html#method.extend_from_within"><code>extend_from_within</code></a>, <a href="struct.Vec.html#method.insert"><code>insert</code></a>, <a href="struct.Vec.html#method.append"><code>append</code></a>, <a href="struct.Vec.html#method.resize"><code>resize</code></a> or
<a href="struct.Vec.html#method.resize_with"><code>resize_with</code></a>, depending on your exact needs.</p>
<h1 id="examples-40" class="section-header"><a href="#examples-40">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attribute">#![<span class="ident">feature</span>(<span class="ident">vec_split_at_spare</span>, <span class="ident">maybe_uninit_extra</span>)]</span>

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">v</span> <span class="op">=</span> <span class="macro">vec!</span>[<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>];

<span class="comment">// Reserve additional space big enough for 10 elements.</span>
<span class="ident">v</span>.<span class="ident">reserve</span>(<span class="number">10</span>);

<span class="kw">let</span> (<span class="ident">init</span>, <span class="ident">uninit</span>) <span class="op">=</span> <span class="ident">v</span>.<span class="ident">split_at_spare_mut</span>();
<span class="kw">let</span> <span class="ident">sum</span> <span class="op">=</span> <span class="ident">init</span>.<span class="ident">iter</span>().<span class="ident">copied</span>().<span class="ident">sum</span>::<span class="op">&lt;</span><span class="ident">u32</span><span class="op">&gt;</span>();

<span class="comment">// Fill in the next 4 elements.</span>
<span class="ident">uninit</span>[<span class="number">0</span>].<span class="ident">write</span>(<span class="ident">sum</span>);
<span class="ident">uninit</span>[<span class="number">1</span>].<span class="ident">write</span>(<span class="ident">sum</span> <span class="op">*</span> <span class="number">2</span>);
<span class="ident">uninit</span>[<span class="number">2</span>].<span class="ident">write</span>(<span class="ident">sum</span> <span class="op">*</span> <span class="number">3</span>);
<span class="ident">uninit</span>[<span class="number">3</span>].<span class="ident">write</span>(<span class="ident">sum</span> <span class="op">*</span> <span class="number">4</span>);

<span class="comment">// Mark the 4 elements of the vector as being initialized.</span>
<span class="kw">unsafe</span> {
    <span class="kw">let</span> <span class="ident">len</span> <span class="op">=</span> <span class="ident">v</span>.<span class="ident">len</span>();
    <span class="ident">v</span>.<span class="ident">set_len</span>(<span class="ident">len</span> <span class="op">+</span> <span class="number">4</span>);
}

<span class="macro">assert_eq!</span>(<span class="kw-2">&amp;</span><span class="ident">v</span>, <span class="kw-2">&amp;</span>[<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">12</span>, <span class="number">16</span>]);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(vec_split_at_spare%2C%20maybe_uninit_extra)%5D%0A%0Afn%20main()%20%7B%0Alet%20mut%20v%20%3D%20vec!%5B1%2C%201%2C%202%5D%3B%0A%0A%2F%2F%20Reserve%20additional%20space%20big%20enough%20for%2010%20elements.%0Av.reserve(10)%3B%0A%0Alet%20(init%2C%20uninit)%20%3D%20v.split_at_spare_mut()%3B%0Alet%20sum%20%3D%20init.iter().copied().sum%3A%3A%3Cu32%3E()%3B%0A%0A%2F%2F%20Fill%20in%20the%20next%204%20elements.%0Auninit%5B0%5D.write(sum)%3B%0Auninit%5B1%5D.write(sum%20*%202)%3B%0Auninit%5B2%5D.write(sum%20*%203)%3B%0Auninit%5B3%5D.write(sum%20*%204)%3B%0A%0A%2F%2F%20Mark%20the%204%20elements%20of%20the%20vector%20as%20being%20initialized.%0Aunsafe%20%7B%0A%20%20%20%20let%20len%20%3D%20v.len()%3B%0A%20%20%20%20v.set_len(len%20%2B%204)%3B%0A%7D%0A%0Aassert_eq!(%26v%2C%20%26%5B1%2C%201%2C%202%2C%204%2C%208%2C%2012%2C%2016%5D)%3B%0A%7D&amp;version=nightly&amp;edition=2018">Run</a></div>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open=""><summary><div id="impl-2" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../../src/alloc/vec/mod.rs.html#2106-2197" title="goto source code">[src]</a></div><a href="#impl-2" class="anchor"></a><h3 class="code-header in-band">impl&lt;T:&nbsp;<a class="trait" href="../../core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>, A:&nbsp;<a class="trait" href="../alloc/trait.Allocator.html" title="trait alloc::alloc::Allocator">Allocator</a>&gt; <a class="struct" href="struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;T, A&gt;</h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.resize" class="method has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.5.0">1.5.0</span><a class="srclink" href="../../src/alloc/vec/mod.rs.html#2131-2139" title="goto source code">[src]</a></div><a href="#method.resize" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.resize" class="fnname">resize</a>(&amp;mut self, new_len: usize, value: T)</h4></div></summary><div class="docblock" xpath="/html[1]/body[1]/section[1]/details[4]/div[1]/details[1]/div[1]" istranslationnode="true" main_mp="YW1sbmc/PnNlYjo7UmBnOUQ9MFAqLy5ndWJ5a3E="><p class="translate-text">就地调整 Vec 的大小，使 len 等于 new_len。</p><p>Resizes the <code>Vec</code> in-place so that <code>len</code> is equal to <code>new_len</code>.</p>
<p class="translate-text">如果 new_len 大于 len，则 Vec 由差值扩展，每个额外的插槽都填充值。 如果 new_len 小于 len，则简单地截断 Vec。</p><p>If <code>new_len</code> is greater than <code>len</code>, the <code>Vec</code> is extended by the
difference, with each additional slot filled with <code>value</code>.
If <code>new_len</code> is less than <code>len</code>, the <code>Vec</code> is simply truncated.</p>
<p class="translate-text">此方法需要 T 实现 Clone，以便能够克隆传递的值。 如果您需要更大的灵活性（或者想要依赖 Default 而不是 Clone），请使用 Vec::resize_with。</p><p>This method requires <code>T</code> to implement <a href="../../core/clone/trait.Clone.html" title="Clone"><code>Clone</code></a>,
in order to be able to clone the passed value.
If you need more flexibility (or want to rely on <a href="../../core/default/trait.Default.html" title="Default"><code>Default</code></a> instead of
<a href="../../core/clone/trait.Clone.html" title="Clone"><code>Clone</code></a>), use <a href="struct.Vec.html#method.resize_with" title="Vec::resize_with"><code>Vec::resize_with</code></a>.</p>
<h1 id="examples-41" class="section-header"><a href="#examples-41">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">vec</span> <span class="op">=</span> <span class="macro">vec!</span>[<span class="string">&quot;hello&quot;</span>];
<span class="ident">vec</span>.<span class="ident">resize</span>(<span class="number">3</span>, <span class="string">&quot;world&quot;</span>);
<span class="macro">assert_eq!</span>(<span class="ident">vec</span>, [<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="string">&quot;world&quot;</span>]);

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">vec</span> <span class="op">=</span> <span class="macro">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];
<span class="ident">vec</span>.<span class="ident">resize</span>(<span class="number">2</span>, <span class="number">0</span>);
<span class="macro">assert_eq!</span>(<span class="ident">vec</span>, [<span class="number">1</span>, <span class="number">2</span>]);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20mut%20vec%20%3D%20vec!%5B%22hello%22%5D%3B%0Avec.resize(3%2C%20%22world%22)%3B%0Aassert_eq!(vec%2C%20%5B%22hello%22%2C%20%22world%22%2C%20%22world%22%5D)%3B%0A%0Alet%20mut%20vec%20%3D%20vec!%5B1%2C%202%2C%203%2C%204%5D%3B%0Avec.resize(2%2C%200)%3B%0Aassert_eq!(vec%2C%20%5B1%2C%202%5D)%3B%0A%7D&amp;edition=2018">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.extend_from_slice" class="method has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.6.0">1.6.0</span><a class="srclink" href="../../src/alloc/vec/mod.rs.html#2162-2164" title="goto source code">[src]</a></div><a href="#method.extend_from_slice" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.extend_from_slice" class="fnname">extend_from_slice</a>(&amp;mut self, other: &amp;[T])</h4></div></summary><div class="docblock" xpath="/html[1]/body[1]/section[1]/details[4]/div[1]/details[2]/div[1]" istranslationnode="true" main_mp="YW1sbmc/PnNlYjo7UmBnOUQ9MFAqLy5waGV1f3BKcmdPTH9SSExHQA=="><p class="translate-text">克隆切片中的所有元素并将其附加到 Vec。</p><p>Clones and appends all elements in a slice to the <code>Vec</code>.</p>
<p class="translate-text">遍历切片 other，克隆每个元素，然后将其附加到此 Vec。 另一个Vector按顺序遍历。</p><p>Iterates over the slice <code>other</code>, clones each element, and then appends
it to this <code>Vec</code>. The <code>other</code> vector is traversed in-order.</p>
<p class="translate-text">请注意，此函数与 extend 相同，只是它专门用于处理切片。 如果并且当 Rust 获得专业化时，此功能可能会被弃用（但仍然可用）。</p><p>Note that this function is same as <a href="struct.Vec.html#method.extend"><code>extend</code></a> except that it is
specialized to work with slices instead. If and when Rust gets
specialization this function will likely be deprecated (but still
available).</p>
<h1 id="examples-42" class="section-header"><a href="#examples-42">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">vec</span> <span class="op">=</span> <span class="macro">vec!</span>[<span class="number">1</span>];
<span class="ident">vec</span>.<span class="ident">extend_from_slice</span>(<span class="kw-2">&amp;</span>[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]);
<span class="macro">assert_eq!</span>(<span class="ident">vec</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20mut%20vec%20%3D%20vec!%5B1%5D%3B%0Avec.extend_from_slice(%26%5B2%2C%203%2C%204%5D)%3B%0Aassert_eq!(vec%2C%20%5B1%2C%202%2C%203%2C%204%5D)%3B%0A%7D&amp;edition=2018">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.extend_from_within" class="method has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.53.0">1.53.0</span><a class="srclink" href="../../src/alloc/vec/mod.rs.html#2184-2196" title="goto source code">[src]</a></div><a href="#method.extend_from_within" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.extend_from_within" class="fnname">extend_from_within</a>&lt;R&gt;(&amp;mut self, src: R) <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;R: <a class="trait" href="../../core/ops/range/trait.RangeBounds.html" title="trait core::ops::range::RangeBounds">RangeBounds</a>&lt;usize&gt;,&nbsp;</span></h4></div></summary><div class="docblock" xpath="/html[1]/body[1]/section[1]/details[4]/div[1]/details[3]/div[1]" istranslationnode="true" main_mp="YW1sbmc/PnNlYjo7UmBnOUQ9MFAqLy5waGV1f3BKcmdPTH9WTVFMTE4="><p class="translate-text">将元素从 src 范围复制到Vector的末尾。</p><p>Copies elements from <code>src</code> range to the end of the vector.</p>
<h2 id="examples-43" class="section-header"><a href="#examples-43">Examples</a></h2>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">vec</span> <span class="op">=</span> <span class="macro">vec!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];

<span class="ident">vec</span>.<span class="ident">extend_from_within</span>(<span class="number">2</span>..);
<span class="macro">assert_eq!</span>(<span class="ident">vec</span>, [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]);

<span class="ident">vec</span>.<span class="ident">extend_from_within</span>(..<span class="number">2</span>);
<span class="macro">assert_eq!</span>(<span class="ident">vec</span>, [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">1</span>]);

<span class="ident">vec</span>.<span class="ident">extend_from_within</span>(<span class="number">4</span>..<span class="number">8</span>);
<span class="macro">assert_eq!</span>(<span class="ident">vec</span>, [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20mut%20vec%20%3D%20vec!%5B0%2C%201%2C%202%2C%203%2C%204%5D%3B%0A%0Avec.extend_from_within(2..)%3B%0Aassert_eq!(vec%2C%20%5B0%2C%201%2C%202%2C%203%2C%204%2C%202%2C%203%2C%204%5D)%3B%0A%0Avec.extend_from_within(..2)%3B%0Aassert_eq!(vec%2C%20%5B0%2C%201%2C%202%2C%203%2C%204%2C%202%2C%203%2C%204%2C%200%2C%201%5D)%3B%0A%0Avec.extend_from_within(4..8)%3B%0Aassert_eq!(vec%2C%20%5B0%2C%201%2C%202%2C%203%2C%204%2C%202%2C%203%2C%204%2C%200%2C%201%2C%204%2C%202%2C%203%2C%204%5D)%3B%0A%7D&amp;edition=2018">Run</a></div>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open=""><summary><div id="impl-3" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../../src/alloc/vec/mod.rs.html#2267-2287" title="goto source code">[src]</a></div><a href="#impl-3" class="anchor"></a><h3 class="code-header in-band">impl&lt;T:&nbsp;<a class="trait" href="../../core/cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a>, A:&nbsp;<a class="trait" href="../alloc/trait.Allocator.html" title="trait alloc::alloc::Allocator">Allocator</a>&gt; <a class="struct" href="struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;T, A&gt;</h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.dedup" class="method has-srclink"><div class="rightside"><a class="srclink" href="../../src/alloc/vec/mod.rs.html#2284-2286" title="goto source code">[src]</a></div><a href="#method.dedup" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.dedup" class="fnname">dedup</a>(&amp;mut self)</h4></div></summary><div class="docblock" xpath="/html[1]/body[1]/section[1]/details[5]/div[1]/details[1]/div[1]" istranslationnode="true" main_mp="YW1sbmc/PnNlYjo7UmBnOUQ9MFAqLy5xdXVlYQ=="><p class="translate-text">根据 PartialEq trait 实现移除Vector中的连续重复元素。</p><p>Removes consecutive repeated elements in the vector according to the
<a href="../../core/cmp/trait.PartialEq.html" title="PartialEq"><code>PartialEq</code></a> trait implementation.</p>
<p class="translate-text">如果Vector已排序，则会删除所有重复项。</p><p>If the vector is sorted, this removes all duplicates.</p>
<h1 id="examples-44" class="section-header"><a href="#examples-44">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">vec</span> <span class="op">=</span> <span class="macro">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>];

<span class="ident">vec</span>.<span class="ident">dedup</span>();

<span class="macro">assert_eq!</span>(<span class="ident">vec</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>]);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20mut%20vec%20%3D%20vec!%5B1%2C%202%2C%202%2C%203%2C%202%5D%3B%0A%0Avec.dedup()%3B%0A%0Aassert_eq!(vec%2C%20%5B1%2C%202%2C%203%2C%202%5D)%3B%0A%7D&amp;edition=2018">Run</a></div>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open=""><summary><div id="impl-4" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../../src/alloc/vec/mod.rs.html#2571-2701" title="goto source code">[src]</a></div><a href="#impl-4" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, A:&nbsp;<a class="trait" href="../alloc/trait.Allocator.html" title="trait alloc::alloc::Allocator">Allocator</a>&gt; <a class="struct" href="struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;T, A&gt;</h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.splice" class="method has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.21.0">1.21.0</span><a class="srclink" href="../../src/alloc/vec/mod.rs.html#2635-2641" title="goto source code">[src]</a></div><a href="#method.splice" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.splice" class="fnname">splice</a>&lt;R, I&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;mut self, <br>&nbsp;&nbsp;&nbsp;&nbsp;range: R, <br>&nbsp;&nbsp;&nbsp;&nbsp;replace_with: I<br>) -&gt; <a class="struct" href="struct.Splice.html" title="struct alloc::vec::Splice">Splice</a>&lt;'_, I::<a class="type" href="../../core/iter/traits/collect/trait.IntoIterator.html#associatedtype.IntoIter" title="type core::iter::traits::collect::IntoIterator::IntoIter">IntoIter</a>, A&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><div class="notable">Notable traits for <a class="struct" href="struct.Splice.html" title="struct alloc::vec::Splice">Splice</a>&lt;'_, I, A&gt;</div><code class="content"><span class="where fmt-newline">impl&lt;I:&nbsp;<a class="trait" href="../../core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a>, A:&nbsp;<a class="trait" href="../alloc/trait.Allocator.html" title="trait alloc::alloc::Allocator">Allocator</a>&gt; <a class="trait" href="../../core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="struct.Splice.html" title="struct alloc::vec::Splice">Splice</a>&lt;'_, I, A&gt;</span><span class="where fmt-newline">    type <a href="../../core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="type">Item</a> = I::<a class="type" href="../../core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" title="type core::iter::traits::iterator::Iterator::Item">Item</a>;</span></code></span></div></span></span> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;R: <a class="trait" href="../../core/ops/range/trait.RangeBounds.html" title="trait core::ops::range::RangeBounds">RangeBounds</a>&lt;usize&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;I: <a class="trait" href="../../core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&lt;Item = T&gt;,&nbsp;</span></h4></div></summary><div class="docblock" xpath="/html[1]/body[1]/section[1]/details[6]/div[1]/details[1]/div[1]" istranslationnode="true" main_mp="YW1sbmc/PnNlYjo7UmBnOUQ9MFAqLy5mYH15cnE="><p class="translate-text">创建一个拼接迭代器，用给定的 replace_with 迭代器替换Vector中的指定范围，并产生删除的项目。 replace_with 不需要与范围的长度相同。</p><p>Creates a splicing iterator that replaces the specified range in the vector
with the given <code>replace_with</code> iterator and yields the removed items.
<code>replace_with</code> does not need to be the same length as <code>range</code>.</p>
<p class="translate-text">即使迭代器直到结束都没有被消耗，范围也会被删除。</p><p><code>range</code> is removed even if the iterator is not consumed until the end.</p>
<p class="translate-text">如果 Splice 值泄漏，则未指定从Vector中删除多少元素。</p><p>It is unspecified how many elements are removed from the vector
if the <code>Splice</code> value is leaked.</p>
<p class="translate-text">输入迭代器 replace_with 仅在 Splice 值被删除时使用。</p><p>The input iterator <code>replace_with</code> is only consumed when the <code>Splice</code> value is dropped.</p>
<p class="translate-text">这是最佳的，如果：</p><p>This is optimal if:</p>
<ul>
<li class="translate-text">尾部（范围之后Vector中的元素）为空，</li><li>The tail (elements in the vector after <code>range</code>) is empty,</li>
<li class="translate-text">或 replace_with 产生的元素少于或等于范围的长度</li><li>or <code>replace_with</code> yields fewer or equal elements than <code>range</code>’s length</li>
<li class="translate-text">或者它的 size_hint() 的下限是准确的。</li><li>or the lower bound of its <code>size_hint()</code> is exact.</li>
</ul>
<p class="translate-text">否则，分配一个临时Vector，并且尾部移动两次。</p><p>Otherwise, a temporary vector is allocated and the tail is moved twice.</p>
<h1 id="panics-11" class="section-header"><a href="#panics-11">Panics</a></h1>
<p class="translate-text">如果起点大于终点或终点大于Vector的长度，则会出现panic。</p><p>Panics if the starting point is greater than the end point or if
the end point is greater than the length of the vector.</p>
<h1 id="examples-45" class="section-header"><a href="#examples-45">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">v</span> <span class="op">=</span> <span class="macro">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];
<span class="kw">let</span> <span class="ident">new</span> <span class="op">=</span> [<span class="number">7</span>, <span class="number">8</span>];
<span class="kw">let</span> <span class="ident">u</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw">_</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">v</span>.<span class="ident">splice</span>(..<span class="number">2</span>, <span class="ident">new</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq!</span>(<span class="ident">v</span>, <span class="kw-2">&amp;</span>[<span class="number">7</span>, <span class="number">8</span>, <span class="number">3</span>]);
<span class="macro">assert_eq!</span>(<span class="ident">u</span>, <span class="kw-2">&amp;</span>[<span class="number">1</span>, <span class="number">2</span>]);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20mut%20v%20%3D%20vec!%5B1%2C%202%2C%203%5D%3B%0Alet%20new%20%3D%20%5B7%2C%208%5D%3B%0Alet%20u%3A%20Vec%3C_%3E%20%3D%20v.splice(..2%2C%20new).collect()%3B%0Aassert_eq!(v%2C%20%26%5B7%2C%208%2C%203%5D)%3B%0Aassert_eq!(u%2C%20%26%5B1%2C%202%5D)%3B%0A%7D&amp;edition=2018">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.drain_filter" class="method has-srclink"><div class="rightside"><a class="srclink" href="../../src/alloc/vec/mod.rs.html#2688-2700" title="goto source code">[src]</a></div><a href="#method.drain_filter" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.drain_filter" class="fnname">drain_filter</a>&lt;F&gt;(&amp;mut self, filter: F) -&gt; <a class="struct" href="struct.DrainFilter.html" title="struct alloc::vec::DrainFilter">DrainFilter</a>&lt;'_, T, F, A&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><div class="notable">Notable traits for <a class="struct" href="struct.DrainFilter.html" title="struct alloc::vec::DrainFilter">DrainFilter</a>&lt;'_, T, F, A&gt;</div><code class="content"><span class="where fmt-newline">impl&lt;T, F, A:&nbsp;<a class="trait" href="../alloc/trait.Allocator.html" title="trait alloc::alloc::Allocator">Allocator</a>&gt; <a class="trait" href="../../core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="struct.DrainFilter.html" title="struct alloc::vec::DrainFilter">DrainFilter</a>&lt;'_, T, F, A&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="../../core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(&amp;mut T) -&gt; bool,&nbsp;</span></span><span class="where fmt-newline">    type <a href="../../core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="type">Item</a> = T;</span></code></span></div></span></span> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="../../core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(&amp;mut T) -&gt; bool,&nbsp;</span></h4></div><div class="item-info"><div class="stab unstable"><details><summary><span class="emoji">🔬</span> This is a nightly-only experimental API. (<code>drain_filter</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/43244">#43244</a>)</summary><p>recently added</p>
</details></div></div></summary><div class="docblock" xpath="/html[1]/body[1]/section[1]/details[6]/div[1]/details[2]/div[1]" istranslationnode="true" main_mp="YW1sbmc/PnNlYjo7UmBnOUQ9MFAqLy5xYnB5f0tzfXlURFI="><p class="translate-text">创建一个迭代器，它使用闭包来确定是否应删除元素。</p><p>Creates an iterator which uses a closure to determine if an element should be removed.</p>
<p class="translate-text">如果闭包返回 true，则元素被移除并生成。 如果闭包返回 false，则元素将保留在Vector中并且不会被迭代器产生。</p><p>If the closure returns true, then the element is removed and yielded.
If the closure returns false, the element will remain in the vector and will not be yielded
by the iterator.</p>
<p class="translate-text">使用该方法等价于以下代码：</p><p>Using this method is equivalent to the following code:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">i</span> <span class="op">=</span> <span class="number">0</span>;
<span class="kw">while</span> <span class="ident">i</span> <span class="op">&lt;</span> <span class="ident">vec</span>.<span class="ident">len</span>() {
    <span class="kw">if</span> <span class="ident">some_predicate</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">vec</span>[<span class="ident">i</span>]) {
        <span class="kw">let</span> <span class="ident">val</span> <span class="op">=</span> <span class="ident">vec</span>.<span class="ident">remove</span>(<span class="ident">i</span>);
        <span class="comment">// your code here</span>
    } <span class="kw">else</span> {
        <span class="ident">i</span> <span class="op">+</span><span class="op">=</span> <span class="number">1</span>;
    }
}
</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20some_predicate%20%3D%20%7Cx%3A%20%26mut%20i32%7C%20%7B%20*x%20%3D%3D%202%20%7C%7C%20*x%20%3D%3D%203%20%7C%7C%20*x%20%3D%3D%206%20%7D%3B%0Alet%20mut%20vec%20%3D%20vec!%5B1%2C%202%2C%203%2C%204%2C%205%2C%206%5D%3B%0Alet%20mut%20i%20%3D%200%3B%0Awhile%20i%20%3C%20vec.len()%20%7B%0A%20%20%20%20if%20some_predicate(%26mut%20vec%5Bi%5D)%20%7B%0A%20%20%20%20%20%20%20%20let%20val%20%3D%20vec.remove(i)%3B%0A%20%20%20%20%20%20%20%20%2F%2F%20your%20code%20here%0A%20%20%20%20%7D%20else%20%7B%0A%20%20%20%20%20%20%20%20i%20%2B%3D%201%3B%0A%20%20%20%20%7D%0A%7D%0A%0Aassert_eq!(vec%2C%20vec!%5B1%2C%204%2C%205%5D)%3B%0A%7D&amp;edition=2018">Run</a></div>
<p class="translate-text">但是 drain_filter 更容易使用。 drain_filter 也更有效，因为它可以批量回移数组的元素。</p><p>But <code>drain_filter</code> is easier to use. <code>drain_filter</code> is also more efficient,
because it can backshift the elements of the array in bulk.</p>
<p class="translate-text">请注意， drain_filter 还允许您改变过滤器闭包中的每个元素，无论您选择保留还是删除它。</p><p>Note that <code>drain_filter</code> also lets you mutate every element in the filter closure,
regardless of whether you choose to keep or remove it.</p>
<h1 id="examples-46" class="section-header"><a href="#examples-46">Examples</a></h1>
<p class="translate-text">将数组拆分为偶数和奇数，重用原始分配：</p><p>Splitting an array into evens and odds, reusing the original allocation:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attribute">#![<span class="ident">feature</span>(<span class="ident">drain_filter</span>)]</span>
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">numbers</span> <span class="op">=</span> <span class="macro">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>];

<span class="kw">let</span> <span class="ident">evens</span> <span class="op">=</span> <span class="ident">numbers</span>.<span class="ident">drain_filter</span>(<span class="op">|</span><span class="ident">x</span><span class="op">|</span> <span class="kw-2">*</span><span class="ident">x</span> <span class="op">%</span> <span class="number">2</span> <span class="op">=</span><span class="op">=</span> <span class="number">0</span>).<span class="ident">collect</span>::<span class="op">&lt;</span><span class="ident">Vec</span><span class="op">&lt;</span><span class="kw">_</span><span class="op">&gt;</span><span class="op">&gt;</span>();
<span class="kw">let</span> <span class="ident">odds</span> <span class="op">=</span> <span class="ident">numbers</span>;

<span class="macro">assert_eq!</span>(<span class="ident">evens</span>, <span class="macro">vec!</span>[<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">14</span>]);
<span class="macro">assert_eq!</span>(<span class="ident">odds</span>, <span class="macro">vec!</span>[<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">15</span>]);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(drain_filter)%5D%0Afn%20main()%20%7B%0Alet%20mut%20numbers%20%3D%20vec!%5B1%2C%202%2C%203%2C%204%2C%205%2C%206%2C%208%2C%209%2C%2011%2C%2013%2C%2014%2C%2015%5D%3B%0A%0Alet%20evens%20%3D%20numbers.drain_filter(%7Cx%7C%20*x%20%25%202%20%3D%3D%200).collect%3A%3A%3CVec%3C_%3E%3E()%3B%0Alet%20odds%20%3D%20numbers%3B%0A%0Aassert_eq!(evens%2C%20vec!%5B2%2C%204%2C%206%2C%208%2C%2014%5D)%3B%0Aassert_eq!(odds%2C%20vec!%5B1%2C%203%2C%205%2C%209%2C%2011%2C%2013%2C%2015%5D)%3B%0A%7D&amp;version=nightly&amp;edition=2018">Run</a></div>
</div></details></div></details><h2 id="trait-implementations" class="small-section-header">Trait Implementations<a href="#trait-implementations" class="anchor"></a></h2><div id="trait-implementations-list"><details class="rustdoc-toggle implementors-toggle" open=""><summary><div id="impl-AsMut%3C%5BT%5D%3E" class="impl has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.5.0">1.5.0</span><a class="srclink" href="../../src/alloc/vec/mod.rs.html#2799-2803" title="goto source code">[src]</a></div><a href="#impl-AsMut%3C%5BT%5D%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, A:&nbsp;<a class="trait" href="../alloc/trait.Allocator.html" title="trait alloc::alloc::Allocator">Allocator</a>&gt; <a class="trait" href="../../core/convert/trait.AsMut.html" title="trait core::convert::AsMut">AsMut</a>&lt;[T]&gt; for <a class="struct" href="struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;T, A&gt;</h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.as_mut-1" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../../src/alloc/vec/mod.rs.html#2800-2802" title="goto source code">[src]</a></div><a href="#method.as_mut-1" class="anchor"></a><h4 class="code-header">fn <a href="../../core/convert/trait.AsMut.html#tymethod.as_mut" class="fnname">as_mut</a>(&amp;mut self) -&gt; &amp;mut [T]</h4></div></summary><div class='docblock'><p>Performs the conversion.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open=""><summary><div id="impl-AsMut%3CVec%3CT%2C%20A%3E%3E" class="impl has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.5.0">1.5.0</span><a class="srclink" href="../../src/alloc/vec/mod.rs.html#2785-2789" title="goto source code">[src]</a></div><a href="#impl-AsMut%3CVec%3CT%2C%20A%3E%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, A:&nbsp;<a class="trait" href="../alloc/trait.Allocator.html" title="trait alloc::alloc::Allocator">Allocator</a>&gt; <a class="trait" href="../../core/convert/trait.AsMut.html" title="trait core::convert::AsMut">AsMut</a>&lt;<a class="struct" href="struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;T, A&gt;&gt; for <a class="struct" href="struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;T, A&gt;</h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.as_mut" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../../src/alloc/vec/mod.rs.html#2786-2788" title="goto source code">[src]</a></div><a href="#method.as_mut" class="anchor"></a><h4 class="code-header">fn <a href="../../core/convert/trait.AsMut.html#tymethod.as_mut" class="fnname">as_mut</a>(&amp;mut self) -&gt; &amp;mut <a class="struct" href="struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;T, A&gt;</h4></div></summary><div class='docblock'><p>Performs the conversion.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open=""><summary><div id="impl-AsRef%3C%5BT%5D%3E" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../../src/alloc/vec/mod.rs.html#2792-2796" title="goto source code">[src]</a></div><a href="#impl-AsRef%3C%5BT%5D%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, A:&nbsp;<a class="trait" href="../alloc/trait.Allocator.html" title="trait alloc::alloc::Allocator">Allocator</a>&gt; <a class="trait" href="../../core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[T]&gt; for <a class="struct" href="struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;T, A&gt;</h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.as_ref-1" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../../src/alloc/vec/mod.rs.html#2793-2795" title="goto source code">[src]</a></div><a href="#method.as_ref-1" class="anchor"></a><h4 class="code-header">fn <a href="../../core/convert/trait.AsRef.html#tymethod.as_ref" class="fnname">as_ref</a>(&amp;self) -&gt; &amp;[T]</h4></div></summary><div class='docblock'><p>Performs the conversion.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open=""><summary><div id="impl-AsRef%3CVec%3CT%2C%20A%3E%3E" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../../src/alloc/vec/mod.rs.html#2778-2782" title="goto source code">[src]</a></div><a href="#impl-AsRef%3CVec%3CT%2C%20A%3E%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, A:&nbsp;<a class="trait" href="../alloc/trait.Allocator.html" title="trait alloc::alloc::Allocator">Allocator</a>&gt; <a class="trait" href="../../core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;<a class="struct" href="struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;T, A&gt;&gt; for <a class="struct" href="struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;T, A&gt;</h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.as_ref" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../../src/alloc/vec/mod.rs.html#2779-2781" title="goto source code">[src]</a></div><a href="#method.as_ref" class="anchor"></a><h4 class="code-header">fn <a href="../../core/convert/trait.AsRef.html#tymethod.as_ref" class="fnname">as_ref</a>(&amp;self) -&gt; &amp;<a class="struct" href="struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;T, A&gt;</h4></div></summary><div class='docblock'><p>Performs the conversion.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open=""><summary><div id="impl-Borrow%3C%5BT%5D%3E" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../../src/alloc/slice.rs.html#815-819" title="goto source code">[src]</a></div><a href="#impl-Borrow%3C%5BT%5D%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="../borrow/trait.Borrow.html" title="trait alloc::borrow::Borrow">Borrow</a>&lt;[T]&gt; for <a class="struct" href="struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;T&gt;</h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.borrow" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../../src/alloc/slice.rs.html#816-818" title="goto source code">[src]</a></div><a href="#method.borrow" class="anchor"></a><h4 class="code-header">fn <a href="../borrow/trait.Borrow.html#tymethod.borrow" class="fnname">borrow</a>(&amp;self) -&gt; &amp;[T]</h4></div></summary><div class='docblock'><p>Immutably borrows from an owned value. <a href="../borrow/trait.Borrow.html#tymethod.borrow">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open=""><summary><div id="impl-BorrowMut%3C%5BT%5D%3E" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../../src/alloc/slice.rs.html#822-826" title="goto source code">[src]</a></div><a href="#impl-BorrowMut%3C%5BT%5D%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="../borrow/trait.BorrowMut.html" title="trait alloc::borrow::BorrowMut">BorrowMut</a>&lt;[T]&gt; for <a class="struct" href="struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;T&gt;</h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.borrow_mut" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../../src/alloc/slice.rs.html#823-825" title="goto source code">[src]</a></div><a href="#method.borrow_mut" class="anchor"></a><h4 class="code-header">fn <a href="../borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fnname">borrow_mut</a>(&amp;mut self) -&gt; &amp;mut [T]</h4></div></summary><div class='docblock'><p>Mutably borrows from an owned value. <a href="../borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open=""><summary><div id="impl-Clone" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../../src/alloc/vec/mod.rs.html#2413-2433" title="goto source code">[src]</a></div><a href="#impl-Clone" class="anchor"></a><h3 class="code-header in-band">impl&lt;T:&nbsp;<a class="trait" href="../../core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>, A:&nbsp;<a class="trait" href="../alloc/trait.Allocator.html" title="trait alloc::alloc::Allocator">Allocator</a> + <a class="trait" href="../../core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>&gt; <a class="trait" href="../../core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> for <a class="struct" href="struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;T, A&gt;</h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.clone" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../../src/alloc/vec/mod.rs.html#2415-2418" title="goto source code">[src]</a></div><a href="#method.clone" class="anchor"></a><h4 class="code-header">fn <a href="../../core/clone/trait.Clone.html#tymethod.clone" class="fnname">clone</a>(&amp;self) -&gt; Self</h4></div></summary><div class='docblock'><p>Returns a copy of the value. <a href="../../core/clone/trait.Clone.html#tymethod.clone">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.clone_from" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../../src/alloc/vec/mod.rs.html#2430-2432" title="goto source code">[src]</a></div><a href="#method.clone_from" class="anchor"></a><h4 class="code-header">fn <a href="../../core/clone/trait.Clone.html#method.clone_from" class="fnname">clone_from</a>(&amp;mut self, other: &amp;Self)</h4></div></summary><div class='docblock'><p>Performs copy-assignment from <code>source</code>. <a href="../../core/clone/trait.Clone.html#method.clone_from">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open=""><summary><div id="impl-Debug" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../../src/alloc/vec/mod.rs.html#2771-2775" title="goto source code">[src]</a></div><a href="#impl-Debug" class="anchor"></a><h3 class="code-header in-band">impl&lt;T:&nbsp;<a class="trait" href="../fmt/trait.Debug.html" title="trait alloc::fmt::Debug">Debug</a>, A:&nbsp;<a class="trait" href="../alloc/trait.Allocator.html" title="trait alloc::alloc::Allocator">Allocator</a>&gt; <a class="trait" href="../fmt/trait.Debug.html" title="trait alloc::fmt::Debug">Debug</a> for <a class="struct" href="struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;T, A&gt;</h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.fmt" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../../src/alloc/vec/mod.rs.html#2772-2774" title="goto source code">[src]</a></div><a href="#method.fmt" class="anchor"></a><h4 class="code-header">fn <a href="../fmt/trait.Debug.html#tymethod.fmt" class="fnname">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="../fmt/struct.Formatter.html" title="struct alloc::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="type" href="../fmt/type.Result.html" title="type alloc::fmt::Result">Result</a></h4></div></summary><div class='docblock'><p>Formats the value using the given formatter. <a href="../fmt/trait.Debug.html#tymethod.fmt">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open=""><summary><div id="impl-Default" class="impl has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.0.0, const unstable">1.0.0 (const: <a href="https://github.com/rust-lang/rust/issues/87864" title="Tracking issue for const_default_impls">unstable</a>)</span><a class="srclink" href="../../src/alloc/vec/mod.rs.html#2763-2768" title="goto source code">[src]</a></div><a href="#impl-Default" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="../../core/default/trait.Default.html" title="trait core::default::Default">Default</a> for <a class="struct" href="struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;T&gt;</h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.default" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../../src/alloc/vec/mod.rs.html#2765-2767" title="goto source code">[src]</a></div><a href="#method.default" class="anchor"></a><h4 class="code-header">fn <a href="../../core/default/trait.Default.html#tymethod.default" class="fnname">default</a>() -&gt; <a class="struct" href="struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;T&gt;</h4></div></summary><div class="docblock"><p>Creates an empty <code>Vec&lt;T&gt;</code>.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open=""><summary><div id="impl-Deref" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../../src/alloc/vec/mod.rs.html#2367-2373" title="goto source code">[src]</a></div><a href="#impl-Deref" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, A:&nbsp;<a class="trait" href="../alloc/trait.Allocator.html" title="trait alloc::alloc::Allocator">Allocator</a>&gt; <a class="trait" href="../../core/ops/deref/trait.Deref.html" title="trait core::ops::deref::Deref">Deref</a> for <a class="struct" href="struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;T, A&gt;</h3></div></summary><div class="impl-items"><details class="rustdoc-toggle" open=""><summary><div id="associatedtype.Target" class="type trait-impl has-srclink"><a href="#associatedtype.Target" class="anchor"></a><h4 class="code-header">type <a href="../../core/ops/deref/trait.Deref.html#associatedtype.Target" class="type">Target</a> = [T]</h4></div></summary><div class='docblock'><p>The resulting type after dereferencing.</p>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.deref" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../../src/alloc/vec/mod.rs.html#2370-2372" title="goto source code">[src]</a></div><a href="#method.deref" class="anchor"></a><h4 class="code-header">fn <a href="../../core/ops/deref/trait.Deref.html#tymethod.deref" class="fnname">deref</a>(&amp;self) -&gt; &amp;[T]</h4></div></summary><div class='docblock'><p>Dereferences the value.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open=""><summary><div id="impl-DerefMut" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../../src/alloc/vec/mod.rs.html#2376-2380" title="goto source code">[src]</a></div><a href="#impl-DerefMut" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, A:&nbsp;<a class="trait" href="../alloc/trait.Allocator.html" title="trait alloc::alloc::Allocator">Allocator</a>&gt; <a class="trait" href="../../core/ops/deref/trait.DerefMut.html" title="trait core::ops::deref::DerefMut">DerefMut</a> for <a class="struct" href="struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;T, A&gt;</h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.deref_mut" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../../src/alloc/vec/mod.rs.html#2377-2379" title="goto source code">[src]</a></div><a href="#method.deref_mut" class="anchor"></a><h4 class="code-header">fn <a href="../../core/ops/deref/trait.DerefMut.html#tymethod.deref_mut" class="fnname">deref_mut</a>(&amp;mut self) -&gt; &amp;mut [T]</h4></div></summary><div class='docblock'><p>Mutably dereferences the value.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open=""><summary><div id="impl-Drop" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../../src/alloc/vec/mod.rs.html#2749-2759" title="goto source code">[src]</a></div><a href="#impl-Drop" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, A:&nbsp;<a class="trait" href="../alloc/trait.Allocator.html" title="trait alloc::alloc::Allocator">Allocator</a>&gt; <a class="trait" href="../../core/ops/drop/trait.Drop.html" title="trait core::ops::drop::Drop">Drop</a> for <a class="struct" href="struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;T, A&gt;</h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.drop" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../../src/alloc/vec/mod.rs.html#2750-2758" title="goto source code">[src]</a></div><a href="#method.drop" class="anchor"></a><h4 class="code-header">fn <a href="../../core/ops/drop/trait.Drop.html#tymethod.drop" class="fnname">drop</a>(&amp;mut self)</h4></div></summary><div class='docblock'><p>Executes the destructor for this type. <a href="../../core/ops/drop/trait.Drop.html#tymethod.drop">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open=""><summary><div id="impl-Extend%3C%26%27a%20T%3E" class="impl has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.2.0">1.2.0</span><a class="srclink" href="../../src/alloc/vec/mod.rs.html#2711-2725" title="goto source code">[src]</a></div><a href="#impl-Extend%3C%26%27a%20T%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;'a, T:&nbsp;<a class="trait" href="../../core/marker/trait.Copy.html" title="trait core::marker::Copy">Copy</a> + 'a, A:&nbsp;<a class="trait" href="../alloc/trait.Allocator.html" title="trait alloc::alloc::Allocator">Allocator</a> + 'a&gt; <a class="trait" href="../../core/iter/traits/collect/trait.Extend.html" title="trait core::iter::traits::collect::Extend">Extend</a>&lt;&amp;'a T&gt; for <a class="struct" href="struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;T, A&gt;</h3></div></summary><div class="docblock"><p>Extend implementation that copies elements out of references before pushing them onto the Vec.</p>
<p>This implementation is specialized for slice iterators, where it uses <a href="https://doc.rust-lang.org/1.56.1/std/primitive.slice.html#method.copy_from_slice"><code>copy_from_slice</code></a> to
append the entire slice at once.</p>
</div><div class="impl-items"><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.extend-1" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../../src/alloc/vec/mod.rs.html#2712-2714" title="goto source code">[src]</a></div><a href="#method.extend-1" class="anchor"></a><h4 class="code-header">fn <a href="../../core/iter/traits/collect/trait.Extend.html#tymethod.extend" class="fnname">extend</a>&lt;I:&nbsp;<a class="trait" href="../../core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&lt;Item = &amp;'a T&gt;&gt;(&amp;mut self, iter: I)</h4></div></summary><div class='docblock'><p>Extends a collection with the contents of an iterator. <a href="../../core/iter/traits/collect/trait.Extend.html#tymethod.extend">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.extend_one-1" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../../src/alloc/vec/mod.rs.html#2717-2719" title="goto source code">[src]</a></div><a href="#method.extend_one-1" class="anchor"></a><h4 class="code-header">fn <a href="../../core/iter/traits/collect/trait.Extend.html#method.extend_one" class="fnname">extend_one</a>(&amp;mut self, item: &amp;'a T)</h4></div></summary><div class="item-info"><div class="stab unstable"><span class="emoji">🔬</span> This is a nightly-only experimental API. (<code>extend_one</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/72631">#72631</a>)</div></div><div class='docblock'><p>Extends a collection with exactly one element.</p>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.extend_reserve-1" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../../src/alloc/vec/mod.rs.html#2722-2724" title="goto source code">[src]</a></div><a href="#method.extend_reserve-1" class="anchor"></a><h4 class="code-header">fn <a href="../../core/iter/traits/collect/trait.Extend.html#method.extend_reserve" class="fnname">extend_reserve</a>(&amp;mut self, additional: usize)</h4></div></summary><div class="item-info"><div class="stab unstable"><span class="emoji">🔬</span> This is a nightly-only experimental API. (<code>extend_one</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/72631">#72631</a>)</div></div><div class='docblock'><p>Reserves capacity in a collection for the given number of additional elements. <a href="../../core/iter/traits/collect/trait.Extend.html#method.extend_reserve">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open=""><summary><div id="impl-Extend%3CT%3E" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../../src/alloc/vec/mod.rs.html#2554-2569" title="goto source code">[src]</a></div><a href="#impl-Extend%3CT%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, A:&nbsp;<a class="trait" href="../alloc/trait.Allocator.html" title="trait alloc::alloc::Allocator">Allocator</a>&gt; <a class="trait" href="../../core/iter/traits/collect/trait.Extend.html" title="trait core::iter::traits::collect::Extend">Extend</a>&lt;T&gt; for <a class="struct" href="struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;T, A&gt;</h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.extend" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../../src/alloc/vec/mod.rs.html#2556-2558" title="goto source code">[src]</a></div><a href="#method.extend" class="anchor"></a><h4 class="code-header">fn <a href="../../core/iter/traits/collect/trait.Extend.html#tymethod.extend" class="fnname">extend</a>&lt;I:&nbsp;<a class="trait" href="../../core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&lt;Item = T&gt;&gt;(&amp;mut self, iter: I)</h4></div></summary><div class='docblock'><p>Extends a collection with the contents of an iterator. <a href="../../core/iter/traits/collect/trait.Extend.html#tymethod.extend">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.extend_one" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../../src/alloc/vec/mod.rs.html#2561-2563" title="goto source code">[src]</a></div><a href="#method.extend_one" class="anchor"></a><h4 class="code-header">fn <a href="../../core/iter/traits/collect/trait.Extend.html#method.extend_one" class="fnname">extend_one</a>(&amp;mut self, item: T)</h4></div></summary><div class="item-info"><div class="stab unstable"><span class="emoji">🔬</span> This is a nightly-only experimental API. (<code>extend_one</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/72631">#72631</a>)</div></div><div class='docblock'><p>Extends a collection with exactly one element.</p>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.extend_reserve" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../../src/alloc/vec/mod.rs.html#2566-2568" title="goto source code">[src]</a></div><a href="#method.extend_reserve" class="anchor"></a><h4 class="code-header">fn <a href="../../core/iter/traits/collect/trait.Extend.html#method.extend_reserve" class="fnname">extend_reserve</a>(&amp;mut self, additional: usize)</h4></div></summary><div class="item-info"><div class="stab unstable"><span class="emoji">🔬</span> This is a nightly-only experimental API. (<code>extend_one</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/72631">#72631</a>)</div></div><div class='docblock'><p>Reserves capacity in a collection for the given number of additional elements. <a href="../../core/iter/traits/collect/trait.Extend.html#method.extend_reserve">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open=""><summary><div id="impl-From%3C%26%27_%20%5BT%5D%3E" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../../src/alloc/vec/mod.rs.html#2807-2823" title="goto source code">[src]</a></div><a href="#impl-From%3C%26%27_%20%5BT%5D%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T:&nbsp;<a class="trait" href="../../core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>&gt; <a class="trait" href="../../core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;&amp;'_ [T]&gt; for <a class="struct" href="struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;T&gt;</h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.from-9" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../../src/alloc/vec/mod.rs.html#2816-2818" title="goto source code">[src]</a></div><a href="#method.from-9" class="anchor"></a><h4 class="code-header">fn <a href="../../core/convert/trait.From.html#tymethod.from" class="fnname">from</a>(s: &amp;[T]) -&gt; <a class="struct" href="struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;T&gt;</h4></div></summary><div class="docblock"><p>Allocate a <code>Vec&lt;T&gt;</code> and fill it by cloning <code>s</code>’s items.</p>
<h1 id="examples-50" class="section-header"><a href="#examples-50">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="ident">Vec::from</span>(<span class="kw-2">&amp;</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>][..]), <span class="macro">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Aassert_eq!(Vec%3A%3Afrom(%26%5B1%2C%202%2C%203%5D%5B..%5D)%2C%20vec!%5B1%2C%202%2C%203%5D)%3B%0A%7D&amp;edition=2018">Run</a></div>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open=""><summary><div id="impl-From%3C%26%27_%20mut%20%5BT%5D%3E" class="impl has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.19.0">1.19.0</span><a class="srclink" href="../../src/alloc/vec/mod.rs.html#2827-2843" title="goto source code">[src]</a></div><a href="#impl-From%3C%26%27_%20mut%20%5BT%5D%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T:&nbsp;<a class="trait" href="../../core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>&gt; <a class="trait" href="../../core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;&amp;'_ mut [T]&gt; for <a class="struct" href="struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;T&gt;</h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.from-10" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../../src/alloc/vec/mod.rs.html#2836-2838" title="goto source code">[src]</a></div><a href="#method.from-10" class="anchor"></a><h4 class="code-header">fn <a href="../../core/convert/trait.From.html#tymethod.from" class="fnname">from</a>(s: &amp;mut [T]) -&gt; <a class="struct" href="struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;T&gt;</h4></div></summary><div class="docblock"><p>Allocate a <code>Vec&lt;T&gt;</code> and fill it by cloning <code>s</code>’s items.</p>
<h1 id="examples-51" class="section-header"><a href="#examples-51">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="ident">Vec::from</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>][..]), <span class="macro">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Aassert_eq!(Vec%3A%3Afrom(%26mut%20%5B1%2C%202%2C%203%5D%5B..%5D)%2C%20vec!%5B1%2C%202%2C%203%5D)%3B%0A%7D&amp;edition=2018">Run</a></div>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open=""><summary><div id="impl-From%3C%26%27_%20str%3E" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../../src/alloc/vec/mod.rs.html#2928-2939" title="goto source code">[src]</a></div><a href="#impl-From%3C%26%27_%20str%3E" class="anchor"></a><h3 class="code-header in-band">impl <a class="trait" href="../../core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;&amp;'_ str&gt; for <a class="struct" href="struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;u8&gt;</h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.from-15" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../../src/alloc/vec/mod.rs.html#2936-2938" title="goto source code">[src]</a></div><a href="#method.from-15" class="anchor"></a><h4 class="code-header">fn <a href="../../core/convert/trait.From.html#tymethod.from" class="fnname">from</a>(s: &amp;str) -&gt; <a class="struct" href="struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;u8&gt;</h4></div></summary><div class="docblock"><p>Allocate a <code>Vec&lt;u8&gt;</code> and fill it with a UTF-8 string.</p>
<h1 id="examples-55" class="section-header"><a href="#examples-55">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="ident">Vec::from</span>(<span class="string">&quot;123&quot;</span>), <span class="macro">vec!</span>[<span class="string">b&#39;1&#39;</span>, <span class="string">b&#39;2&#39;</span>, <span class="string">b&#39;3&#39;</span>]);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Aassert_eq!(Vec%3A%3Afrom(%22123%22)%2C%20vec!%5Bb'1'%2C%20b'2'%2C%20b'3'%5D)%3B%0A%7D&amp;edition=2018">Run</a></div>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open=""><summary><div id="impl-From%3C%26%27a%20Vec%3CT%2C%20Global%3E%3E" class="impl has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.28.0">1.28.0</span><a class="srclink" href="../../src/alloc/vec/cow.rs.html#33-43" title="goto source code">[src]</a></div><a href="#impl-From%3C%26%27a%20Vec%3CT%2C%20Global%3E%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;'a, T:&nbsp;<a class="trait" href="../../core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>&gt; <a class="trait" href="../../core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;&amp;'a <a class="struct" href="struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;T, <a class="struct" href="../alloc/struct.Global.html" title="struct alloc::alloc::Global">Global</a>&gt;&gt; for <a class="enum" href="../borrow/enum.Cow.html" title="enum alloc::borrow::Cow">Cow</a>&lt;'a, [T]&gt;</h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.from-8" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../../src/alloc/vec/cow.rs.html#40-42" title="goto source code">[src]</a></div><a href="#method.from-8" class="anchor"></a><h4 class="code-header">fn <a href="../../core/convert/trait.From.html#tymethod.from" class="fnname">from</a>(v: &amp;'a <a class="struct" href="struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;T&gt;) -&gt; <a class="enum" href="../borrow/enum.Cow.html" title="enum alloc::borrow::Cow">Cow</a>&lt;'a, [T]&gt;</h4></div></summary><div class="docblock"><p>Creates a <a href="../borrow/enum.Cow.html#variant.Borrowed"><code>Borrowed</code></a> variant of <a href="../borrow/enum.Cow.html" title="Cow"><code>Cow</code></a>
from a reference to <a href="struct.Vec.html" title="Vec"><code>Vec</code></a>.</p>
<p>This conversion does not allocate or clone the data.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open=""><summary><div id="impl-From%3C%5BT%3B%20N%5D%3E" class="impl has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.44.0">1.44.0</span><a class="srclink" href="../../src/alloc/vec/mod.rs.html#2846-2862" title="goto source code">[src]</a></div><a href="#impl-From%3C%5BT%3B%20N%5D%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, const N:&nbsp;usize&gt; <a class="trait" href="../../core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;[T; N]&gt; for <a class="struct" href="struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;T&gt;</h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.from-11" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../../src/alloc/vec/mod.rs.html#2848-2850" title="goto source code">[src]</a></div><a href="#method.from-11" class="anchor"></a><h4 class="code-header">fn <a href="../../core/convert/trait.From.html#tymethod.from" class="fnname">from</a>(s: [T; N]) -&gt; <a class="struct" href="struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;T&gt;</h4></div></summary><div class='docblock'><p>Performs the conversion.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open=""><summary><div id="impl-From%3CBinaryHeap%3CT%3E%3E" class="impl has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.5.0">1.5.0</span><a class="srclink" href="../../src/alloc/collections/binary_heap.rs.html#1492-1500" title="goto source code">[src]</a></div><a href="#impl-From%3CBinaryHeap%3CT%3E%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="../../core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;<a class="struct" href="../collections/binary_heap/struct.BinaryHeap.html" title="struct alloc::collections::binary_heap::BinaryHeap">BinaryHeap</a>&lt;T&gt;&gt; for <a class="struct" href="struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;T&gt;</h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.from-1" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../../src/alloc/collections/binary_heap.rs.html#1497-1499" title="goto source code">[src]</a></div><a href="#method.from-1" class="anchor"></a><h4 class="code-header">fn <a href="../../core/convert/trait.From.html#tymethod.from" class="fnname">from</a>(heap: <a class="struct" href="../collections/binary_heap/struct.BinaryHeap.html" title="struct alloc::collections::binary_heap::BinaryHeap">BinaryHeap</a>&lt;T&gt;) -&gt; <a class="struct" href="struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;T&gt;</h4></div></summary><div class="docblock"><p>Converts a <code>BinaryHeap&lt;T&gt;</code> into a <code>Vec&lt;T&gt;</code>.</p>
<p>This conversion requires no data movement or allocation, and has
constant time complexity.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open=""><summary><div id="impl-From%3CBox%3C%5BT%5D%2C%20A%3E%3E" class="impl has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.18.0">1.18.0</span><a class="srclink" href="../../src/alloc/vec/mod.rs.html#2891-2904" title="goto source code">[src]</a></div><a href="#impl-From%3CBox%3C%5BT%5D%2C%20A%3E%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, A:&nbsp;<a class="trait" href="../alloc/trait.Allocator.html" title="trait alloc::alloc::Allocator">Allocator</a>&gt; <a class="trait" href="../../core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;<a class="struct" href="../boxed/struct.Box.html" title="struct alloc::boxed::Box">Box</a>&lt;[T], A&gt;&gt; for <a class="struct" href="struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;T, A&gt;</h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.from-13" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../../src/alloc/vec/mod.rs.html#2901-2903" title="goto source code">[src]</a></div><a href="#method.from-13" class="anchor"></a><h4 class="code-header">fn <a href="../../core/convert/trait.From.html#tymethod.from" class="fnname">from</a>(s: <a class="struct" href="../boxed/struct.Box.html" title="struct alloc::boxed::Box">Box</a>&lt;[T], A&gt;) -&gt; Self</h4></div></summary><div class="docblock"><p>Convert a boxed slice into a vector by transferring ownership of
the existing heap allocation.</p>
<h1 id="examples-53" class="section-header"><a href="#examples-53">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">b</span>: <span class="ident">Box</span><span class="op">&lt;</span>[<span class="ident">i32</span>]<span class="op">&gt;</span> <span class="op">=</span> <span class="macro">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].<span class="ident">into_boxed_slice</span>();
<span class="macro">assert_eq!</span>(<span class="ident">Vec::from</span>(<span class="ident">b</span>), <span class="macro">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20b%3A%20Box%3C%5Bi32%5D%3E%20%3D%20vec!%5B1%2C%202%2C%203%5D.into_boxed_slice()%3B%0Aassert_eq!(Vec%3A%3Afrom(b)%2C%20vec!%5B1%2C%202%2C%203%5D)%3B%0A%7D&amp;edition=2018">Run</a></div>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open=""><summary><div id="impl-From%3CCow%3C%27a%2C%20%5BT%5D%3E%3E" class="impl has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.14.0">1.14.0</span><a class="srclink" href="../../src/alloc/vec/mod.rs.html#2865-2886" title="goto source code">[src]</a></div><a href="#impl-From%3CCow%3C%27a%2C%20%5BT%5D%3E%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;'a, T&gt; <a class="trait" href="../../core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;<a class="enum" href="../borrow/enum.Cow.html" title="enum alloc::borrow::Cow">Cow</a>&lt;'a, [T]&gt;&gt; for <a class="struct" href="struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;[T]: <a class="trait" href="../borrow/trait.ToOwned.html" title="trait alloc::borrow::ToOwned">ToOwned</a>&lt;Owned = <a class="struct" href="struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;T&gt;&gt;,&nbsp;</span></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.from-12" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../../src/alloc/vec/mod.rs.html#2883-2885" title="goto source code">[src]</a></div><a href="#method.from-12" class="anchor"></a><h4 class="code-header">fn <a href="../../core/convert/trait.From.html#tymethod.from" class="fnname">from</a>(s: <a class="enum" href="../borrow/enum.Cow.html" title="enum alloc::borrow::Cow">Cow</a>&lt;'a, [T]&gt;) -&gt; <a class="struct" href="struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;T&gt;</h4></div></summary><div class="docblock"><p>Convert a clone-on-write slice into a vector.</p>
<p>If <code>s</code> already owns a <code>Vec&lt;T&gt;</code>, it will be returned directly.
If <code>s</code> is borrowing a slice, a new <code>Vec&lt;T&gt;</code> will be allocated and
filled by cloning <code>s</code>’s items into it.</p>
<h1 id="examples-52" class="section-header"><a href="#examples-52">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">o</span>: <span class="ident">Cow</span><span class="op">&lt;</span>[<span class="ident">i32</span>]<span class="op">&gt;</span> <span class="op">=</span> <span class="ident">Cow::Owned</span>(<span class="macro">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);
<span class="kw">let</span> <span class="ident">b</span>: <span class="ident">Cow</span><span class="op">&lt;</span>[<span class="ident">i32</span>]<span class="op">&gt;</span> <span class="op">=</span> <span class="ident">Cow::Borrowed</span>(<span class="kw-2">&amp;</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);
<span class="macro">assert_eq!</span>(<span class="ident">Vec::from</span>(<span class="ident">o</span>), <span class="ident">Vec::from</span>(<span class="ident">b</span>));</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Ause%20std%3A%3Aborrow%3A%3ACow%3B%0Alet%20o%3A%20Cow%3C%5Bi32%5D%3E%20%3D%20Cow%3A%3AOwned(vec!%5B1%2C%202%2C%203%5D)%3B%0Alet%20b%3A%20Cow%3C%5Bi32%5D%3E%20%3D%20Cow%3A%3ABorrowed(%26%5B1%2C%202%2C%203%5D)%3B%0Aassert_eq!(Vec%3A%3Afrom(o)%2C%20Vec%3A%3Afrom(b))%3B%0A%7D&amp;edition=2018">Run</a></div>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open=""><summary><div id="impl-From%3CString%3E" class="impl has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.14.0">1.14.0</span><a class="srclink" href="../../src/alloc/string.rs.html#2686-2704" title="goto source code">[src]</a></div><a href="#impl-From%3CString%3E" class="anchor"></a><h3 class="code-header in-band">impl <a class="trait" href="../../core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;<a class="struct" href="../string/struct.String.html" title="struct alloc::string::String">String</a>&gt; for <a class="struct" href="struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;u8&gt;</h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.from-5" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../../src/alloc/string.rs.html#2701-2703" title="goto source code">[src]</a></div><a href="#method.from-5" class="anchor"></a><h4 class="code-header">fn <a href="../../core/convert/trait.From.html#tymethod.from" class="fnname">from</a>(string: <a class="struct" href="../string/struct.String.html" title="struct alloc::string::String">String</a>) -&gt; <a class="struct" href="struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;u8&gt;</h4></div></summary><div class="docblock"><p>Converts the given <a href="../string/struct.String.html" title="String"><code>String</code></a> to a vector <a href="struct.Vec.html" title="Vec"><code>Vec</code></a> that holds values of type <a href="https://doc.rust-lang.org/1.56.1/std/primitive.u8.html" title="u8"><code>u8</code></a>.</p>
<h1 id="examples-49" class="section-header"><a href="#examples-49">Examples</a></h1>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">s1</span> <span class="op">=</span> <span class="ident">String::from</span>(<span class="string">&quot;hello world&quot;</span>);
<span class="kw">let</span> <span class="ident">v1</span> <span class="op">=</span> <span class="ident">Vec::from</span>(<span class="ident">s1</span>);

<span class="kw">for</span> <span class="ident">b</span> <span class="kw">in</span> <span class="ident">v1</span> {
    <span class="macro">println!</span>(<span class="string">&quot;{}&quot;</span>, <span class="ident">b</span>);
}</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20s1%20%3D%20String%3A%3Afrom(%22hello%20world%22)%3B%0Alet%20v1%20%3D%20Vec%3A%3Afrom(s1)%3B%0A%0Afor%20b%20in%20v1%20%7B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20b)%3B%0A%7D%0A%7D&amp;edition=2018">Run</a></div>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open=""><summary><div id="impl-From%3CVec%3CT%2C%20A%3E%3E" class="impl has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.10.0">1.10.0</span><a class="srclink" href="../../src/alloc/collections/vec_deque/mod.rs.html#2914-2946" title="goto source code">[src]</a></div><a href="#impl-From%3CVec%3CT%2C%20A%3E%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, A:&nbsp;<a class="trait" href="../alloc/trait.Allocator.html" title="trait alloc::alloc::Allocator">Allocator</a>&gt; <a class="trait" href="../../core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;<a class="struct" href="struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;T, A&gt;&gt; for <a class="struct" href="../collections/vec_deque/struct.VecDeque.html" title="struct alloc::collections::vec_deque::VecDeque">VecDeque</a>&lt;T, A&gt;</h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.from-2" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../../src/alloc/collections/vec_deque/mod.rs.html#2923-2945" title="goto source code">[src]</a></div><a href="#method.from-2" class="anchor"></a><h4 class="code-header">fn <a href="../../core/convert/trait.From.html#tymethod.from" class="fnname">from</a>(other: <a class="struct" href="struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;T, A&gt;) -&gt; Self</h4></div></summary><div class="docblock"><p>Turn a <a href="struct.Vec.html"><code>Vec&lt;T&gt;</code></a> into a <a href="../collections/vec_deque/struct.VecDeque.html"><code>VecDeque&lt;T&gt;</code></a>.</p>
<p>This avoids reallocating where possible, but the conditions for that are
strict, and subject to change, and so shouldn’t be relied upon unless the
<code>Vec&lt;T&gt;</code> came from <code>From&lt;VecDeque&lt;T&gt;&gt;</code> and hasn’t been reallocated.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open=""><summary><div id="impl-From%3CVec%3CT%2C%20A%3E%3E-1" class="impl has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.20.0">1.20.0</span><a class="srclink" href="../../src/alloc/vec/mod.rs.html#2910-2924" title="goto source code">[src]</a></div><a href="#impl-From%3CVec%3CT%2C%20A%3E%3E-1" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, A:&nbsp;<a class="trait" href="../alloc/trait.Allocator.html" title="trait alloc::alloc::Allocator">Allocator</a>&gt; <a class="trait" href="../../core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;<a class="struct" href="struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;T, A&gt;&gt; for <a class="struct" href="../boxed/struct.Box.html" title="struct alloc::boxed::Box">Box</a>&lt;[T], A&gt;</h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.from-14" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../../src/alloc/vec/mod.rs.html#2921-2923" title="goto source code">[src]</a></div><a href="#method.from-14" class="anchor"></a><h4 class="code-header">fn <a href="../../core/convert/trait.From.html#tymethod.from" class="fnname">from</a>(v: <a class="struct" href="struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;T, A&gt;) -&gt; Self</h4></div></summary><div class="docblock"><p>Convert a vector into a boxed slice.</p>
<p>If <code>v</code> has excess capacity, its items will be moved into a
newly-allocated buffer with exactly the right capacity.</p>
<h1 id="examples-54" class="section-header"><a href="#examples-54">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="ident">Box::from</span>(<span class="macro">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]), <span class="macro">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].<span class="ident">into_boxed_slice</span>());</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Aassert_eq!(Box%3A%3Afrom(vec!%5B1%2C%202%2C%203%5D)%2C%20vec!%5B1%2C%202%2C%203%5D.into_boxed_slice())%3B%0A%7D&amp;edition=2018">Run</a></div>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open=""><summary><div id="impl-From%3CVec%3CT%2C%20Global%3E%3E" class="impl has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.5.0">1.5.0</span><a class="srclink" href="../../src/alloc/collections/binary_heap.rs.html#1464-1473" title="goto source code">[src]</a></div><a href="#impl-From%3CVec%3CT%2C%20Global%3E%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T:&nbsp;<a class="trait" href="../../core/cmp/trait.Ord.html" title="trait core::cmp::Ord">Ord</a>&gt; <a class="trait" href="../../core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;<a class="struct" href="struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;T, <a class="struct" href="../alloc/struct.Global.html" title="struct alloc::alloc::Global">Global</a>&gt;&gt; for <a class="struct" href="../collections/binary_heap/struct.BinaryHeap.html" title="struct alloc::collections::binary_heap::BinaryHeap">BinaryHeap</a>&lt;T&gt;</h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.from" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../../src/alloc/collections/binary_heap.rs.html#1468-1472" title="goto source code">[src]</a></div><a href="#method.from" class="anchor"></a><h4 class="code-header">fn <a href="../../core/convert/trait.From.html#tymethod.from" class="fnname">from</a>(vec: <a class="struct" href="struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;T&gt;) -&gt; <a class="struct" href="../collections/binary_heap/struct.BinaryHeap.html" title="struct alloc::collections::binary_heap::BinaryHeap">BinaryHeap</a>&lt;T&gt;</h4></div></summary><div class="docblock"><p>Converts a <code>Vec&lt;T&gt;</code> into a <code>BinaryHeap&lt;T&gt;</code>.</p>
<p>This conversion happens in-place, and has <em>O</em>(<em>n</em>) time complexity.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open=""><summary><div id="impl-From%3CVec%3CT%2C%20Global%3E%3E-1" class="impl has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.21.0">1.21.0</span><a class="srclink" href="../../src/alloc/rc.rs.html#1845-1867" title="goto source code">[src]</a></div><a href="#impl-From%3CVec%3CT%2C%20Global%3E%3E-1" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="../../core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;<a class="struct" href="struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;T, <a class="struct" href="../alloc/struct.Global.html" title="struct alloc::alloc::Global">Global</a>&gt;&gt; for <a class="struct" href="../rc/struct.Rc.html" title="struct alloc::rc::Rc">Rc</a>&lt;[T]&gt;</h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.from-4" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../../src/alloc/rc.rs.html#1857-1866" title="goto source code">[src]</a></div><a href="#method.from-4" class="anchor"></a><h4 class="code-header">fn <a href="../../core/convert/trait.From.html#tymethod.from" class="fnname">from</a>(v: <a class="struct" href="struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;T&gt;) -&gt; <a class="struct" href="../rc/struct.Rc.html" title="struct alloc::rc::Rc">Rc</a>&lt;[T]&gt;</h4></div></summary><div class="docblock"><p>Allocate a reference-counted slice and move <code>v</code>’s items into it.</p>
<h1 id="example" class="section-header"><a href="#example">Example</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">original</span>: <span class="ident">Box</span><span class="op">&lt;</span><span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">i32</span><span class="op">&gt;</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">Box::new</span>(<span class="macro">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);
<span class="kw">let</span> <span class="ident">shared</span>: <span class="ident">Rc</span><span class="op">&lt;</span><span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">i32</span><span class="op">&gt;</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">Rc::from</span>(<span class="ident">original</span>);
<span class="macro">assert_eq!</span>(<span class="macro">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="kw-2">*</span><span class="ident">shared</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Ause%20std%3A%3Arc%3A%3ARc%3B%0Alet%20original%3A%20Box%3CVec%3Ci32%3E%3E%20%3D%20Box%3A%3Anew(vec!%5B1%2C%202%2C%203%5D)%3B%0Alet%20shared%3A%20Rc%3CVec%3Ci32%3E%3E%20%3D%20Rc%3A%3Afrom(original)%3B%0Aassert_eq!(vec!%5B1%2C%202%2C%203%5D%2C%20*shared)%3B%0A%7D&amp;edition=2018">Run</a></div>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open=""><summary><div id="impl-From%3CVec%3CT%2C%20Global%3E%3E-2" class="impl has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.21.0">1.21.0</span><a class="srclink" href="../../src/alloc/sync.rs.html#2434-2456" title="goto source code">[src]</a></div><a href="#impl-From%3CVec%3CT%2C%20Global%3E%3E-2" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="../../core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;<a class="struct" href="struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;T, <a class="struct" href="../alloc/struct.Global.html" title="struct alloc::alloc::Global">Global</a>&gt;&gt; for <a class="struct" href="../sync/struct.Arc.html" title="struct alloc::sync::Arc">Arc</a>&lt;[T]&gt;</h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.from-6" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../../src/alloc/sync.rs.html#2446-2455" title="goto source code">[src]</a></div><a href="#method.from-6" class="anchor"></a><h4 class="code-header">fn <a href="../../core/convert/trait.From.html#tymethod.from" class="fnname">from</a>(v: <a class="struct" href="struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;T&gt;) -&gt; <a class="struct" href="../sync/struct.Arc.html" title="struct alloc::sync::Arc">Arc</a>&lt;[T]&gt;</h4></div></summary><div class="docblock"><p>Allocate a reference-counted slice and move <code>v</code>’s items into it.</p>
<h1 id="example-1" class="section-header"><a href="#example-1">Example</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">unique</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">i32</span><span class="op">&gt;</span> <span class="op">=</span> <span class="macro">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];
<span class="kw">let</span> <span class="ident">shared</span>: <span class="ident">Arc</span><span class="op">&lt;</span>[<span class="ident">i32</span>]<span class="op">&gt;</span> <span class="op">=</span> <span class="ident">Arc::from</span>(<span class="ident">unique</span>);
<span class="macro">assert_eq!</span>(<span class="kw-2">&amp;</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="kw-2">&amp;</span><span class="ident">shared</span>[..]);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Ause%20std%3A%3Async%3A%3AArc%3B%0Alet%20unique%3A%20Vec%3Ci32%3E%20%3D%20vec!%5B1%2C%202%2C%203%5D%3B%0Alet%20shared%3A%20Arc%3C%5Bi32%5D%3E%20%3D%20Arc%3A%3Afrom(unique)%3B%0Aassert_eq!(%26%5B1%2C%202%2C%203%5D%2C%20%26shared%5B..%5D)%3B%0A%7D&amp;edition=2018">Run</a></div>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open=""><summary><div id="impl-From%3CVec%3CT%2C%20Global%3E%3E-3" class="impl has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.8.0">1.8.0</span><a class="srclink" href="../../src/alloc/vec/cow.rs.html#20-30" title="goto source code">[src]</a></div><a href="#impl-From%3CVec%3CT%2C%20Global%3E%3E-3" class="anchor"></a><h3 class="code-header in-band">impl&lt;'a, T:&nbsp;<a class="trait" href="../../core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>&gt; <a class="trait" href="../../core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;<a class="struct" href="struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;T, <a class="struct" href="../alloc/struct.Global.html" title="struct alloc::alloc::Global">Global</a>&gt;&gt; for <a class="enum" href="../borrow/enum.Cow.html" title="enum alloc::borrow::Cow">Cow</a>&lt;'a, [T]&gt;</h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.from-7" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../../src/alloc/vec/cow.rs.html#27-29" title="goto source code">[src]</a></div><a href="#method.from-7" class="anchor"></a><h4 class="code-header">fn <a href="../../core/convert/trait.From.html#tymethod.from" class="fnname">from</a>(v: <a class="struct" href="struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;T&gt;) -&gt; <a class="enum" href="../borrow/enum.Cow.html" title="enum alloc::borrow::Cow">Cow</a>&lt;'a, [T]&gt;</h4></div></summary><div class="docblock"><p>Creates an <a href="../borrow/enum.Cow.html#variant.Owned"><code>Owned</code></a> variant of <a href="../borrow/enum.Cow.html" title="Cow"><code>Cow</code></a>
from an owned instance of <a href="struct.Vec.html" title="Vec"><code>Vec</code></a>.</p>
<p>This conversion does not allocate or clone the data.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open=""><summary><div id="impl-From%3CVecDeque%3CT%2C%20A%3E%3E" class="impl has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.10.0">1.10.0</span><a class="srclink" href="../../src/alloc/collections/vec_deque/mod.rs.html#2949-2995" title="goto source code">[src]</a></div><a href="#impl-From%3CVecDeque%3CT%2C%20A%3E%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, A:&nbsp;<a class="trait" href="../alloc/trait.Allocator.html" title="trait alloc::alloc::Allocator">Allocator</a>&gt; <a class="trait" href="../../core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;<a class="struct" href="../collections/vec_deque/struct.VecDeque.html" title="struct alloc::collections::vec_deque::VecDeque">VecDeque</a>&lt;T, A&gt;&gt; for <a class="struct" href="struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;T, A&gt;</h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.from-3" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../../src/alloc/collections/vec_deque/mod.rs.html#2979-2994" title="goto source code">[src]</a></div><a href="#method.from-3" class="anchor"></a><h4 class="code-header">fn <a href="../../core/convert/trait.From.html#tymethod.from" class="fnname">from</a>(other: <a class="struct" href="../collections/vec_deque/struct.VecDeque.html" title="struct alloc::collections::vec_deque::VecDeque">VecDeque</a>&lt;T, A&gt;) -&gt; Self</h4></div></summary><div class="docblock"><p>Turn a <a href="../collections/vec_deque/struct.VecDeque.html"><code>VecDeque&lt;T&gt;</code></a> into a <a href="struct.Vec.html"><code>Vec&lt;T&gt;</code></a>.</p>
<p>This never needs to re-allocate, but does need to do <em>O</em>(<em>n</em>) data movement if
the circular buffer doesn’t happen to be at the beginning of the allocation.</p>
<h1 id="examples-48" class="section-header"><a href="#examples-48">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">std::collections::VecDeque</span>;

<span class="comment">// This one is *O*(1).</span>
<span class="kw">let</span> <span class="ident">deque</span>: <span class="ident">VecDeque</span><span class="op">&lt;</span><span class="kw">_</span><span class="op">&gt;</span> <span class="op">=</span> (<span class="number">1</span>..<span class="number">5</span>).<span class="ident">collect</span>();
<span class="kw">let</span> <span class="ident">ptr</span> <span class="op">=</span> <span class="ident">deque</span>.<span class="ident">as_slices</span>().<span class="number">0</span>.<span class="ident">as_ptr</span>();
<span class="kw">let</span> <span class="ident">vec</span> <span class="op">=</span> <span class="ident">Vec::from</span>(<span class="ident">deque</span>);
<span class="macro">assert_eq!</span>(<span class="ident">vec</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]);
<span class="macro">assert_eq!</span>(<span class="ident">vec</span>.<span class="ident">as_ptr</span>(), <span class="ident">ptr</span>);

<span class="comment">// This one needs data rearranging.</span>
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">deque</span>: <span class="ident">VecDeque</span><span class="op">&lt;</span><span class="kw">_</span><span class="op">&gt;</span> <span class="op">=</span> (<span class="number">1</span>..<span class="number">5</span>).<span class="ident">collect</span>();
<span class="ident">deque</span>.<span class="ident">push_front</span>(<span class="number">9</span>);
<span class="ident">deque</span>.<span class="ident">push_front</span>(<span class="number">8</span>);
<span class="kw">let</span> <span class="ident">ptr</span> <span class="op">=</span> <span class="ident">deque</span>.<span class="ident">as_slices</span>().<span class="number">1</span>.<span class="ident">as_ptr</span>();
<span class="kw">let</span> <span class="ident">vec</span> <span class="op">=</span> <span class="ident">Vec::from</span>(<span class="ident">deque</span>);
<span class="macro">assert_eq!</span>(<span class="ident">vec</span>, [<span class="number">8</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]);
<span class="macro">assert_eq!</span>(<span class="ident">vec</span>.<span class="ident">as_ptr</span>(), <span class="ident">ptr</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Ause%20std%3A%3Acollections%3A%3AVecDeque%3B%0A%0A%2F%2F%20This%20one%20is%20*O*(1).%0Alet%20deque%3A%20VecDeque%3C_%3E%20%3D%20(1..5).collect()%3B%0Alet%20ptr%20%3D%20deque.as_slices().0.as_ptr()%3B%0Alet%20vec%20%3D%20Vec%3A%3Afrom(deque)%3B%0Aassert_eq!(vec%2C%20%5B1%2C%202%2C%203%2C%204%5D)%3B%0Aassert_eq!(vec.as_ptr()%2C%20ptr)%3B%0A%0A%2F%2F%20This%20one%20needs%20data%20rearranging.%0Alet%20mut%20deque%3A%20VecDeque%3C_%3E%20%3D%20(1..5).collect()%3B%0Adeque.push_front(9)%3B%0Adeque.push_front(8)%3B%0Alet%20ptr%20%3D%20deque.as_slices().1.as_ptr()%3B%0Alet%20vec%20%3D%20Vec%3A%3Afrom(deque)%3B%0Aassert_eq!(vec%2C%20%5B8%2C%209%2C%201%2C%202%2C%203%2C%204%5D)%3B%0Aassert_eq!(vec.as_ptr()%2C%20ptr)%3B%0A%7D&amp;edition=2018">Run</a></div>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open=""><summary><div id="impl-FromIterator%3CT%3E" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../../src/alloc/vec/mod.rs.html#2483-2488" title="goto source code">[src]</a></div><a href="#impl-FromIterator%3CT%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="../../core/iter/traits/collect/trait.FromIterator.html" title="trait core::iter::traits::collect::FromIterator">FromIterator</a>&lt;T&gt; for <a class="struct" href="struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;T&gt;</h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.from_iter" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../../src/alloc/vec/mod.rs.html#2485-2487" title="goto source code">[src]</a></div><a href="#method.from_iter" class="anchor"></a><h4 class="code-header">fn <a href="../../core/iter/traits/collect/trait.FromIterator.html#tymethod.from_iter" class="fnname">from_iter</a>&lt;I:&nbsp;<a class="trait" href="../../core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&lt;Item = T&gt;&gt;(iter: I) -&gt; <a class="struct" href="struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;T&gt;</h4></div></summary><div class='docblock'><p>Creates a value from an iterator. <a href="../../core/iter/traits/collect/trait.FromIterator.html#tymethod.from_iter">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open=""><summary><div id="impl-Hash" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../../src/alloc/vec/mod.rs.html#2448-2453" title="goto source code">[src]</a></div><a href="#impl-Hash" class="anchor"></a><h3 class="code-header in-band">impl&lt;T:&nbsp;<a class="trait" href="../../core/hash/trait.Hash.html" title="trait core::hash::Hash">Hash</a>, A:&nbsp;<a class="trait" href="../alloc/trait.Allocator.html" title="trait alloc::alloc::Allocator">Allocator</a>&gt; <a class="trait" href="../../core/hash/trait.Hash.html" title="trait core::hash::Hash">Hash</a> for <a class="struct" href="struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;T, A&gt;</h3></div></summary><div class="docblock"><p>The hash of a vector is the same as that of the corresponding slice,
as required by the <code>core::borrow::Borrow</code> implementation.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attribute">#![<span class="ident">feature</span>(<span class="ident">build_hasher_simple_hash_one</span>)]</span>
<span class="kw">use</span> <span class="ident">std::hash::BuildHasher</span>;

<span class="kw">let</span> <span class="ident">b</span> <span class="op">=</span> <span class="ident">std::collections::hash_map::RandomState::new</span>();
<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">u8</span><span class="op">&gt;</span> <span class="op">=</span> <span class="macro">vec!</span>[<span class="number">0xa8</span>, <span class="number">0x3c</span>, <span class="number">0x09</span>];
<span class="kw">let</span> <span class="ident">s</span>: <span class="kw-2">&amp;</span>[<span class="ident">u8</span>] <span class="op">=</span> <span class="kw-2">&amp;</span>[<span class="number">0xa8</span>, <span class="number">0x3c</span>, <span class="number">0x09</span>];
<span class="macro">assert_eq!</span>(<span class="ident">b</span>.<span class="ident">hash_one</span>(<span class="ident">v</span>), <span class="ident">b</span>.<span class="ident">hash_one</span>(<span class="ident">s</span>));</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(build_hasher_simple_hash_one)%5D%0Afn%20main()%20%7B%0Ause%20std%3A%3Ahash%3A%3ABuildHasher%3B%0A%0Alet%20b%20%3D%20std%3A%3Acollections%3A%3Ahash_map%3A%3ARandomState%3A%3Anew()%3B%0Alet%20v%3A%20Vec%3Cu8%3E%20%3D%20vec!%5B0xa8%2C%200x3c%2C%200x09%5D%3B%0Alet%20s%3A%20%26%5Bu8%5D%20%3D%20%26%5B0xa8%2C%200x3c%2C%200x09%5D%3B%0Aassert_eq!(b.hash_one(v)%2C%20b.hash_one(s))%3B%0A%7D&amp;version=nightly&amp;edition=2018">Run</a></div>
</div><div class="impl-items"><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.hash" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../../src/alloc/vec/mod.rs.html#2450-2452" title="goto source code">[src]</a></div><a href="#method.hash" class="anchor"></a><h4 class="code-header">fn <a href="../../core/hash/trait.Hash.html#tymethod.hash" class="fnname">hash</a>&lt;H:&nbsp;<a class="trait" href="../../core/hash/trait.Hasher.html" title="trait core::hash::Hasher">Hasher</a>&gt;(&amp;self, state: &amp;mut H)</h4></div></summary><div class='docblock'><p>Feeds this value into the given <a href="../../core/hash/trait.Hasher.html" title="Hasher"><code>Hasher</code></a>. <a href="../../core/hash/trait.Hash.html#tymethod.hash">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.hash_slice" class="method trait-impl has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.3.0">1.3.0</span><a class="srclink" href="../../src/core/hash/mod.rs.html#211-213" title="goto source code">[src]</a></div><a href="#method.hash_slice" class="anchor"></a><h4 class="code-header">fn <a href="../../core/hash/trait.Hash.html#method.hash_slice" class="fnname">hash_slice</a>&lt;H&gt;(data: &amp;[Self], state: &amp;mut H) <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;H: <a class="trait" href="../../core/hash/trait.Hasher.html" title="trait core::hash::Hasher">Hasher</a>,&nbsp;</span></h4></div></summary><div class='docblock'><p>Feeds a slice of this type into the given <a href="../../core/hash/trait.Hasher.html" title="Hasher"><code>Hasher</code></a>. <a href="../../core/hash/trait.Hash.html#method.hash_slice">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open=""><summary><div id="impl-Index%3CI%3E" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../../src/alloc/vec/mod.rs.html#2460-2467" title="goto source code">[src]</a></div><a href="#impl-Index%3CI%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, I:&nbsp;<a class="trait" href="../slice/trait.SliceIndex.html" title="trait alloc::slice::SliceIndex">SliceIndex</a>&lt;[T]&gt;, A:&nbsp;<a class="trait" href="../alloc/trait.Allocator.html" title="trait alloc::alloc::Allocator">Allocator</a>&gt; <a class="trait" href="../../core/ops/index/trait.Index.html" title="trait core::ops::index::Index">Index</a>&lt;I&gt; for <a class="struct" href="struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;T, A&gt;</h3></div></summary><div class="impl-items"><details class="rustdoc-toggle" open=""><summary><div id="associatedtype.Output" class="type trait-impl has-srclink"><a href="#associatedtype.Output" class="anchor"></a><h4 class="code-header">type <a href="../../core/ops/index/trait.Index.html#associatedtype.Output" class="type">Output</a> = I::<a class="type" href="../slice/trait.SliceIndex.html#associatedtype.Output" title="type alloc::slice::SliceIndex::Output">Output</a></h4></div></summary><div class='docblock'><p>The returned type after indexing.</p>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.index" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../../src/alloc/vec/mod.rs.html#2464-2466" title="goto source code">[src]</a></div><a href="#method.index" class="anchor"></a><h4 class="code-header">fn <a href="../../core/ops/index/trait.Index.html#tymethod.index" class="fnname">index</a>(&amp;self, index: I) -&gt; &amp;Self::<a class="type" href="../../core/ops/index/trait.Index.html#associatedtype.Output" title="type core::ops::index::Index::Output">Output</a></h4></div></summary><div class='docblock'><p>Performs the indexing (<code>container[index]</code>) operation. <a href="../../core/ops/index/trait.Index.html#tymethod.index">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open=""><summary><div id="impl-IndexMut%3CI%3E" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../../src/alloc/vec/mod.rs.html#2474-2479" title="goto source code">[src]</a></div><a href="#impl-IndexMut%3CI%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, I:&nbsp;<a class="trait" href="../slice/trait.SliceIndex.html" title="trait alloc::slice::SliceIndex">SliceIndex</a>&lt;[T]&gt;, A:&nbsp;<a class="trait" href="../alloc/trait.Allocator.html" title="trait alloc::alloc::Allocator">Allocator</a>&gt; <a class="trait" href="../../core/ops/index/trait.IndexMut.html" title="trait core::ops::index::IndexMut">IndexMut</a>&lt;I&gt; for <a class="struct" href="struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;T, A&gt;</h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.index_mut" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../../src/alloc/vec/mod.rs.html#2476-2478" title="goto source code">[src]</a></div><a href="#method.index_mut" class="anchor"></a><h4 class="code-header">fn <a href="../../core/ops/index/trait.IndexMut.html#tymethod.index_mut" class="fnname">index_mut</a>(&amp;mut self, index: I) -&gt; &amp;mut Self::<a class="type" href="../../core/ops/index/trait.Index.html#associatedtype.Output" title="type core::ops::index::Index::Output">Output</a></h4></div></summary><div class='docblock'><p>Performs the mutable indexing (<code>container[index]</code>) operation. <a href="../../core/ops/index/trait.IndexMut.html#tymethod.index_mut">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open=""><summary><div id="impl-IntoIterator" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../../src/alloc/vec/mod.rs.html#2491-2530" title="goto source code">[src]</a></div><a href="#impl-IntoIterator" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, A:&nbsp;<a class="trait" href="../alloc/trait.Allocator.html" title="trait alloc::alloc::Allocator">Allocator</a>&gt; <a class="trait" href="../../core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a> for <a class="struct" href="struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;T, A&gt;</h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.into_iter" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../../src/alloc/vec/mod.rs.html#2509-2529" title="goto source code">[src]</a></div><a href="#method.into_iter" class="anchor"></a><h4 class="code-header">fn <a href="../../core/iter/traits/collect/trait.IntoIterator.html#tymethod.into_iter" class="fnname">into_iter</a>(self) -&gt; <a class="struct" href="struct.IntoIter.html" title="struct alloc::vec::IntoIter">IntoIter</a>&lt;T, A&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><div class="notable">Notable traits for <a class="struct" href="struct.IntoIter.html" title="struct alloc::vec::IntoIter">IntoIter</a>&lt;T, A&gt;</div><code class="content"><span class="where fmt-newline">impl&lt;T, A:&nbsp;<a class="trait" href="../alloc/trait.Allocator.html" title="trait alloc::alloc::Allocator">Allocator</a>&gt; <a class="trait" href="../../core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="struct.IntoIter.html" title="struct alloc::vec::IntoIter">IntoIter</a>&lt;T, A&gt;</span><span class="where fmt-newline">    type <a href="../../core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="type">Item</a> = T;</span></code></span></div></span></span></h4></div></summary><div class="docblock"><p>Creates a consuming iterator, that is, one that moves each value out of
the vector (from start to end). The vector cannot be used after calling
this.</p>
<h1 id="examples-56" class="section-header"><a href="#examples-56">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">v</span> <span class="op">=</span> <span class="macro">vec!</span>[<span class="string">&quot;a&quot;</span>.<span class="ident">to_string</span>(), <span class="string">&quot;b&quot;</span>.<span class="ident">to_string</span>()];
<span class="kw">for</span> <span class="ident">s</span> <span class="kw">in</span> <span class="ident">v</span>.<span class="ident">into_iter</span>() {
    <span class="comment">// s has type String, not &amp;String</span>
    <span class="macro">println!</span>(<span class="string">&quot;{}&quot;</span>, <span class="ident">s</span>);
}</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20v%20%3D%20vec!%5B%22a%22.to_string()%2C%20%22b%22.to_string()%5D%3B%0Afor%20s%20in%20v.into_iter()%20%7B%0A%20%20%20%20%2F%2F%20s%20has%20type%20String%2C%20not%20%26String%0A%20%20%20%20println!(%22%7B%7D%22%2C%20s)%3B%0A%7D%0A%7D&amp;edition=2018">Run</a></div>
</div></details><details class="rustdoc-toggle" open=""><summary><div id="associatedtype.Item" class="type trait-impl has-srclink"><a href="#associatedtype.Item" class="anchor"></a><h4 class="code-header">type <a href="../../core/iter/traits/collect/trait.IntoIterator.html#associatedtype.Item" class="type">Item</a> = T</h4></div></summary><div class='docblock'><p>The type of the elements being iterated over.</p>
</div></details><details class="rustdoc-toggle" open=""><summary><div id="associatedtype.IntoIter" class="type trait-impl has-srclink"><a href="#associatedtype.IntoIter" class="anchor"></a><h4 class="code-header">type <a href="../../core/iter/traits/collect/trait.IntoIterator.html#associatedtype.IntoIter" class="type">IntoIter</a> = <a class="struct" href="struct.IntoIter.html" title="struct alloc::vec::IntoIter">IntoIter</a>&lt;T, A&gt;</h4></div></summary><div class='docblock'><p>Which kind of iterator are we turning this into?</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open=""><summary><div id="impl-IntoIterator-1" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../../src/alloc/vec/mod.rs.html#2533-2540" title="goto source code">[src]</a></div><a href="#impl-IntoIterator-1" class="anchor"></a><h3 class="code-header in-band">impl&lt;'a, T, A:&nbsp;<a class="trait" href="../alloc/trait.Allocator.html" title="trait alloc::alloc::Allocator">Allocator</a>&gt; <a class="trait" href="../../core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a> for &amp;'a <a class="struct" href="struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;T, A&gt;</h3></div></summary><div class="impl-items"><details class="rustdoc-toggle" open=""><summary><div id="associatedtype.Item-1" class="type trait-impl has-srclink"><a href="#associatedtype.Item-1" class="anchor"></a><h4 class="code-header">type <a href="../../core/iter/traits/collect/trait.IntoIterator.html#associatedtype.Item" class="type">Item</a> = &amp;'a T</h4></div></summary><div class='docblock'><p>The type of the elements being iterated over.</p>
</div></details><details class="rustdoc-toggle" open=""><summary><div id="associatedtype.IntoIter-1" class="type trait-impl has-srclink"><a href="#associatedtype.IntoIter-1" class="anchor"></a><h4 class="code-header">type <a href="../../core/iter/traits/collect/trait.IntoIterator.html#associatedtype.IntoIter" class="type">IntoIter</a> = <a class="struct" href="../slice/struct.Iter.html" title="struct alloc::slice::Iter">Iter</a>&lt;'a, T&gt;</h4></div></summary><div class='docblock'><p>Which kind of iterator are we turning this into?</p>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.into_iter-1" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../../src/alloc/vec/mod.rs.html#2537-2539" title="goto source code">[src]</a></div><a href="#method.into_iter-1" class="anchor"></a><h4 class="code-header">fn <a href="../../core/iter/traits/collect/trait.IntoIterator.html#tymethod.into_iter" class="fnname">into_iter</a>(self) -&gt; <a class="struct" href="../slice/struct.Iter.html" title="struct alloc::slice::Iter">Iter</a>&lt;'a, T&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><div class="notable">Notable traits for <a class="struct" href="../slice/struct.Iter.html" title="struct alloc::slice::Iter">Iter</a>&lt;'a, T&gt;</div><code class="content"><span class="where fmt-newline">impl&lt;'a, T&gt; <a class="trait" href="../../core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="../slice/struct.Iter.html" title="struct alloc::slice::Iter">Iter</a>&lt;'a, T&gt;</span><span class="where fmt-newline">    type <a href="../../core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="type">Item</a> = &amp;'a T;</span></code></span></div></span></span></h4></div></summary><div class='docblock'><p>Creates an iterator from a value. <a href="../../core/iter/traits/collect/trait.IntoIterator.html#tymethod.into_iter">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open=""><summary><div id="impl-IntoIterator-2" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../../src/alloc/vec/mod.rs.html#2543-2550" title="goto source code">[src]</a></div><a href="#impl-IntoIterator-2" class="anchor"></a><h3 class="code-header in-band">impl&lt;'a, T, A:&nbsp;<a class="trait" href="../alloc/trait.Allocator.html" title="trait alloc::alloc::Allocator">Allocator</a>&gt; <a class="trait" href="../../core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a> for &amp;'a mut <a class="struct" href="struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;T, A&gt;</h3></div></summary><div class="impl-items"><details class="rustdoc-toggle" open=""><summary><div id="associatedtype.Item-2" class="type trait-impl has-srclink"><a href="#associatedtype.Item-2" class="anchor"></a><h4 class="code-header">type <a href="../../core/iter/traits/collect/trait.IntoIterator.html#associatedtype.Item" class="type">Item</a> = &amp;'a mut T</h4></div></summary><div class='docblock'><p>The type of the elements being iterated over.</p>
</div></details><details class="rustdoc-toggle" open=""><summary><div id="associatedtype.IntoIter-2" class="type trait-impl has-srclink"><a href="#associatedtype.IntoIter-2" class="anchor"></a><h4 class="code-header">type <a href="../../core/iter/traits/collect/trait.IntoIterator.html#associatedtype.IntoIter" class="type">IntoIter</a> = <a class="struct" href="../slice/struct.IterMut.html" title="struct alloc::slice::IterMut">IterMut</a>&lt;'a, T&gt;</h4></div></summary><div class='docblock'><p>Which kind of iterator are we turning this into?</p>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.into_iter-2" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../../src/alloc/vec/mod.rs.html#2547-2549" title="goto source code">[src]</a></div><a href="#method.into_iter-2" class="anchor"></a><h4 class="code-header">fn <a href="../../core/iter/traits/collect/trait.IntoIterator.html#tymethod.into_iter" class="fnname">into_iter</a>(self) -&gt; <a class="struct" href="../slice/struct.IterMut.html" title="struct alloc::slice::IterMut">IterMut</a>&lt;'a, T&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><div class="notable">Notable traits for <a class="struct" href="../slice/struct.IterMut.html" title="struct alloc::slice::IterMut">IterMut</a>&lt;'a, T&gt;</div><code class="content"><span class="where fmt-newline">impl&lt;'a, T&gt; <a class="trait" href="../../core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="../slice/struct.IterMut.html" title="struct alloc::slice::IterMut">IterMut</a>&lt;'a, T&gt;</span><span class="where fmt-newline">    type <a href="../../core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="type">Item</a> = &amp;'a mut T;</span></code></span></div></span></span></h4></div></summary><div class='docblock'><p>Creates an iterator from a value. <a href="../../core/iter/traits/collect/trait.IntoIterator.html#tymethod.into_iter">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open=""><summary><div id="impl-Ord" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../../src/alloc/vec/mod.rs.html#2741-2746" title="goto source code">[src]</a></div><a href="#impl-Ord" class="anchor"></a><h3 class="code-header in-band">impl&lt;T:&nbsp;<a class="trait" href="../../core/cmp/trait.Ord.html" title="trait core::cmp::Ord">Ord</a>, A:&nbsp;<a class="trait" href="../alloc/trait.Allocator.html" title="trait alloc::alloc::Allocator">Allocator</a>&gt; <a class="trait" href="../../core/cmp/trait.Ord.html" title="trait core::cmp::Ord">Ord</a> for <a class="struct" href="struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;T, A&gt;</h3></div></summary><div class="docblock"><p>Implements ordering of vectors, <a href="../../core/cmp/trait.Ord.html#lexicographical-comparison">lexicographically</a>.</p>
</div><div class="impl-items"><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.cmp" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../../src/alloc/vec/mod.rs.html#2743-2745" title="goto source code">[src]</a></div><a href="#method.cmp" class="anchor"></a><h4 class="code-header">fn <a href="../../core/cmp/trait.Ord.html#tymethod.cmp" class="fnname">cmp</a>(&amp;self, other: &amp;Self) -&gt; <a class="enum" href="../../core/cmp/enum.Ordering.html" title="enum core::cmp::Ordering">Ordering</a></h4></div></summary><div class='docblock'><p>This method returns an <a href="../../core/cmp/enum.Ordering.html" title="Ordering"><code>Ordering</code></a> between <code>self</code> and <code>other</code>. <a href="../../core/cmp/trait.Ord.html#tymethod.cmp">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.max" class="method trait-impl has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.21.0">1.21.0</span><a class="srclink" href="../../src/core/cmp.rs.html#763-765" title="goto source code">[src]</a></div><a href="#method.max" class="anchor"></a><h4 class="code-header">fn <a href="../../core/cmp/trait.Ord.html#method.max" class="fnname">max</a>(self, other: Self) -&gt; Self</h4></div></summary><div class='docblock'><p>Compares and returns the maximum of two values. <a href="../../core/cmp/trait.Ord.html#method.max">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.min" class="method trait-impl has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.21.0">1.21.0</span><a class="srclink" href="../../src/core/cmp.rs.html#783-785" title="goto source code">[src]</a></div><a href="#method.min" class="anchor"></a><h4 class="code-header">fn <a href="../../core/cmp/trait.Ord.html#method.min" class="fnname">min</a>(self, other: Self) -&gt; Self</h4></div></summary><div class='docblock'><p>Compares and returns the minimum of two values. <a href="../../core/cmp/trait.Ord.html#method.min">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.clamp" class="method trait-impl has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.50.0">1.50.0</span><a class="srclink" href="../../src/core/cmp.rs.html#808-810" title="goto source code">[src]</a></div><a href="#method.clamp" class="anchor"></a><h4 class="code-header">fn <a href="../../core/cmp/trait.Ord.html#method.clamp" class="fnname">clamp</a>(self, min: Self, max: Self) -&gt; Self</h4></div></summary><div class='docblock'><p>Restrict a value to a certain interval. <a href="../../core/cmp/trait.Ord.html#method.clamp">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open=""><summary><div id="impl-PartialEq%3C%26%27_%20%5BU%3B%20N%5D%3E" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../../src/alloc/vec/partial_eq.rs.html#37" title="goto source code">[src]</a></div><a href="#impl-PartialEq%3C%26%27_%20%5BU%3B%20N%5D%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, U, A:&nbsp;<a class="trait" href="../alloc/trait.Allocator.html" title="trait alloc::alloc::Allocator">Allocator</a>, const N:&nbsp;usize&gt; <a class="trait" href="../../core/cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a>&lt;&amp;'_ [U; N]&gt; for <a class="struct" href="struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;T, A&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../core/cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a>&lt;U&gt;,&nbsp;</span></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.eq-10" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../../src/alloc/vec/partial_eq.rs.html#37" title="goto source code">[src]</a></div><a href="#method.eq-10" class="anchor"></a><h4 class="code-header">fn <a href="../../core/cmp/trait.PartialEq.html#tymethod.eq" class="fnname">eq</a>(&amp;self, other: &amp;&amp;[U; N]) -&gt; bool</h4></div></summary><div class='docblock'><p>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used
by <code>==</code>. <a href="../../core/cmp/trait.PartialEq.html#tymethod.eq">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.ne-10" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../../src/alloc/vec/partial_eq.rs.html#37" title="goto source code">[src]</a></div><a href="#method.ne-10" class="anchor"></a><h4 class="code-header">fn <a href="../../core/cmp/trait.PartialEq.html#method.ne" class="fnname">ne</a>(&amp;self, other: &amp;&amp;[U; N]) -&gt; bool</h4></div></summary><div class='docblock'><p>This method tests for <code>!=</code>.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open=""><summary><div id="impl-PartialEq%3C%26%27_%20%5BU%5D%3E" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../../src/alloc/vec/partial_eq.rs.html#24" title="goto source code">[src]</a></div><a href="#impl-PartialEq%3C%26%27_%20%5BU%5D%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, U, A:&nbsp;<a class="trait" href="../alloc/trait.Allocator.html" title="trait alloc::alloc::Allocator">Allocator</a>&gt; <a class="trait" href="../../core/cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a>&lt;&amp;'_ [U]&gt; for <a class="struct" href="struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;T, A&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../core/cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a>&lt;U&gt;,&nbsp;</span></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.eq-2" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../../src/alloc/vec/partial_eq.rs.html#24" title="goto source code">[src]</a></div><a href="#method.eq-2" class="anchor"></a><h4 class="code-header">fn <a href="../../core/cmp/trait.PartialEq.html#tymethod.eq" class="fnname">eq</a>(&amp;self, other: &amp;&amp;[U]) -&gt; bool</h4></div></summary><div class='docblock'><p>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used
by <code>==</code>. <a href="../../core/cmp/trait.PartialEq.html#tymethod.eq">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.ne-2" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../../src/alloc/vec/partial_eq.rs.html#24" title="goto source code">[src]</a></div><a href="#method.ne-2" class="anchor"></a><h4 class="code-header">fn <a href="../../core/cmp/trait.PartialEq.html#method.ne" class="fnname">ne</a>(&amp;self, other: &amp;&amp;[U]) -&gt; bool</h4></div></summary><div class='docblock'><p>This method tests for <code>!=</code>.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open=""><summary><div id="impl-PartialEq%3C%26%27_%20mut%20%5BU%5D%3E" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../../src/alloc/vec/partial_eq.rs.html#25" title="goto source code">[src]</a></div><a href="#impl-PartialEq%3C%26%27_%20mut%20%5BU%5D%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, U, A:&nbsp;<a class="trait" href="../alloc/trait.Allocator.html" title="trait alloc::alloc::Allocator">Allocator</a>&gt; <a class="trait" href="../../core/cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a>&lt;&amp;'_ mut [U]&gt; for <a class="struct" href="struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;T, A&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../core/cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a>&lt;U&gt;,&nbsp;</span></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.eq-3" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../../src/alloc/vec/partial_eq.rs.html#25" title="goto source code">[src]</a></div><a href="#method.eq-3" class="anchor"></a><h4 class="code-header">fn <a href="../../core/cmp/trait.PartialEq.html#tymethod.eq" class="fnname">eq</a>(&amp;self, other: &amp;&amp;mut [U]) -&gt; bool</h4></div></summary><div class='docblock'><p>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used
by <code>==</code>. <a href="../../core/cmp/trait.PartialEq.html#tymethod.eq">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.ne-3" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../../src/alloc/vec/partial_eq.rs.html#25" title="goto source code">[src]</a></div><a href="#method.ne-3" class="anchor"></a><h4 class="code-header">fn <a href="../../core/cmp/trait.PartialEq.html#method.ne" class="fnname">ne</a>(&amp;self, other: &amp;&amp;mut [U]) -&gt; bool</h4></div></summary><div class='docblock'><p>This method tests for <code>!=</code>.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open=""><summary><div id="impl-PartialEq%3C%5BU%3B%20N%5D%3E" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../../src/alloc/vec/partial_eq.rs.html#36" title="goto source code">[src]</a></div><a href="#impl-PartialEq%3C%5BU%3B%20N%5D%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, U, A:&nbsp;<a class="trait" href="../alloc/trait.Allocator.html" title="trait alloc::alloc::Allocator">Allocator</a>, const N:&nbsp;usize&gt; <a class="trait" href="../../core/cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a>&lt;[U; N]&gt; for <a class="struct" href="struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;T, A&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../core/cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a>&lt;U&gt;,&nbsp;</span></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.eq-9" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../../src/alloc/vec/partial_eq.rs.html#36" title="goto source code">[src]</a></div><a href="#method.eq-9" class="anchor"></a><h4 class="code-header">fn <a href="../../core/cmp/trait.PartialEq.html#tymethod.eq" class="fnname">eq</a>(&amp;self, other: &amp;[U; N]) -&gt; bool</h4></div></summary><div class='docblock'><p>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used
by <code>==</code>. <a href="../../core/cmp/trait.PartialEq.html#tymethod.eq">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.ne-9" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../../src/alloc/vec/partial_eq.rs.html#36" title="goto source code">[src]</a></div><a href="#method.ne-9" class="anchor"></a><h4 class="code-header">fn <a href="../../core/cmp/trait.PartialEq.html#method.ne" class="fnname">ne</a>(&amp;self, other: &amp;[U; N]) -&gt; bool</h4></div></summary><div class='docblock'><p>This method tests for <code>!=</code>.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open=""><summary><div id="impl-PartialEq%3C%5BU%5D%3E" class="impl has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.48.0">1.48.0</span><a class="srclink" href="../../src/alloc/vec/partial_eq.rs.html#28" title="goto source code">[src]</a></div><a href="#impl-PartialEq%3C%5BU%5D%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, U, A:&nbsp;<a class="trait" href="../alloc/trait.Allocator.html" title="trait alloc::alloc::Allocator">Allocator</a>&gt; <a class="trait" href="../../core/cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a>&lt;[U]&gt; for <a class="struct" href="struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;T, A&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../core/cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a>&lt;U&gt;,&nbsp;</span></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.eq-6" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../../src/alloc/vec/partial_eq.rs.html#28" title="goto source code">[src]</a></div><a href="#method.eq-6" class="anchor"></a><h4 class="code-header">fn <a href="../../core/cmp/trait.PartialEq.html#tymethod.eq" class="fnname">eq</a>(&amp;self, other: &amp;[U]) -&gt; bool</h4></div></summary><div class='docblock'><p>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used
by <code>==</code>. <a href="../../core/cmp/trait.PartialEq.html#tymethod.eq">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.ne-6" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../../src/alloc/vec/partial_eq.rs.html#28" title="goto source code">[src]</a></div><a href="#method.ne-6" class="anchor"></a><h4 class="code-header">fn <a href="../../core/cmp/trait.PartialEq.html#method.ne" class="fnname">ne</a>(&amp;self, other: &amp;[U]) -&gt; bool</h4></div></summary><div class='docblock'><p>This method tests for <code>!=</code>.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open=""><summary><div id="impl-PartialEq%3CVec%3CU%2C%20A%3E%3E" class="impl has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.17.0">1.17.0</span><a class="srclink" href="../../src/alloc/collections/vec_deque/mod.rs.html#2758" title="goto source code">[src]</a></div><a href="#impl-PartialEq%3CVec%3CU%2C%20A%3E%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, U, A:&nbsp;<a class="trait" href="../alloc/trait.Allocator.html" title="trait alloc::alloc::Allocator">Allocator</a>&gt; <a class="trait" href="../../core/cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a>&lt;<a class="struct" href="struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;U, A&gt;&gt; for <a class="struct" href="../collections/vec_deque/struct.VecDeque.html" title="struct alloc::collections::vec_deque::VecDeque">VecDeque</a>&lt;T, A&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../core/cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a>&lt;U&gt;,&nbsp;</span></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.eq" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../../src/alloc/collections/vec_deque/mod.rs.html#2758" title="goto source code">[src]</a></div><a href="#method.eq" class="anchor"></a><h4 class="code-header">fn <a href="../../core/cmp/trait.PartialEq.html#tymethod.eq" class="fnname">eq</a>(&amp;self, other: &amp;<a class="struct" href="struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;U, A&gt;) -&gt; bool</h4></div></summary><div class='docblock'><p>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used
by <code>==</code>. <a href="../../core/cmp/trait.PartialEq.html#tymethod.eq">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.ne" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../../src/core/cmp.rs.html#217" title="goto source code">[src]</a></div><a href="#method.ne" class="anchor"></a><h4 class="code-header">fn <a href="../../core/cmp/trait.PartialEq.html#method.ne" class="fnname">ne</a>(&amp;self, other: &amp;Rhs) -&gt; bool</h4></div></summary><div class='docblock'><p>This method tests for <code>!=</code>.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open=""><summary><div id="impl-PartialEq%3CVec%3CU%2C%20A%3E%3E-1" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../../src/alloc/vec/partial_eq.rs.html#23" title="goto source code">[src]</a></div><a href="#impl-PartialEq%3CVec%3CU%2C%20A%3E%3E-1" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, U, A:&nbsp;<a class="trait" href="../alloc/trait.Allocator.html" title="trait alloc::alloc::Allocator">Allocator</a>&gt; <a class="trait" href="../../core/cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a>&lt;<a class="struct" href="struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;U, A&gt;&gt; for <a class="struct" href="struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;T, A&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../core/cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a>&lt;U&gt;,&nbsp;</span></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.eq-1" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../../src/alloc/vec/partial_eq.rs.html#23" title="goto source code">[src]</a></div><a href="#method.eq-1" class="anchor"></a><h4 class="code-header">fn <a href="../../core/cmp/trait.PartialEq.html#tymethod.eq" class="fnname">eq</a>(&amp;self, other: &amp;<a class="struct" href="struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;U, A&gt;) -&gt; bool</h4></div></summary><div class='docblock'><p>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used
by <code>==</code>. <a href="../../core/cmp/trait.PartialEq.html#tymethod.eq">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.ne-1" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../../src/alloc/vec/partial_eq.rs.html#23" title="goto source code">[src]</a></div><a href="#method.ne-1" class="anchor"></a><h4 class="code-header">fn <a href="../../core/cmp/trait.PartialEq.html#method.ne" class="fnname">ne</a>(&amp;self, other: &amp;<a class="struct" href="struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;U, A&gt;) -&gt; bool</h4></div></summary><div class='docblock'><p>This method tests for <code>!=</code>.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open=""><summary><div id="impl-PartialEq%3CVec%3CU%2C%20A%3E%3E-2" class="impl has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.46.0">1.46.0</span><a class="srclink" href="../../src/alloc/vec/partial_eq.rs.html#26" title="goto source code">[src]</a></div><a href="#impl-PartialEq%3CVec%3CU%2C%20A%3E%3E-2" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, U, A:&nbsp;<a class="trait" href="../alloc/trait.Allocator.html" title="trait alloc::alloc::Allocator">Allocator</a>&gt; <a class="trait" href="../../core/cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a>&lt;<a class="struct" href="struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;U, A&gt;&gt; for &amp;[T] <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../core/cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a>&lt;U&gt;,&nbsp;</span></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.eq-4" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../../src/alloc/vec/partial_eq.rs.html#26" title="goto source code">[src]</a></div><a href="#method.eq-4" class="anchor"></a><h4 class="code-header">fn <a href="../../core/cmp/trait.PartialEq.html#tymethod.eq" class="fnname">eq</a>(&amp;self, other: &amp;<a class="struct" href="struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;U, A&gt;) -&gt; bool</h4></div></summary><div class='docblock'><p>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used
by <code>==</code>. <a href="../../core/cmp/trait.PartialEq.html#tymethod.eq">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.ne-4" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../../src/alloc/vec/partial_eq.rs.html#26" title="goto source code">[src]</a></div><a href="#method.ne-4" class="anchor"></a><h4 class="code-header">fn <a href="../../core/cmp/trait.PartialEq.html#method.ne" class="fnname">ne</a>(&amp;self, other: &amp;<a class="struct" href="struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;U, A&gt;) -&gt; bool</h4></div></summary><div class='docblock'><p>This method tests for <code>!=</code>.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open=""><summary><div id="impl-PartialEq%3CVec%3CU%2C%20A%3E%3E-3" class="impl has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.46.0">1.46.0</span><a class="srclink" href="../../src/alloc/vec/partial_eq.rs.html#27" title="goto source code">[src]</a></div><a href="#impl-PartialEq%3CVec%3CU%2C%20A%3E%3E-3" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, U, A:&nbsp;<a class="trait" href="../alloc/trait.Allocator.html" title="trait alloc::alloc::Allocator">Allocator</a>&gt; <a class="trait" href="../../core/cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a>&lt;<a class="struct" href="struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;U, A&gt;&gt; for &amp;mut [T] <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../core/cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a>&lt;U&gt;,&nbsp;</span></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.eq-5" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../../src/alloc/vec/partial_eq.rs.html#27" title="goto source code">[src]</a></div><a href="#method.eq-5" class="anchor"></a><h4 class="code-header">fn <a href="../../core/cmp/trait.PartialEq.html#tymethod.eq" class="fnname">eq</a>(&amp;self, other: &amp;<a class="struct" href="struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;U, A&gt;) -&gt; bool</h4></div></summary><div class='docblock'><p>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used
by <code>==</code>. <a href="../../core/cmp/trait.PartialEq.html#tymethod.eq">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.ne-5" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../../src/alloc/vec/partial_eq.rs.html#27" title="goto source code">[src]</a></div><a href="#method.ne-5" class="anchor"></a><h4 class="code-header">fn <a href="../../core/cmp/trait.PartialEq.html#method.ne" class="fnname">ne</a>(&amp;self, other: &amp;<a class="struct" href="struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;U, A&gt;) -&gt; bool</h4></div></summary><div class='docblock'><p>This method tests for <code>!=</code>.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open=""><summary><div id="impl-PartialEq%3CVec%3CU%2C%20A%3E%3E-4" class="impl has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.48.0">1.48.0</span><a class="srclink" href="../../src/alloc/vec/partial_eq.rs.html#29" title="goto source code">[src]</a></div><a href="#impl-PartialEq%3CVec%3CU%2C%20A%3E%3E-4" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, U, A:&nbsp;<a class="trait" href="../alloc/trait.Allocator.html" title="trait alloc::alloc::Allocator">Allocator</a>&gt; <a class="trait" href="../../core/cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a>&lt;<a class="struct" href="struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;U, A&gt;&gt; for [T] <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../core/cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a>&lt;U&gt;,&nbsp;</span></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.eq-7" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../../src/alloc/vec/partial_eq.rs.html#29" title="goto source code">[src]</a></div><a href="#method.eq-7" class="anchor"></a><h4 class="code-header">fn <a href="../../core/cmp/trait.PartialEq.html#tymethod.eq" class="fnname">eq</a>(&amp;self, other: &amp;<a class="struct" href="struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;U, A&gt;) -&gt; bool</h4></div></summary><div class='docblock'><p>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used
by <code>==</code>. <a href="../../core/cmp/trait.PartialEq.html#tymethod.eq">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.ne-7" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../../src/alloc/vec/partial_eq.rs.html#29" title="goto source code">[src]</a></div><a href="#method.ne-7" class="anchor"></a><h4 class="code-header">fn <a href="../../core/cmp/trait.PartialEq.html#method.ne" class="fnname">ne</a>(&amp;self, other: &amp;<a class="struct" href="struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;U, A&gt;) -&gt; bool</h4></div></summary><div class='docblock'><p>This method tests for <code>!=</code>.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open=""><summary><div id="impl-PartialEq%3CVec%3CU%2C%20A%3E%3E-5" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../../src/alloc/vec/partial_eq.rs.html#31" title="goto source code">[src]</a></div><a href="#impl-PartialEq%3CVec%3CU%2C%20A%3E%3E-5" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, U, A:&nbsp;<a class="trait" href="../alloc/trait.Allocator.html" title="trait alloc::alloc::Allocator">Allocator</a>&gt; <a class="trait" href="../../core/cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a>&lt;<a class="struct" href="struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;U, A&gt;&gt; for <a class="enum" href="../borrow/enum.Cow.html" title="enum alloc::borrow::Cow">Cow</a>&lt;'_, [T]&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../core/cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a>&lt;U&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,&nbsp;</span></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.eq-8" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../../src/alloc/vec/partial_eq.rs.html#31" title="goto source code">[src]</a></div><a href="#method.eq-8" class="anchor"></a><h4 class="code-header">fn <a href="../../core/cmp/trait.PartialEq.html#tymethod.eq" class="fnname">eq</a>(&amp;self, other: &amp;<a class="struct" href="struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;U, A&gt;) -&gt; bool</h4></div></summary><div class='docblock'><p>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used
by <code>==</code>. <a href="../../core/cmp/trait.PartialEq.html#tymethod.eq">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.ne-8" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../../src/alloc/vec/partial_eq.rs.html#31" title="goto source code">[src]</a></div><a href="#method.ne-8" class="anchor"></a><h4 class="code-header">fn <a href="../../core/cmp/trait.PartialEq.html#method.ne" class="fnname">ne</a>(&amp;self, other: &amp;<a class="struct" href="struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;U, A&gt;) -&gt; bool</h4></div></summary><div class='docblock'><p>This method tests for <code>!=</code>.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open=""><summary><div id="impl-PartialOrd%3CVec%3CT%2C%20A%3E%3E" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../../src/alloc/vec/mod.rs.html#2729-2734" title="goto source code">[src]</a></div><a href="#impl-PartialOrd%3CVec%3CT%2C%20A%3E%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T:&nbsp;<a class="trait" href="../../core/cmp/trait.PartialOrd.html" title="trait core::cmp::PartialOrd">PartialOrd</a>, A:&nbsp;<a class="trait" href="../alloc/trait.Allocator.html" title="trait alloc::alloc::Allocator">Allocator</a>&gt; <a class="trait" href="../../core/cmp/trait.PartialOrd.html" title="trait core::cmp::PartialOrd">PartialOrd</a>&lt;<a class="struct" href="struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;T, A&gt;&gt; for <a class="struct" href="struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;T, A&gt;</h3></div></summary><div class="docblock"><p>Implements comparison of vectors, <a href="../../core/cmp/trait.Ord.html#lexicographical-comparison">lexicographically</a>.</p>
</div><div class="impl-items"><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.partial_cmp" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../../src/alloc/vec/mod.rs.html#2731-2733" title="goto source code">[src]</a></div><a href="#method.partial_cmp" class="anchor"></a><h4 class="code-header">fn <a href="../../core/cmp/trait.PartialOrd.html#tymethod.partial_cmp" class="fnname">partial_cmp</a>(&amp;self, other: &amp;Self) -&gt; <a class="enum" href="../../core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="enum" href="../../core/cmp/enum.Ordering.html" title="enum core::cmp::Ordering">Ordering</a>&gt;</h4></div></summary><div class='docblock'><p>This method returns an ordering between <code>self</code> and <code>other</code> values if one exists. <a href="../../core/cmp/trait.PartialOrd.html#tymethod.partial_cmp">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.lt" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../../src/core/cmp.rs.html#1029" title="goto source code">[src]</a></div><a href="#method.lt" class="anchor"></a><h4 class="code-header">fn <a href="../../core/cmp/trait.PartialOrd.html#method.lt" class="fnname">lt</a>(&amp;self, other: &amp;Rhs) -&gt; bool</h4></div></summary><div class='docblock'><p>This method tests less than (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;</code> operator. <a href="../../core/cmp/trait.PartialOrd.html#method.lt">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.le" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../../src/core/cmp.rs.html#1048" title="goto source code">[src]</a></div><a href="#method.le" class="anchor"></a><h4 class="code-header">fn <a href="../../core/cmp/trait.PartialOrd.html#method.le" class="fnname">le</a>(&amp;self, other: &amp;Rhs) -&gt; bool</h4></div></summary><div class='docblock'><p>This method tests less than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;=</code>
operator. <a href="../../core/cmp/trait.PartialOrd.html#method.le">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.gt" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../../src/core/cmp.rs.html#1070" title="goto source code">[src]</a></div><a href="#method.gt" class="anchor"></a><h4 class="code-header">fn <a href="../../core/cmp/trait.PartialOrd.html#method.gt" class="fnname">gt</a>(&amp;self, other: &amp;Rhs) -&gt; bool</h4></div></summary><div class='docblock'><p>This method tests greater than (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;</code> operator. <a href="../../core/cmp/trait.PartialOrd.html#method.gt">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.ge" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../../src/core/cmp.rs.html#1089" title="goto source code">[src]</a></div><a href="#method.ge" class="anchor"></a><h4 class="code-header">fn <a href="../../core/cmp/trait.PartialOrd.html#method.ge" class="fnname">ge</a>(&amp;self, other: &amp;Rhs) -&gt; bool</h4></div></summary><div class='docblock'><p>This method tests greater than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;=</code>
operator. <a href="../../core/cmp/trait.PartialOrd.html#method.ge">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open=""><summary><div id="impl-TryFrom%3CVec%3CT%2C%20A%3E%3E" class="impl has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.48.0">1.48.0</span><a class="srclink" href="../../src/alloc/vec/mod.rs.html#2942-2990" title="goto source code">[src]</a></div><a href="#impl-TryFrom%3CVec%3CT%2C%20A%3E%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, A:&nbsp;<a class="trait" href="../alloc/trait.Allocator.html" title="trait alloc::alloc::Allocator">Allocator</a>, const N:&nbsp;usize&gt; <a class="trait" href="../../core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;<a class="struct" href="struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;T, A&gt;&gt; for [T; N]</h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.try_from" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../../src/alloc/vec/mod.rs.html#2974-2989" title="goto source code">[src]</a></div><a href="#method.try_from" class="anchor"></a><h4 class="code-header">fn <a href="../../core/convert/trait.TryFrom.html#tymethod.try_from" class="fnname">try_from</a>(vec: <a class="struct" href="struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;T, A&gt;) -&gt; <a class="enum" href="../../core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;[T; N], <a class="struct" href="struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;T, A&gt;&gt;</h4></div></summary><div class="docblock"><p>Gets the entire contents of the <code>Vec&lt;T&gt;</code> as an array,
if its size exactly matches that of the requested array.</p>
<h1 id="examples-47" class="section-header"><a href="#examples-47">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">std::convert::TryInto</span>;
<span class="macro">assert_eq!</span>(<span class="macro">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].<span class="ident">try_into</span>(), <span class="prelude-val">Ok</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]));
<span class="macro">assert_eq!</span>(<span class="op">&lt;</span><span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">i32</span><span class="op">&gt;</span><span class="op">&gt;</span><span class="ident">::new</span>().<span class="ident">try_into</span>(), <span class="prelude-val">Ok</span>([]));</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Ause%20std%3A%3Aconvert%3A%3ATryInto%3B%0Aassert_eq!(vec!%5B1%2C%202%2C%203%5D.try_into()%2C%20Ok(%5B1%2C%202%2C%203%5D))%3B%0Aassert_eq!(%3CVec%3Ci32%3E%3E%3A%3Anew().try_into()%2C%20Ok(%5B%5D))%3B%0A%7D&amp;edition=2018">Run</a></div>
<p>If the length doesn’t match, the input comes back in <code>Err</code>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">std::convert::TryInto</span>;
<span class="kw">let</span> <span class="ident">r</span>: <span class="prelude-ty">Result</span><span class="op">&lt;</span>[<span class="ident">i32</span>; <span class="number">4</span>], <span class="kw">_</span><span class="op">&gt;</span> <span class="op">=</span> (<span class="number">0</span>..<span class="number">10</span>).<span class="ident">collect</span>::<span class="op">&lt;</span><span class="ident">Vec</span><span class="op">&lt;</span><span class="kw">_</span><span class="op">&gt;</span><span class="op">&gt;</span>().<span class="ident">try_into</span>();
<span class="macro">assert_eq!</span>(<span class="ident">r</span>, <span class="prelude-val">Err</span>(<span class="macro">vec!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]));</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Ause%20std%3A%3Aconvert%3A%3ATryInto%3B%0Alet%20r%3A%20Result%3C%5Bi32%3B%204%5D%2C%20_%3E%20%3D%20(0..10).collect%3A%3A%3CVec%3C_%3E%3E().try_into()%3B%0Aassert_eq!(r%2C%20Err(vec!%5B0%2C%201%2C%202%2C%203%2C%204%2C%205%2C%206%2C%207%2C%208%2C%209%5D))%3B%0A%7D&amp;edition=2018">Run</a></div>
<p>If you’re fine with just getting a prefix of the <code>Vec&lt;T&gt;</code>,
you can call <a href="struct.Vec.html#method.truncate"><code>.truncate(N)</code></a> first.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">std::convert::TryInto</span>;
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">v</span> <span class="op">=</span> <span class="ident">String::from</span>(<span class="string">&quot;hello world&quot;</span>).<span class="ident">into_bytes</span>();
<span class="ident">v</span>.<span class="ident">sort</span>();
<span class="ident">v</span>.<span class="ident">truncate</span>(<span class="number">2</span>);
<span class="kw">let</span> [<span class="ident">a</span>, <span class="ident">b</span>]: [<span class="kw">_</span>; <span class="number">2</span>] <span class="op">=</span> <span class="ident">v</span>.<span class="ident">try_into</span>().<span class="ident">unwrap</span>();
<span class="macro">assert_eq!</span>(<span class="ident">a</span>, <span class="string">b&#39; &#39;</span>);
<span class="macro">assert_eq!</span>(<span class="ident">b</span>, <span class="string">b&#39;d&#39;</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Ause%20std%3A%3Aconvert%3A%3ATryInto%3B%0Alet%20mut%20v%20%3D%20String%3A%3Afrom(%22hello%20world%22).into_bytes()%3B%0Av.sort()%3B%0Av.truncate(2)%3B%0Alet%20%5Ba%2C%20b%5D%3A%20%5B_%3B%202%5D%20%3D%20v.try_into().unwrap()%3B%0Aassert_eq!(a%2C%20b'%20')%3B%0Aassert_eq!(b%2C%20b'd')%3B%0A%7D&amp;edition=2018">Run</a></div>
</div></details><details class="rustdoc-toggle" open=""><summary><div id="associatedtype.Error" class="type trait-impl has-srclink"><a href="#associatedtype.Error" class="anchor"></a><h4 class="code-header">type <a href="../../core/convert/trait.TryFrom.html#associatedtype.Error" class="type">Error</a> = <a class="struct" href="struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;T, A&gt;</h4></div></summary><div class='docblock'><p>The type returned in the event of a conversion error.</p>
</div></details></div></details><div id="impl-Eq" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../../src/alloc/vec/mod.rs.html#2737" title="goto source code">[src]</a></div><a href="#impl-Eq" class="anchor"></a><h3 class="code-header in-band">impl&lt;T:&nbsp;<a class="trait" href="../../core/cmp/trait.Eq.html" title="trait core::cmp::Eq">Eq</a>, A:&nbsp;<a class="trait" href="../alloc/trait.Allocator.html" title="trait alloc::alloc::Allocator">Allocator</a>&gt; <a class="trait" href="../../core/cmp/trait.Eq.html" title="trait core::cmp::Eq">Eq</a> for <a class="struct" href="struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;T, A&gt;</h3></div></div><h2 id="synthetic-implementations" class="small-section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor"></a></h2><div id="synthetic-implementations-list"><div id="impl-RefUnwindSafe" class="impl has-srclink"><div class="rightside"></div><a href="#impl-RefUnwindSafe" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, A&gt; <a class="trait" href="../../core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a> for <a class="struct" href="struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;T, A&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;A: <a class="trait" href="../../core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a>,&nbsp;</span></h3></div><div id="impl-Send" class="impl has-srclink"><div class="rightside"></div><a href="#impl-Send" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, A&gt; <a class="trait" href="../../core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="struct" href="struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;T, A&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;A: <a class="trait" href="../../core/marker/trait.Send.html" title="trait core::marker::Send">Send</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../core/marker/trait.Send.html" title="trait core::marker::Send">Send</a>,&nbsp;</span></h3></div><div id="impl-Sync" class="impl has-srclink"><div class="rightside"></div><a href="#impl-Sync" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, A&gt; <a class="trait" href="../../core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> for <a class="struct" href="struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;T, A&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;A: <a class="trait" href="../../core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a>,&nbsp;</span></h3></div><div id="impl-Unpin" class="impl has-srclink"><div class="rightside"></div><a href="#impl-Unpin" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, A&gt; <a class="trait" href="../../core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a> for <a class="struct" href="struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;T, A&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;A: <a class="trait" href="../../core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a>,&nbsp;</span></h3></div><div id="impl-UnwindSafe" class="impl has-srclink"><div class="rightside"></div><a href="#impl-UnwindSafe" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, A&gt; <a class="trait" href="../../core/panic/unwind_safe/trait.UnwindSafe.html" title="trait core::panic::unwind_safe::UnwindSafe">UnwindSafe</a> for <a class="struct" href="struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;T, A&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;A: <a class="trait" href="../../core/panic/unwind_safe/trait.UnwindSafe.html" title="trait core::panic::unwind_safe::UnwindSafe">UnwindSafe</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../core/panic/unwind_safe/trait.UnwindSafe.html" title="trait core::panic::unwind_safe::UnwindSafe">UnwindSafe</a>,&nbsp;</span></h3></div></div><h2 id="blanket-implementations" class="small-section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor"></a></h2><div id="blanket-implementations-list"><details class="rustdoc-toggle implementors-toggle" open=""><summary><div id="impl-Any" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../../src/core/any.rs.html#132-136" title="goto source code">[src]</a></div><a href="#impl-Any" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="../../core/any/trait.Any.html" title="trait core::any::Any">Any</a> for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'static + ?<a class="trait" href="../../core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.type_id" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../../src/core/any.rs.html#133" title="goto source code">[src]</a></div><a href="#method.type_id" class="anchor"></a><h4 class="code-header">pub fn <a href="../../core/any/trait.Any.html#tymethod.type_id" class="fnname">type_id</a>(&amp;self) -&gt; <a class="struct" href="../../core/any/struct.TypeId.html" title="struct core::any::TypeId">TypeId</a></h4></div></summary><div class='docblock'><p>Gets the <code>TypeId</code> of <code>self</code>. <a href="../../core/any/trait.Any.html#tymethod.type_id">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open=""><summary><div id="impl-Borrow%3CT%3E" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../../src/core/borrow.rs.html#208-213" title="goto source code">[src]</a></div><a href="#impl-Borrow%3CT%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="../borrow/trait.Borrow.html" title="trait alloc::borrow::Borrow">Borrow</a>&lt;T&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="../../core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.borrow-1" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../../src/core/borrow.rs.html#210" title="goto source code">[src]</a></div><a href="#method.borrow-1" class="anchor"></a><h4 class="code-header">pub fn <a href="../borrow/trait.Borrow.html#tymethod.borrow" class="fnname">borrow</a>(&amp;self) -&gt; &amp;T</h4></div></summary><div class='docblock'><p>Immutably borrows from an owned value. <a href="../borrow/trait.Borrow.html#tymethod.borrow">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open=""><summary><div id="impl-BorrowMut%3CT%3E" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../../src/core/borrow.rs.html#216-220" title="goto source code">[src]</a></div><a href="#impl-BorrowMut%3CT%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="../borrow/trait.BorrowMut.html" title="trait alloc::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="../../core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.borrow_mut-1" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../../src/core/borrow.rs.html#217" title="goto source code">[src]</a></div><a href="#method.borrow_mut-1" class="anchor"></a><h4 class="code-header">pub fn <a href="../borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fnname">borrow_mut</a>(&amp;mut self) -&gt; &amp;mut T</h4></div></summary><div class='docblock'><p>Mutably borrows from an owned value. <a href="../borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open=""><summary><div id="impl-From%3CT%3E" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../../src/core/convert/mod.rs.html#546-550" title="goto source code">[src]</a></div><a href="#impl-From%3CT%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="../../core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for T</h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.from-16" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../../src/core/convert/mod.rs.html#547" title="goto source code">[src]</a></div><a href="#method.from-16" class="anchor"></a><h4 class="code-header">pub fn <a href="../../core/convert/trait.From.html#tymethod.from" class="fnname">from</a>(t: T) -&gt; T</h4></div></summary><div class='docblock'><p>Performs the conversion.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open=""><summary><div id="impl-Into%3CU%3E" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../../src/core/convert/mod.rs.html#535-542" title="goto source code">[src]</a></div><a href="#impl-Into%3CU%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, U&gt; <a class="trait" href="../../core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="../../core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt;,&nbsp;</span></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.into" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../../src/core/convert/mod.rs.html#539" title="goto source code">[src]</a></div><a href="#method.into" class="anchor"></a><h4 class="code-header">pub fn <a href="../../core/convert/trait.Into.html#tymethod.into" class="fnname">into</a>(self) -&gt; U</h4></div></summary><div class='docblock'><p>Performs the conversion.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open=""><summary><div id="impl-ToOwned" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../../src/alloc/borrow.rs.html#84-96" title="goto source code">[src]</a></div><a href="#impl-ToOwned" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="../borrow/trait.ToOwned.html" title="trait alloc::borrow::ToOwned">ToOwned</a> for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,&nbsp;</span></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle" open=""><summary><div id="associatedtype.Owned" class="type trait-impl has-srclink"><a href="#associatedtype.Owned" class="anchor"></a><h4 class="code-header">type <a href="../borrow/trait.ToOwned.html#associatedtype.Owned" class="type">Owned</a> = T</h4></div></summary><div class='docblock'><p>The resulting type after obtaining ownership.</p>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.to_owned" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../../src/alloc/borrow.rs.html#89-91" title="goto source code">[src]</a></div><a href="#method.to_owned" class="anchor"></a><h4 class="code-header">pub fn <a href="../borrow/trait.ToOwned.html#tymethod.to_owned" class="fnname">to_owned</a>(&amp;Self) -&gt; T</h4></div></summary><div class='docblock'><p>Creates owned data from borrowed data, usually by cloning. <a href="../borrow/trait.ToOwned.html#tymethod.to_owned">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.clone_into" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../../src/alloc/borrow.rs.html#93-95" title="goto source code">[src]</a></div><a href="#method.clone_into" class="anchor"></a><h4 class="code-header">pub fn <a href="../borrow/trait.ToOwned.html#method.clone_into" class="fnname">clone_into</a>(&amp;Self, &amp;mut T)</h4></div></summary><div class="item-info"><div class="stab unstable"><details><summary><span class="emoji">🔬</span> This is a nightly-only experimental API. (<code>toowned_clone_into</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/41263">#41263</a>)</summary><p>recently added</p>
</details></div></div><div class='docblock'><p>Uses borrowed data to replace owned data, usually by cloning. <a href="../borrow/trait.ToOwned.html#method.clone_into">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open=""><summary><div id="impl-TryFrom%3CU%3E" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../../src/core/convert/mod.rs.html#583-592" title="goto source code">[src]</a></div><a href="#impl-TryFrom%3CU%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, U&gt; <a class="trait" href="../../core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="../../core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;T&gt;,&nbsp;</span></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle" open=""><summary><div id="associatedtype.Error-1" class="type trait-impl has-srclink"><a href="#associatedtype.Error-1" class="anchor"></a><h4 class="code-header">type <a href="../../core/convert/trait.TryFrom.html#associatedtype.Error" class="type">Error</a> = <a class="enum" href="../../core/convert/enum.Infallible.html" title="enum core::convert::Infallible">Infallible</a></h4></div></summary><div class='docblock'><p>The type returned in the event of a conversion error.</p>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.try_from-1" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../../src/core/convert/mod.rs.html#589" title="goto source code">[src]</a></div><a href="#method.try_from-1" class="anchor"></a><h4 class="code-header">pub fn <a href="../../core/convert/trait.TryFrom.html#tymethod.try_from" class="fnname">try_from</a>(value: U) -&gt; <a class="enum" href="../../core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="../../core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="type" href="../../core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></div></summary><div class='docblock'><p>Performs the conversion.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open=""><summary><div id="impl-TryInto%3CU%3E" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../../src/core/convert/mod.rs.html#569-578" title="goto source code">[src]</a></div><a href="#impl-TryInto%3CU%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, U&gt; <a class="trait" href="../../core/convert/trait.TryInto.html" title="trait core::convert::TryInto">TryInto</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="../../core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;,&nbsp;</span></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle" open=""><summary><div id="associatedtype.Error-2" class="type trait-impl has-srclink"><a href="#associatedtype.Error-2" class="anchor"></a><h4 class="code-header">type <a href="../../core/convert/trait.TryInto.html#associatedtype.Error" class="type">Error</a> = &lt;U as <a class="trait" href="../../core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="type" href="../../core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a></h4></div></summary><div class='docblock'><p>The type returned in the event of a conversion error.</p>
</div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.try_into" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../../src/core/convert/mod.rs.html#575" title="goto source code">[src]</a></div><a href="#method.try_into" class="anchor"></a><h4 class="code-header">pub fn <a href="../../core/convert/trait.TryInto.html#tymethod.try_into" class="fnname">try_into</a>(self) -&gt; <a class="enum" href="../../core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="../../core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="type" href="../../core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></div></summary><div class='docblock'><p>Performs the conversion.</p>
</div></details></div></details></div></section><section id="search" class="content hidden"></section><div id="rustdoc-vars" data-root-path="../../" data-current-crate="alloc" data-search-index-js="../../search-index1.56.1.js" data-search-js="../../search1.56.1.js"></div>
    <script src="../../main1.56.1.js"></script>
</body></html>