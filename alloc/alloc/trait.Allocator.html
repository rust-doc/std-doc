<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="An implementation of `Allocator` can allocate, grow, shrink, and deallocate arbitrary blocks of data described via [`Layout`][]."><meta name="keywords" content="rust, rustlang, rust-lang, Allocator"><title>Allocator in alloc::alloc - Rust</title><link rel="stylesheet" type="text/css" href="../../normalize1.58.0.css"><link rel="stylesheet" type="text/css" href="../../rustdoc1.58.0.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../light1.58.0.css" id="themeStyle"><link rel="stylesheet" type="text/css" href="../../dark1.58.0.css" disabled=""><link rel="stylesheet" type="text/css" href="../../ayu1.58.0.css" disabled=""><script id="default-settings"></script><script src="../../storage1.58.0.js"></script><script src="../../crates1.58.0.js"></script><script defer="" src="../../main1.58.0.js"></script>
    <noscript><link rel="stylesheet" href="../../noscript1.58.0.css"></noscript><link rel="alternate icon" type="image/png" href="../../favicon-16x161.58.0.png"><link rel="alternate icon" type="image/png" href="../../favicon-32x321.58.0.png"><link rel="icon" type="image/svg+xml" href="../../favicon1.58.0.svg"><style type="text/css">#crate-search{background-image:url("../../down-arrow1.58.0.svg");}</style></head><body class="rustdoc trait"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu" role="button">&#9776;</div><a href='../../alloc/index.html'><div class='logo-container rust-logo'><img src='../../rust-logo1.58.0.png' alt='logo'></div></a><h2 class="location">Trait Allocator</h2><div class="sidebar-elems"><div class="block items"><h3 class="sidebar-title"><a href="#required-methods">Required Methods</a></h3><div class="sidebar-links"><a href="#tymethod.allocate">allocate</a><a href="#tymethod.deallocate">deallocate</a></div><h3 class="sidebar-title"><a href="#provided-methods">Provided Methods</a></h3><div class="sidebar-links"><a href="#method.allocate_zeroed">allocate_zeroed</a><a href="#method.by_ref">by_ref</a><a href="#method.grow">grow</a><a href="#method.grow_zeroed">grow_zeroed</a><a href="#method.shrink">shrink</a></div><h3 class="sidebar-title"><a href="#foreign-impls">Implementations on Foreign Types</a></h3><div class="sidebar-links"><a href="#impl-Allocator-for-%26%27_%20A">&amp;&#39;_ A</a></div><h3 class="sidebar-title"><a href="#implementors">Implementors</a></h3></div><h2 class="location">Other items in<br><a href="../index.html">alloc</a>::<wbr><a href="index.html">alloc</a></h2><div id="sidebar-vars" data-name="Allocator" data-ty="trait" data-relpath=""></div><script defer="" src="sidebar-items.js"></script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu" title="themes"><img width="18" height="18" alt="Pick another theme!" src="../../brush1.58.0.svg"></button><div id="theme-choices" role="menu"></div></div><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><button type="button" id="help-button" title="help">?</button><a id="settings-menu" href="../../settings.html" title="settings"><img width="18" height="18" alt="Change settings" src="../../wheel1.58.0.svg"></a></div></form></nav><section id="main" class="content"><h1 class="fqn"><span class="in-band">Trait <a href="../index.html">alloc</a>::<wbr><a href="index.html">alloc</a>::<wbr><a class="trait" href="#">Allocator</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../../clipboard1.58.0.svg" width="19" height="18" alt="Copy item path"></button></span><span class="out-of-band"><span id="render-detail"><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span><a class="srclink" href="../../src/core/alloc/mod.rs.html#100-351" title="goto source code">[src]</a></span></h1><div class="docblock item-decl"><pre class="rust trait"><code>pub unsafe trait Allocator {
    fn <a href="#tymethod.allocate" class="fnname">allocate</a>(&amp;self, layout: <a class="struct" href="struct.Layout.html" title="struct alloc::alloc::Layout">Layout</a>) -&gt; <a class="enum" href="../../core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="../../core/ptr/non_null/struct.NonNull.html" title="struct core::ptr::non_null::NonNull">NonNull</a>&lt;<a class="primitive" href="../../core/primitive.slice.html">[</a><a class="primitive" href="../../core/primitive.u8.html">u8</a><a class="primitive" href="../../core/primitive.slice.html">]</a>&gt;, <a class="struct" href="struct.AllocError.html" title="struct alloc::alloc::AllocError">AllocError</a>&gt;;
<div class="item-spacer"></div>    unsafe fn <a href="#tymethod.deallocate" class="fnname">deallocate</a>(&amp;self, ptr: <a class="struct" href="../../core/ptr/non_null/struct.NonNull.html" title="struct core::ptr::non_null::NonNull">NonNull</a>&lt;<a class="primitive" href="../../core/primitive.u8.html">u8</a>&gt;, layout: <a class="struct" href="struct.Layout.html" title="struct alloc::alloc::Layout">Layout</a>);

    fn <a href="#method.allocate_zeroed" class="fnname">allocate_zeroed</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;layout: <a class="struct" href="struct.Layout.html" title="struct alloc::alloc::Layout">Layout</a><br>&nbsp;&nbsp;&nbsp;&nbsp;) -&gt; <a class="enum" href="../../core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="../../core/ptr/non_null/struct.NonNull.html" title="struct core::ptr::non_null::NonNull">NonNull</a>&lt;<a class="primitive" href="../../core/primitive.slice.html">[</a><a class="primitive" href="../../core/primitive.u8.html">u8</a><a class="primitive" href="../../core/primitive.slice.html">]</a>&gt;, <a class="struct" href="struct.AllocError.html" title="struct alloc::alloc::AllocError">AllocError</a>&gt; { ... }
<div class="item-spacer"></div>    unsafe fn <a href="#method.grow" class="fnname">grow</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ptr: <a class="struct" href="../../core/ptr/non_null/struct.NonNull.html" title="struct core::ptr::non_null::NonNull">NonNull</a>&lt;<a class="primitive" href="../../core/primitive.u8.html">u8</a>&gt;, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;old_layout: <a class="struct" href="struct.Layout.html" title="struct alloc::alloc::Layout">Layout</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new_layout: <a class="struct" href="struct.Layout.html" title="struct alloc::alloc::Layout">Layout</a><br>&nbsp;&nbsp;&nbsp;&nbsp;) -&gt; <a class="enum" href="../../core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="../../core/ptr/non_null/struct.NonNull.html" title="struct core::ptr::non_null::NonNull">NonNull</a>&lt;<a class="primitive" href="../../core/primitive.slice.html">[</a><a class="primitive" href="../../core/primitive.u8.html">u8</a><a class="primitive" href="../../core/primitive.slice.html">]</a>&gt;, <a class="struct" href="struct.AllocError.html" title="struct alloc::alloc::AllocError">AllocError</a>&gt; { ... }
<div class="item-spacer"></div>    unsafe fn <a href="#method.grow_zeroed" class="fnname">grow_zeroed</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ptr: <a class="struct" href="../../core/ptr/non_null/struct.NonNull.html" title="struct core::ptr::non_null::NonNull">NonNull</a>&lt;<a class="primitive" href="../../core/primitive.u8.html">u8</a>&gt;, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;old_layout: <a class="struct" href="struct.Layout.html" title="struct alloc::alloc::Layout">Layout</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new_layout: <a class="struct" href="struct.Layout.html" title="struct alloc::alloc::Layout">Layout</a><br>&nbsp;&nbsp;&nbsp;&nbsp;) -&gt; <a class="enum" href="../../core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="../../core/ptr/non_null/struct.NonNull.html" title="struct core::ptr::non_null::NonNull">NonNull</a>&lt;<a class="primitive" href="../../core/primitive.slice.html">[</a><a class="primitive" href="../../core/primitive.u8.html">u8</a><a class="primitive" href="../../core/primitive.slice.html">]</a>&gt;, <a class="struct" href="struct.AllocError.html" title="struct alloc::alloc::AllocError">AllocError</a>&gt; { ... }
<div class="item-spacer"></div>    unsafe fn <a href="#method.shrink" class="fnname">shrink</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ptr: <a class="struct" href="../../core/ptr/non_null/struct.NonNull.html" title="struct core::ptr::non_null::NonNull">NonNull</a>&lt;<a class="primitive" href="../../core/primitive.u8.html">u8</a>&gt;, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;old_layout: <a class="struct" href="struct.Layout.html" title="struct alloc::alloc::Layout">Layout</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new_layout: <a class="struct" href="struct.Layout.html" title="struct alloc::alloc::Layout">Layout</a><br>&nbsp;&nbsp;&nbsp;&nbsp;) -&gt; <a class="enum" href="../../core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="../../core/ptr/non_null/struct.NonNull.html" title="struct core::ptr::non_null::NonNull">NonNull</a>&lt;<a class="primitive" href="../../core/primitive.slice.html">[</a><a class="primitive" href="../../core/primitive.u8.html">u8</a><a class="primitive" href="../../core/primitive.slice.html">]</a>&gt;, <a class="struct" href="struct.AllocError.html" title="struct alloc::alloc::AllocError">AllocError</a>&gt; { ... }
<div class="item-spacer"></div>    fn <a href="#method.by_ref" class="fnname">by_ref</a>(&amp;self) -&gt; <a class="primitive" href="../../core/primitive.reference.html">&amp;</a>Self { ... }
}</code></pre></div><div class="item-info"><div class="stab unstable"><span class="emoji">🔬</span> This is a nightly-only experimental API. (<code>allocator_api</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/32838">#32838</a>)</div></div><details class="rustdoc-toggle top-doc" open=""><summary class="hideme"><span>Expand description</span></summary><div class="docblock" xpath="/html[1]/body[1]/section[1]/details[1]/div[1]" istranslationnode="true" main_mp="Y25yZD4/ZWlsbmM7PkRoaX9ycWV7Zw==" sub_mp="[&quot;YW1sbmc/PmRsbW9iPj9FaXx+c3BgemY=&quot;]"><p class="translate-text">`Allocator` 的实现可以分配、增长、收缩和释放通过“布局”描述的任意数据块。</p><p>An implementation of <code>Allocator</code> can allocate, grow, shrink, and deallocate arbitrary blocks of
data described via <a href="struct.Layout.html" title="Layout"><code>Layout</code></a>.</p>
<p class="translate-text">`Allocator` 被设计为在 ZST、引用或智能指针上实现，因为在不更新指向已分配内存的指针的情况下，无法移动像 `MyAlloc([u8; N])` 这样的分配器。</p><p><code>Allocator</code> is designed to be implemented on ZSTs, references, or smart pointers because having
an allocator like <code>MyAlloc([u8; N])</code> cannot be moved, without updating the pointers to the
allocated memory.</p>
<p class="translate-text">与“GlobalAlloc”不同，在 `Allocator` 中允许零大小的分配。 如果底层分配器不支持这一点（如 jemalloc）或返回空指针（如`libc::malloc`），则必须由实现捕获。</p><p>Unlike <a href="trait.GlobalAlloc.html" title="GlobalAlloc"><code>GlobalAlloc</code></a>, zero-sized allocations are allowed in <code>Allocator</code>. If an underlying
allocator does not support this (like jemalloc) or return a null pointer (such as
<code>libc::malloc</code>), this must be caught by the implementation.</p>
<h4 id="currently-allocated-memory" class="section-header"><a href="#currently-allocated-memory">Currently allocated memory</a></h4>
<p class="translate-text">一些方法要求当前通过分配器分配内存块。 这意味着：</p><p>Some of the methods require that a memory block be <em>currently allocated</em> via an allocator. This
means that:</p>
<ul>
<li class="translate-text">该内存块的起始地址先前由分配、增长或收缩返回，并且</li><li>
<p>the starting address for that memory block was previously returned by <a href="trait.Allocator.html#tymethod.allocate"><code>allocate</code></a>, <a href="trait.Allocator.html#method.grow"><code>grow</code></a>, or
<a href="trait.Allocator.html#method.shrink"><code>shrink</code></a>, and</p>
</li>
<li class="translate-text">内存块随后没有被释放，其中块要么通过传递给 deallocate 直接释放，要么通过传递给返回 Ok 的增长或收缩来更改。 如果增长或收缩返回了 Err，则传递的指针仍然有效。</li><li>
<p>the memory block has not been subsequently deallocated, where blocks are either deallocated
directly by being passed to <a href="trait.Allocator.html#tymethod.deallocate"><code>deallocate</code></a> or were changed by being passed to <a href="trait.Allocator.html#method.grow"><code>grow</code></a> or
<a href="trait.Allocator.html#method.shrink"><code>shrink</code></a> that returns <code>Ok</code>. If <code>grow</code> or <code>shrink</code> have returned <code>Err</code>, the passed pointer
remains valid.</p>
</li>
</ul>
<h4 id="memory-fitting" class="section-header"><a href="#memory-fitting">Memory fitting</a></h4>
<p class="translate-text">一些方法要求布局适合内存块。 布局“适合”内存块意味着（或等效地，内存块“适合”布局）意味着必须满足以下条件：</p><p>Some of the methods require that a layout <em>fit</em> a memory block. What it means for a layout to
“fit” a memory block means (or equivalently, for a memory block to “fit” a layout) is that the
following conditions must hold:</p>
<ul>
<li class="translate-text">该块必须以与 layout.align() 相同的对齐方式分配，并且</li><li>
<p>The block must be allocated with the same alignment as <a href="struct.Layout.html#method.align"><code>layout.align()</code></a>, and</p>
</li>
<li class="translate-text">提供的 layout.size() 必须在 min ..= max 范围内，其中：</li><li>
<p>The provided <a href="struct.Layout.html#method.size"><code>layout.size()</code></a> must fall in the range <code>min ..= max</code>, where:</p>
<ul>
<li class="translate-text">`min` 是最近用于分配块的布局的大小，并且</li><li><code>min</code> is the size of the layout most recently used to allocate the block, and</li>
<li class="translate-text">`max` 是从“allocate”、“grow”或“shrink”返回的最新实际大小。</li><li><code>max</code> is the latest actual size returned from <a href="trait.Allocator.html#tymethod.allocate"><code>allocate</code></a>, <a href="trait.Allocator.html#method.grow"><code>grow</code></a>, or <a href="trait.Allocator.html#method.shrink"><code>shrink</code></a>.</li>
</ul>
</li>
</ul>
<h2 id="safety" class="section-header"><a href="#safety">Safety</a></h2>
<ul>
<li class="translate-text">从分配器返回的内存块必须指向有效内存并保持其有效性，直到删除实例及其所有克隆，</li><li>
<p>Memory blocks returned from an allocator must point to valid memory and retain their validity
until the instance and all of its clones are dropped,</p>
</li>
<li class="translate-text">克隆或移动分配器不得使从此分配器返回的内存块无效。 克隆的分配器必须表现得像同一个分配器，并且</li><li>
<p>cloning or moving the allocator must not invalidate memory blocks returned from this
allocator. A cloned allocator must behave like the same allocator, and</p>
</li>
<li class="translate-text">任何指向当前分配的内存块的指针都可以传递给分配器的任何其他方法。</li><li>
<p>any pointer to a memory block which is <a href="#currently-allocated-memory"><em>currently allocated</em></a> may be passed to any other
method of the allocator.</p>
</li>
</ul>
</div></details><h2 id="required-methods" class="small-section-header">Required methods<a href="#required-methods" class="anchor"></a></h2><div class="methods"><details class="rustdoc-toggle" open=""><summary><div id="tymethod.allocate" class="method has-srclink"><div class="rightside"><a class="srclink" href="../../src/core/alloc/mod.rs.html#121" title="goto source code">[src]</a></div><h4 class="code-header">fn <a href="#tymethod.allocate" class="fnname">allocate</a>(&amp;self, layout: <a class="struct" href="struct.Layout.html" title="struct alloc::alloc::Layout">Layout</a>) -&gt; <a class="enum" href="../../core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="../../core/ptr/non_null/struct.NonNull.html" title="struct core::ptr::non_null::NonNull">NonNull</a>&lt;<a class="primitive" href="../../core/primitive.slice.html">[</a><a class="primitive" href="../../core/primitive.u8.html">u8</a><a class="primitive" href="../../core/primitive.slice.html">]</a>&gt;, <a class="struct" href="struct.AllocError.html" title="struct alloc::alloc::AllocError">AllocError</a>&gt;</h4></div></summary><div class="item-info"><div class="stab unstable"><span class="emoji">🔬</span> This is a nightly-only experimental API. (<code>allocator_api</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/32838">#32838</a>)</div></div><div class="docblock" xpath="/html[1]/body[1]/section[1]/div[3]/details[1]/div[2]" istranslationnode="true" main_mp="Y25yZD4/ZWlsbmM7PkRoaX9ycWV7Zy4vcX18fnd0YHA=" sub_mp="[&quot;YW1sbmc/PmRsbW9iPj9FaXx+c3BgemYvKnB8fXt2dWFF&quot;]"><p class="translate-text">尝试分配一块内存。</p><p>Attempts to allocate a block of memory.</p>
<p class="translate-text">成功时，返回满足 `layout` 的大小和对齐保证的“NonNull<[u8]>”。</p><p>On success, returns a <a href="../../core/ptr/non_null/struct.NonNull.html" title="NonNull"><code>NonNull&lt;[u8]&gt;</code></a> meeting the size and alignment guarantees of <code>layout</code>.</p>
<p class="translate-text">返回的块可能具有比 `layout.size()` 指定的更大的大小，并且可能会或可能不会初始化其内容。</p><p>The returned block may have a larger size than specified by <code>layout.size()</code>, and may or may
not have its contents initialized.</p>
<h5 id="errors" class="section-header"><a href="#errors">Errors</a></h5>
<p class="translate-text">返回 `Err` 表示内存已耗尽或 `layout` 不满足分配器的大小或对齐约束。</p><p>Returning <code>Err</code> indicates that either memory is exhausted or <code>layout</code> does not meet
allocator’s size or alignment constraints.</p>
<p class="translate-text">鼓励实现在内存耗尽时返回“Err”，而不是panic或中止，但这不是严格的要求。 （特别是：在内存耗尽时中止的底层本机分配库之上实现此Trait是合法的。）</p><p>Implementations are encouraged to return <code>Err</code> on memory exhaustion rather than panicking or
aborting, but this is not a strict requirement. (Specifically: it is <em>legal</em> to implement
this trait atop an underlying native allocation library that aborts on memory exhaustion.)</p>
<p class="translate-text">鼓励希望中止计算以响应分配错误的客户端调用“handle_alloc_error”函数，而不是直接调用 `panic!` 或类似的。</p><p>Clients wishing to abort computation in response to an allocation error are encouraged to
call the <a href="../../alloc/alloc/fn.handle_alloc_error.html"><code>handle_alloc_error</code></a> function, rather than directly invoking <code>panic!</code> or similar.</p>
</div></details><details class="rustdoc-toggle" open=""><summary><div id="tymethod.deallocate" class="method has-srclink"><div class="rightside"><a class="srclink" href="../../src/core/alloc/mod.rs.html#154" title="goto source code">[src]</a></div><h4 class="code-header">unsafe fn <a href="#tymethod.deallocate" class="fnname">deallocate</a>(&amp;self, ptr: <a class="struct" href="../../core/ptr/non_null/struct.NonNull.html" title="struct core::ptr::non_null::NonNull">NonNull</a>&lt;<a class="primitive" href="../../core/primitive.u8.html">u8</a>&gt;, layout: <a class="struct" href="struct.Layout.html" title="struct alloc::alloc::Layout">Layout</a>)</h4></div></summary><div class="item-info"><div class="stab unstable"><span class="emoji">🔬</span> This is a nightly-only experimental API. (<code>allocator_api</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/32838">#32838</a>)</div></div><div class="docblock" xpath="/html[1]/body[1]/section[1]/div[3]/details[2]/div[2]" istranslationnode="true" main_mp="Y25yZD4/ZWlsbmM7PkRoaX9ycWV7Zy4vdHRxfXh6d3RURA==" sub_mp="[&quot;YW1sbmc/PmRsbW9iPj9FaXx+c3BgemYvKnV1cHh5e3ZBVUU=&quot;]"><p class="translate-text">释放 `ptr` 引用的内存。</p><p>Deallocates the memory referenced by <code>ptr</code>.</p>
<h5 id="safety-1" class="section-header"><a href="#safety-1">Safety</a></h5>
<ul>
<li class="translate-text">`ptr` 必须表示通过此分配器“当前分配”的内存块，并且</li><li><code>ptr</code> must denote a block of memory <a href="#currently-allocated-memory"><em>currently allocated</em></a> via this allocator, and</li>
<li class="translate-text">`layout` 必须“适合”该内存块。</li><li><code>layout</code> must <a href="#memory-fitting"><em>fit</em></a> that block of memory.</li>
</ul>
</div></details></div><h2 id="provided-methods" class="small-section-header">Provided methods<a href="#provided-methods" class="anchor"></a></h2><div class="methods"><details class="rustdoc-toggle" open=""><summary><div id="method.allocate_zeroed" class="method has-srclink"><div class="rightside"><a class="srclink" href="../../src/core/alloc/mod.rs.html#138" title="goto source code">[src]</a></div><h4 class="code-header">fn <a href="#method.allocate_zeroed" class="fnname">allocate_zeroed</a>(&amp;self, layout: <a class="struct" href="struct.Layout.html" title="struct alloc::alloc::Layout">Layout</a>) -&gt; <a class="enum" href="../../core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="../../core/ptr/non_null/struct.NonNull.html" title="struct core::ptr::non_null::NonNull">NonNull</a>&lt;<a class="primitive" href="../../core/primitive.slice.html">[</a><a class="primitive" href="../../core/primitive.u8.html">u8</a><a class="primitive" href="../../core/primitive.slice.html">]</a>&gt;, <a class="struct" href="struct.AllocError.html" title="struct alloc::alloc::AllocError">AllocError</a>&gt;</h4></div></summary><div class="item-info"><div class="stab unstable"><span class="emoji">🔬</span> This is a nightly-only experimental API. (<code>allocator_api</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/32838">#32838</a>)</div></div><div class="docblock" xpath="/html[1]/body[1]/section[1]/div[4]/details[1]/div[2]" istranslationnode="true" main_mp="Y25yZD4/ZWlsbmM7PkRoaX9ycWV7Zy4vcX18fnd0YHB/W0VTS0BA" sub_mp="[&quot;YW1sbmc/PmRsbW9iPj9FaXx+c3BgemYvKnB8fXt2dWFFflpEVkpBQQ==&quot;]"><p class="translate-text">行为类似于 `allocate`，但也确保返回的内存是零初始化的。</p><p>Behaves like <code>allocate</code>, but also ensures that the returned memory is zero-initialized.</p>
<h5 id="errors-1" class="section-header"><a href="#errors-1">Errors</a></h5>
<p class="translate-text">返回 `Err` 表示内存已耗尽或 `layout` 不满足分配器的大小或对齐约束。</p><p>Returning <code>Err</code> indicates that either memory is exhausted or <code>layout</code> does not meet
allocator’s size or alignment constraints.</p>
<p class="translate-text">鼓励实现在内存耗尽时返回“Err”，而不是panic或中止，但这不是严格的要求。 （特别是：在内存耗尽时中止的底层本机分配库之上实现此Trait是合法的。）</p><p>Implementations are encouraged to return <code>Err</code> on memory exhaustion rather than panicking or
aborting, but this is not a strict requirement. (Specifically: it is <em>legal</em> to implement
this trait atop an underlying native allocation library that aborts on memory exhaustion.)</p>
<p class="translate-text">鼓励希望中止计算以响应分配错误的客户端调用“handle_alloc_error”函数，而不是直接调用 `panic!` 或类似的。</p><p>Clients wishing to abort computation in response to an allocation error are encouraged to
call the <a href="../../alloc/alloc/fn.handle_alloc_error.html"><code>handle_alloc_error</code></a> function, rather than directly invoking <code>panic!</code> or similar.</p>
</div></details><details class="rustdoc-toggle" open=""><summary><div id="method.grow" class="method has-srclink"><div class="rightside"><a class="srclink" href="../../src/core/alloc/mod.rs.html#192-197" title="goto source code">[src]</a></div><h4 class="code-header">unsafe fn <a href="#method.grow" class="fnname">grow</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;ptr: <a class="struct" href="../../core/ptr/non_null/struct.NonNull.html" title="struct core::ptr::non_null::NonNull">NonNull</a>&lt;<a class="primitive" href="../../core/primitive.u8.html">u8</a>&gt;, <br>&nbsp;&nbsp;&nbsp;&nbsp;old_layout: <a class="struct" href="struct.Layout.html" title="struct alloc::alloc::Layout">Layout</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;new_layout: <a class="struct" href="struct.Layout.html" title="struct alloc::alloc::Layout">Layout</a><br>) -&gt; <a class="enum" href="../../core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="../../core/ptr/non_null/struct.NonNull.html" title="struct core::ptr::non_null::NonNull">NonNull</a>&lt;<a class="primitive" href="../../core/primitive.slice.html">[</a><a class="primitive" href="../../core/primitive.u8.html">u8</a><a class="primitive" href="../../core/primitive.slice.html">]</a>&gt;, <a class="struct" href="struct.AllocError.html" title="struct alloc::alloc::AllocError">AllocError</a>&gt;</h4></div></summary><div class="item-info"><div class="stab unstable"><span class="emoji">🔬</span> This is a nightly-only experimental API. (<code>allocator_api</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/32838">#32838</a>)</div></div><div class="docblock" xpath="/html[1]/body[1]/section[1]/div[4]/details[2]/div[2]" istranslationnode="true" main_mp="Y25yZD4/ZWlsbmM7PkRoaX9ycWV7Zy4vd2N/Zg==" sub_mp="[&quot;YW1sbmc/PmRsbW9iPj9FaXx+c3BgemYvKnZifmM=&quot;]"><p class="translate-text">尝试扩展内存块。</p><p>Attempts to extend the memory block.</p>
<p class="translate-text">返回一个新的“NonNull<[u8]>”，其中包含一个指针和已分配内存的实际大小。 该指针适用于保存由 `new_layout` 描述的数据。 为此，分配器可以扩展 `ptr` 引用的分配以适应新布局。</p><p>Returns a new <a href="../../core/ptr/non_null/struct.NonNull.html" title="NonNull"><code>NonNull&lt;[u8]&gt;</code></a> containing a pointer and the actual size of the allocated
memory. The pointer is suitable for holding data described by <code>new_layout</code>. To accomplish
this, the allocator may extend the allocation referenced by <code>ptr</code> to fit the new layout.</p>
<p class="translate-text">如果返回 `Ok`，则 `ptr` 引用的内存块的所有权已转移到此分配器。 内存可能已释放，也可能未释放，除非通过此方法的返回值再次将其转移回调用者，否则应将其视为不可用。</p><p>If this returns <code>Ok</code>, then ownership of the memory block referenced by <code>ptr</code> has been
transferred to this allocator. The memory may or may not have been freed, and should be
considered unusable unless it was transferred back to the caller again via the return value
of this method.</p>
<p class="translate-text">如果此方法返回 `Err`，则内存块的所有权尚未转移到此分配器，并且内存块的内容未更改。</p><p>If this method returns <code>Err</code>, then ownership of the memory block has not been transferred to
this allocator, and the contents of the memory block are unaltered.</p>
<h5 id="safety-2" class="section-header"><a href="#safety-2">Safety</a></h5>
<ul>
<li class="translate-text">`ptr` 必须表示通过此分配器“当前分配”的内存块。</li><li><code>ptr</code> must denote a block of memory <a href="#currently-allocated-memory"><em>currently allocated</em></a> via this allocator.</li>
<li class="translate-text">`old_layout` 必须“适合”该内存块（`new_layout` 参数不需要适合它。）。</li><li><code>old_layout</code> must <a href="#memory-fitting"><em>fit</em></a> that block of memory (The <code>new_layout</code> argument need not fit it.).</li>
<li class="translate-text">`new_layout.size()` 必须大于或等于 `old_layout.size()`。</li><li><code>new_layout.size()</code> must be greater than or equal to <code>old_layout.size()</code>.</li>
</ul>
<h5 id="errors-2" class="section-header"><a href="#errors-2">Errors</a></h5>
<p class="translate-text">如果新布局不满足分配器的大小和分配器的对齐约束，或者增长失败，则返回 `Err`。</p><p>Returns <code>Err</code> if the new layout does not meet the allocator’s size and alignment
constraints of the allocator, or if growing otherwise fails.</p>
<p class="translate-text">鼓励实现在内存耗尽时返回“Err”，而不是panic或中止，但这不是严格的要求。 （特别是：在内存耗尽时中止的底层本机分配库之上实现此Trait是合法的。）</p><p>Implementations are encouraged to return <code>Err</code> on memory exhaustion rather than panicking or
aborting, but this is not a strict requirement. (Specifically: it is <em>legal</em> to implement
this trait atop an underlying native allocation library that aborts on memory exhaustion.)</p>
<p class="translate-text">鼓励希望中止计算以响应分配错误的客户端调用“handle_alloc_error”函数，而不是直接调用 `panic!` 或类似的。</p><p>Clients wishing to abort computation in response to an allocation error are encouraged to
call the <a href="../../alloc/alloc/fn.handle_alloc_error.html"><code>handle_alloc_error</code></a> function, rather than directly invoking <code>panic!</code> or similar.</p>
</div></details><details class="rustdoc-toggle" open=""><summary><div id="method.grow_zeroed" class="method has-srclink"><div class="rightside"><a class="srclink" href="../../src/core/alloc/mod.rs.html#253-258" title="goto source code">[src]</a></div><h4 class="code-header">unsafe fn <a href="#method.grow_zeroed" class="fnname">grow_zeroed</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;ptr: <a class="struct" href="../../core/ptr/non_null/struct.NonNull.html" title="struct core::ptr::non_null::NonNull">NonNull</a>&lt;<a class="primitive" href="../../core/primitive.u8.html">u8</a>&gt;, <br>&nbsp;&nbsp;&nbsp;&nbsp;old_layout: <a class="struct" href="struct.Layout.html" title="struct alloc::alloc::Layout">Layout</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;new_layout: <a class="struct" href="struct.Layout.html" title="struct alloc::alloc::Layout">Layout</a><br>) -&gt; <a class="enum" href="../../core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="../../core/ptr/non_null/struct.NonNull.html" title="struct core::ptr::non_null::NonNull">NonNull</a>&lt;<a class="primitive" href="../../core/primitive.slice.html">[</a><a class="primitive" href="../../core/primitive.u8.html">u8</a><a class="primitive" href="../../core/primitive.slice.html">]</a>&gt;, <a class="struct" href="struct.AllocError.html" title="struct alloc::alloc::AllocError">AllocError</a>&gt;</h4></div></summary><div class="item-info"><div class="stab unstable"><span class="emoji">🔬</span> This is a nightly-only experimental API. (<code>allocator_api</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/32838">#32838</a>)</div></div><div class="docblock" xpath="/html[1]/body[1]/section[1]/div[4]/details[3]/div[2]" istranslationnode="true" main_mp="Y25yZD4/ZWlsbmM7PkRoaX9ycWV7Zy4vd2N/ZktvcWdPREQ=" sub_mp="[&quot;YW1sbmc/PmRsbW9iPj9FaXx+c3BgemYvKnZifmNKbnBSTkVF&quot;]"><p class="translate-text">行为类似于 `grow`，但也确保新内容在返回之前设置为零。</p><p>Behaves like <code>grow</code>, but also ensures that the new contents are set to zero before being
returned.</p>
<p class="translate-text">成功调用 `grow_zeroed` 后，内存块将包含以下内容：</p><p>The memory block will contain the following contents after a successful call to
<code>grow_zeroed</code>:</p>
<ul>
<li class="translate-text">字节 `0..old_layout.size()` 从原始分配中保留下来。</li><li>Bytes <code>0..old_layout.size()</code> are preserved from the original allocation.</li>
<li class="translate-text">字节 `old_layout.size()..old_size` 将被保留或归零，具体取决于分配器的实现。 `old_size` 是指在 `grow_zeroed` 调用之前的内存块大小，它可能大于分配时最初请求的大小。</li><li>Bytes <code>old_layout.size()..old_size</code> will either be preserved or zeroed, depending on
the allocator implementation. <code>old_size</code> refers to the size of the memory block prior
to the <code>grow_zeroed</code> call, which may be larger than the size that was originally
requested when it was allocated.</li>
<li class="translate-text">字节 `old_size..new_size` 被归零。 `new_size` 指的是 `grow_zeroed` 调用返回的内存块的大小。</li><li>Bytes <code>old_size..new_size</code> are zeroed. <code>new_size</code> refers to the size of the memory
block returned by the <code>grow_zeroed</code> call.</li>
</ul>
<h5 id="safety-3" class="section-header"><a href="#safety-3">Safety</a></h5>
<ul>
<li class="translate-text">`ptr` 必须表示通过此分配器“当前分配”的内存块。</li><li><code>ptr</code> must denote a block of memory <a href="#currently-allocated-memory"><em>currently allocated</em></a> via this allocator.</li>
<li class="translate-text">`old_layout` 必须“适合”该内存块（`new_layout` 参数不需要适合它。）。</li><li><code>old_layout</code> must <a href="#memory-fitting"><em>fit</em></a> that block of memory (The <code>new_layout</code> argument need not fit it.).</li>
<li class="translate-text">`new_layout.size()` 必须大于或等于 `old_layout.size()`。</li><li><code>new_layout.size()</code> must be greater than or equal to <code>old_layout.size()</code>.</li>
</ul>
<h5 id="errors-3" class="section-header"><a href="#errors-3">Errors</a></h5>
<p class="translate-text">如果新布局不满足分配器的大小和分配器的对齐约束，或者增长失败，则返回 `Err`。</p><p>Returns <code>Err</code> if the new layout does not meet the allocator’s size and alignment
constraints of the allocator, or if growing otherwise fails.</p>
<p class="translate-text">鼓励实现在内存耗尽时返回“Err”，而不是panic或中止，但这不是严格的要求。 （特别是：在内存耗尽时中止的底层本机分配库之上实现此Trait是合法的。）</p><p>Implementations are encouraged to return <code>Err</code> on memory exhaustion rather than panicking or
aborting, but this is not a strict requirement. (Specifically: it is <em>legal</em> to implement
this trait atop an underlying native allocation library that aborts on memory exhaustion.)</p>
<p class="translate-text">鼓励希望中止计算以响应分配错误的客户端调用“handle_alloc_error”函数，而不是直接调用 `panic!` 或类似的。</p><p>Clients wishing to abort computation in response to an allocation error are encouraged to
call the <a href="../../alloc/alloc/fn.handle_alloc_error.html"><code>handle_alloc_error</code></a> function, rather than directly invoking <code>panic!</code> or similar.</p>
</div></details><details class="rustdoc-toggle" open=""><summary><div id="method.shrink" class="method has-srclink"><div class="rightside"><a class="srclink" href="../../src/core/alloc/mod.rs.html#315-320" title="goto source code">[src]</a></div><h4 class="code-header">unsafe fn <a href="#method.shrink" class="fnname">shrink</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;ptr: <a class="struct" href="../../core/ptr/non_null/struct.NonNull.html" title="struct core::ptr::non_null::NonNull">NonNull</a>&lt;<a class="primitive" href="../../core/primitive.u8.html">u8</a>&gt;, <br>&nbsp;&nbsp;&nbsp;&nbsp;old_layout: <a class="struct" href="struct.Layout.html" title="struct alloc::alloc::Layout">Layout</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;new_layout: <a class="struct" href="struct.Layout.html" title="struct alloc::alloc::Layout">Layout</a><br>) -&gt; <a class="enum" href="../../core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="../../core/ptr/non_null/struct.NonNull.html" title="struct core::ptr::non_null::NonNull">NonNull</a>&lt;<a class="primitive" href="../../core/primitive.slice.html">[</a><a class="primitive" href="../../core/primitive.u8.html">u8</a><a class="primitive" href="../../core/primitive.slice.html">]</a>&gt;, <a class="struct" href="struct.AllocError.html" title="struct alloc::alloc::AllocError">AllocError</a>&gt;</h4></div></summary><div class="item-info"><div class="stab unstable"><span class="emoji">🔬</span> This is a nightly-only experimental API. (<code>allocator_api</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/32838">#32838</a>)</div></div><div class="docblock" xpath="/html[1]/body[1]/section[1]/div[4]/details[4]/div[2]" istranslationnode="true" main_mp="Y25yZD4/ZWlsbmM7PkRoaX9ycWV7Zy4vY3lieHp+" sub_mp="[&quot;YW1sbmc/PmRsbW9iPj9FaXx+c3BgemYvKmJ4Y317fw==&quot;]"><p class="translate-text">尝试缩小内存块。</p><p>Attempts to shrink the memory block.</p>
<p class="translate-text">返回一个新的“NonNull<[u8]>”，其中包含一个指针和已分配内存的实际大小。 该指针适用于保存由 `new_layout` 描述的数据。 为了实现这一点，分配器可能会缩小 `ptr` 引用的分配以适应新布局。</p><p>Returns a new <a href="../../core/ptr/non_null/struct.NonNull.html" title="NonNull"><code>NonNull&lt;[u8]&gt;</code></a> containing a pointer and the actual size of the allocated
memory. The pointer is suitable for holding data described by <code>new_layout</code>. To accomplish
this, the allocator may shrink the allocation referenced by <code>ptr</code> to fit the new layout.</p>
<p class="translate-text">如果返回 `Ok`，则 `ptr` 引用的内存块的所有权已转移到此分配器。 内存可能已释放，也可能未释放，除非通过此方法的返回值再次将其转移回调用者，否则应将其视为不可用。</p><p>If this returns <code>Ok</code>, then ownership of the memory block referenced by <code>ptr</code> has been
transferred to this allocator. The memory may or may not have been freed, and should be
considered unusable unless it was transferred back to the caller again via the return value
of this method.</p>
<p class="translate-text">如果此方法返回 `Err`，则内存块的所有权尚未转移到此分配器，并且内存块的内容未更改。</p><p>If this method returns <code>Err</code>, then ownership of the memory block has not been transferred to
this allocator, and the contents of the memory block are unaltered.</p>
<h5 id="safety-4" class="section-header"><a href="#safety-4">Safety</a></h5>
<ul>
<li class="translate-text">`ptr` 必须表示通过此分配器“当前分配”的内存块。</li><li><code>ptr</code> must denote a block of memory <a href="#currently-allocated-memory"><em>currently allocated</em></a> via this allocator.</li>
<li class="translate-text">`old_layout` 必须“适合”该内存块（`new_layout` 参数不需要适合它。）。</li><li><code>old_layout</code> must <a href="#memory-fitting"><em>fit</em></a> that block of memory (The <code>new_layout</code> argument need not fit it.).</li>
<li class="translate-text">`new_layout.size()` 必须小于或等于 `old_layout.size()`。</li><li><code>new_layout.size()</code> must be smaller than or equal to <code>old_layout.size()</code>.</li>
</ul>
<h5 id="errors-4" class="section-header"><a href="#errors-4">Errors</a></h5>
<p class="translate-text">如果新布局不满足分配器的大小和分配器的对齐约束，或者收缩失败，则返回 `Err`。</p><p>Returns <code>Err</code> if the new layout does not meet the allocator’s size and alignment
constraints of the allocator, or if shrinking otherwise fails.</p>
<p class="translate-text">鼓励实现在内存耗尽时返回“Err”，而不是panic或中止，但这不是严格的要求。 （特别是：在内存耗尽时中止的底层本机分配库之上实现此Trait是合法的。）</p><p>Implementations are encouraged to return <code>Err</code> on memory exhaustion rather than panicking or
aborting, but this is not a strict requirement. (Specifically: it is <em>legal</em> to implement
this trait atop an underlying native allocation library that aborts on memory exhaustion.)</p>
<p class="translate-text">鼓励希望中止计算以响应分配错误的客户端调用“handle_alloc_error”函数，而不是直接调用 `panic!` 或类似的。</p><p>Clients wishing to abort computation in response to an allocation error are encouraged to
call the <a href="../../alloc/alloc/fn.handle_alloc_error.html"><code>handle_alloc_error</code></a> function, rather than directly invoking <code>panic!</code> or similar.</p>
</div></details><details class="rustdoc-toggle" open=""><summary><div id="method.by_ref" class="method has-srclink"><div class="rightside"><a class="srclink" href="../../src/core/alloc/mod.rs.html#345-347" title="goto source code">[src]</a></div><h4 class="code-header">fn <a href="#method.by_ref" class="fnname">by_ref</a>(&amp;self) -&gt; <a class="primitive" href="../../core/primitive.reference.html">&amp;</a>Self</h4></div></summary><div class="item-info"><div class="stab unstable"><span class="emoji">🔬</span> This is a nightly-only experimental API. (<code>allocator_api</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/32838">#32838</a>)</div></div><div class="docblock" xpath="/html[1]/body[1]/section[1]/div[4]/details[5]/div[2]" istranslationnode="true" main_mp="Y25yZD4/ZWlsbmM7PkRoaX9ycWV7Zy4vcmhPY3Fz" sub_mp="[&quot;YW1sbmc/PmRsbW9iPj9FaXx+c3BgemYvKnNpTmZwcg==&quot;]"><p class="translate-text">为此 `Allocator` 实例创建一个“按引用”适配器。</p><p>Creates a “by reference” adapter for this instance of <code>Allocator</code>.</p>
<p class="translate-text">返回的适配器还实现了“分配器”，并且会简单地借用它。</p><p>The returned adapter also implements <code>Allocator</code> and will simply borrow this.</p>
</div></details></div><h2 id="foreign-impls" class="small-section-header">Implementations on Foreign Types<a href="#foreign-impls" class="anchor"></a></h2><details class="rustdoc-toggle implementors-toggle"><summary><div id="impl-Allocator-for-%26%27_%20A" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../../src/core/alloc/mod.rs.html#354-406" title="goto source code">[src]</a></div><a href="#impl-Allocator-for-%26%27_%20A" class="anchor"></a><h3 class="code-header in-band">impl&lt;'_, A&gt; <a class="trait" href="trait.Allocator.html" title="trait alloc::alloc::Allocator">Allocator</a> for <a class="primitive" href="../../core/primitive.reference.html">&amp;'_ </a>A <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;A: <a class="trait" href="trait.Allocator.html" title="trait alloc::alloc::Allocator">Allocator</a> + ?<a class="trait" href="../../core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.allocate" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../../src/core/alloc/mod.rs.html#359" title="goto source code">[src]</a></div><a href="#method.allocate" class="anchor"></a><h4 class="code-header">pub fn <a href="#tymethod.allocate" class="fnname">allocate</a>(&amp;self, layout: <a class="struct" href="struct.Layout.html" title="struct alloc::alloc::Layout">Layout</a>) -&gt; <a class="enum" href="../../core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="../../core/ptr/non_null/struct.NonNull.html" title="struct core::ptr::non_null::NonNull">NonNull</a>&lt;<a class="primitive" href="../../core/primitive.slice.html">[</a><a class="primitive" href="../../core/primitive.u8.html">u8</a><a class="primitive" href="../../core/primitive.slice.html">]</a>&gt;, <a class="struct" href="struct.AllocError.html" title="struct alloc::alloc::AllocError">AllocError</a>&gt;</h4></div></summary><div class="item-info"><div class="stab unstable"><span class="emoji">🔬</span> This is a nightly-only experimental API. (<code>allocator_api</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/32838">#32838</a>)</div></div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.allocate_zeroed-1" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../../src/core/alloc/mod.rs.html#364" title="goto source code">[src]</a></div><a href="#method.allocate_zeroed-1" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.allocate_zeroed" class="fnname">allocate_zeroed</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;layout: <a class="struct" href="struct.Layout.html" title="struct alloc::alloc::Layout">Layout</a><br>) -&gt; <a class="enum" href="../../core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="../../core/ptr/non_null/struct.NonNull.html" title="struct core::ptr::non_null::NonNull">NonNull</a>&lt;<a class="primitive" href="../../core/primitive.slice.html">[</a><a class="primitive" href="../../core/primitive.u8.html">u8</a><a class="primitive" href="../../core/primitive.slice.html">]</a>&gt;, <a class="struct" href="struct.AllocError.html" title="struct alloc::alloc::AllocError">AllocError</a>&gt;</h4></div></summary><div class="item-info"><div class="stab unstable"><span class="emoji">🔬</span> This is a nightly-only experimental API. (<code>allocator_api</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/32838">#32838</a>)</div></div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.deallocate" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../../src/core/alloc/mod.rs.html#369" title="goto source code">[src]</a></div><a href="#method.deallocate" class="anchor"></a><h4 class="code-header">pub unsafe fn <a href="#tymethod.deallocate" class="fnname">deallocate</a>(&amp;self, ptr: <a class="struct" href="../../core/ptr/non_null/struct.NonNull.html" title="struct core::ptr::non_null::NonNull">NonNull</a>&lt;<a class="primitive" href="../../core/primitive.u8.html">u8</a>&gt;, layout: <a class="struct" href="struct.Layout.html" title="struct alloc::alloc::Layout">Layout</a>)</h4></div></summary><div class="item-info"><div class="stab unstable"><span class="emoji">🔬</span> This is a nightly-only experimental API. (<code>allocator_api</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/32838">#32838</a>)</div></div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.grow-1" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../../src/core/alloc/mod.rs.html#375-380" title="goto source code">[src]</a></div><a href="#method.grow-1" class="anchor"></a><h4 class="code-header">pub unsafe fn <a href="#method.grow" class="fnname">grow</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;ptr: <a class="struct" href="../../core/ptr/non_null/struct.NonNull.html" title="struct core::ptr::non_null::NonNull">NonNull</a>&lt;<a class="primitive" href="../../core/primitive.u8.html">u8</a>&gt;, <br>&nbsp;&nbsp;&nbsp;&nbsp;old_layout: <a class="struct" href="struct.Layout.html" title="struct alloc::alloc::Layout">Layout</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;new_layout: <a class="struct" href="struct.Layout.html" title="struct alloc::alloc::Layout">Layout</a><br>) -&gt; <a class="enum" href="../../core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="../../core/ptr/non_null/struct.NonNull.html" title="struct core::ptr::non_null::NonNull">NonNull</a>&lt;<a class="primitive" href="../../core/primitive.slice.html">[</a><a class="primitive" href="../../core/primitive.u8.html">u8</a><a class="primitive" href="../../core/primitive.slice.html">]</a>&gt;, <a class="struct" href="struct.AllocError.html" title="struct alloc::alloc::AllocError">AllocError</a>&gt;</h4></div></summary><div class="item-info"><div class="stab unstable"><span class="emoji">🔬</span> This is a nightly-only experimental API. (<code>allocator_api</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/32838">#32838</a>)</div></div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.grow_zeroed-1" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../../src/core/alloc/mod.rs.html#386-391" title="goto source code">[src]</a></div><a href="#method.grow_zeroed-1" class="anchor"></a><h4 class="code-header">pub unsafe fn <a href="#method.grow_zeroed" class="fnname">grow_zeroed</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;ptr: <a class="struct" href="../../core/ptr/non_null/struct.NonNull.html" title="struct core::ptr::non_null::NonNull">NonNull</a>&lt;<a class="primitive" href="../../core/primitive.u8.html">u8</a>&gt;, <br>&nbsp;&nbsp;&nbsp;&nbsp;old_layout: <a class="struct" href="struct.Layout.html" title="struct alloc::alloc::Layout">Layout</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;new_layout: <a class="struct" href="struct.Layout.html" title="struct alloc::alloc::Layout">Layout</a><br>) -&gt; <a class="enum" href="../../core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="../../core/ptr/non_null/struct.NonNull.html" title="struct core::ptr::non_null::NonNull">NonNull</a>&lt;<a class="primitive" href="../../core/primitive.slice.html">[</a><a class="primitive" href="../../core/primitive.u8.html">u8</a><a class="primitive" href="../../core/primitive.slice.html">]</a>&gt;, <a class="struct" href="struct.AllocError.html" title="struct alloc::alloc::AllocError">AllocError</a>&gt;</h4></div></summary><div class="item-info"><div class="stab unstable"><span class="emoji">🔬</span> This is a nightly-only experimental API. (<code>allocator_api</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/32838">#32838</a>)</div></div></details><details class="rustdoc-toggle method-toggle" open=""><summary><div id="method.shrink-1" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../../src/core/alloc/mod.rs.html#397-402" title="goto source code">[src]</a></div><a href="#method.shrink-1" class="anchor"></a><h4 class="code-header">pub unsafe fn <a href="#method.shrink" class="fnname">shrink</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;ptr: <a class="struct" href="../../core/ptr/non_null/struct.NonNull.html" title="struct core::ptr::non_null::NonNull">NonNull</a>&lt;<a class="primitive" href="../../core/primitive.u8.html">u8</a>&gt;, <br>&nbsp;&nbsp;&nbsp;&nbsp;old_layout: <a class="struct" href="struct.Layout.html" title="struct alloc::alloc::Layout">Layout</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;new_layout: <a class="struct" href="struct.Layout.html" title="struct alloc::alloc::Layout">Layout</a><br>) -&gt; <a class="enum" href="../../core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="../../core/ptr/non_null/struct.NonNull.html" title="struct core::ptr::non_null::NonNull">NonNull</a>&lt;<a class="primitive" href="../../core/primitive.slice.html">[</a><a class="primitive" href="../../core/primitive.u8.html">u8</a><a class="primitive" href="../../core/primitive.slice.html">]</a>&gt;, <a class="struct" href="struct.AllocError.html" title="struct alloc::alloc::AllocError">AllocError</a>&gt;</h4></div></summary><div class="item-info"><div class="stab unstable"><span class="emoji">🔬</span> This is a nightly-only experimental API. (<code>allocator_api</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/32838">#32838</a>)</div></div></details></div></details><h2 id="implementors" class="small-section-header">Implementors<a href="#implementors" class="anchor"></a></h2><div class="item-list" id="implementors-list"><div id="impl-Allocator" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../../src/alloc/alloc.rs.html#226-310" title="goto source code">[src]</a></div><a href="#impl-Allocator" class="anchor"></a><h3 class="code-header in-band">impl <a class="trait" href="trait.Allocator.html" title="trait alloc::alloc::Allocator">Allocator</a> for <a class="struct" href="struct.Global.html" title="struct alloc::alloc::Global">Global</a></h3></div></div><script type="text/javascript" src="../../implementors/core/alloc/trait.Allocator.js" async=""></script></section><section id="search" class="content hidden"></section><div id="rustdoc-vars" data-root-path="../../" data-current-crate="alloc" data-search-index-js="../../search-index1.58.0.js" data-search-js="../../search1.58.0.js"></div>
</body></html>